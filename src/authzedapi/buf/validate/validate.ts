// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "buf/validate/validate.proto" (package "buf.validate", syntax proto2)
// tslint:disable
//
// Copyright 2023-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FieldDescriptorProto_Type } from "../../google/protobuf/descriptor.js";
import { Timestamp } from "../../google/protobuf/timestamp.js";
import { Duration } from "../../google/protobuf/duration.js";
/**
 * `Constraint` represents a validation rule written in the Common Expression
 * Language (CEL) syntax. Each Constraint includes a unique identifier, an
 * optional error message, and the CEL expression to evaluate. For more
 * information on CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
 *
 * ```proto
 * message Foo {
 *   option (buf.validate.message).cel = {
 *     id: "foo.bar"
 *     message: "bar must be greater than 0"
 *     expression: "this.bar > 0"
 *   };
 *   int32 bar = 1;
 * }
 * ```
 *
 * @generated from protobuf message buf.validate.Constraint
 */
export interface Constraint {
    /**
     * `id` is a string that serves as a machine-readable name for this Constraint.
     * It should be unique within its scope, which could be either a message or a field.
     *
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * `message` is an optional field that provides a human-readable error message
     * for this Constraint when the CEL expression evaluates to false. If a
     * non-empty message is provided, any strings resulting from the CEL
     * expression evaluation are ignored.
     *
     * @generated from protobuf field: optional string message = 2;
     */
    message?: string;
    /**
     * `expression` is the actual CEL expression that will be evaluated for
     * validation. This string must resolve to either a boolean or a string
     * value. If the expression evaluates to false or a non-empty string, the
     * validation is considered failed, and the message is rejected.
     *
     * @generated from protobuf field: optional string expression = 3;
     */
    expression?: string;
}
/**
 * MessageConstraints represents validation rules that are applied to the entire message.
 * It includes disabling options and a list of Constraint messages representing Common Expression Language (CEL) validation rules.
 *
 * @generated from protobuf message buf.validate.MessageConstraints
 */
export interface MessageConstraints {
    /**
     * `disabled` is a boolean flag that, when set to true, nullifies any validation rules for this message.
     * This includes any fields within the message that would otherwise support validation.
     *
     * ```proto
     * message MyMessage {
     *   // validation will be bypassed for this message
     *   option (buf.validate.message).disabled = true;
     * }
     * ```
     *
     * @generated from protobuf field: optional bool disabled = 1;
     */
    disabled?: boolean;
    /**
     * `cel` is a repeated field of type Constraint. Each Constraint specifies a validation rule to be applied to this message.
     * These constraints are written in Common Expression Language (CEL) syntax. For more information on
     * CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
     *
     *
     * ```proto
     * message MyMessage {
     *   // The field `foo` must be greater than 42.
     *   option (buf.validate.message).cel = {
     *     id: "my_message.value",
     *     message: "value must be greater than 42",
     *     expression: "this.foo > 42",
     *   };
     *   optional int32 foo = 1;
     * }
     * ```
     *
     * @generated from protobuf field: repeated buf.validate.Constraint cel = 3;
     */
    cel: Constraint[];
}
/**
 * The `OneofConstraints` message type enables you to manage constraints for
 * oneof fields in your protobuf messages.
 *
 * @generated from protobuf message buf.validate.OneofConstraints
 */
export interface OneofConstraints {
    /**
     * If `required` is true, exactly one field of the oneof must be present. A
     * validation error is returned if no fields in the oneof are present. The
     * field itself may still be a default value; further constraints
     * should be placed on the fields themselves to ensure they are valid values,
     * such as `min_len` or `gt`.
     *
     * ```proto
     * message MyMessage {
     *   oneof value {
     *     // Either `a` or `b` must be set. If `a` is set, it must also be
     *     // non-empty; whereas if `b` is set, it can still be an empty string.
     *     option (buf.validate.oneof).required = true;
     *     string a = 1 [(buf.validate.field).string.min_len = 1];
     *     string b = 2;
     *   }
     * }
     * ```
     *
     * @generated from protobuf field: optional bool required = 1;
     */
    required?: boolean;
}
/**
 * FieldConstraints encapsulates the rules for each type of field. Depending on
 * the field, the correct set should be used to ensure proper validations.
 *
 * @generated from protobuf message buf.validate.FieldConstraints
 */
export interface FieldConstraints {
    /**
     * `cel` is a repeated field used to represent a textual expression
     * in the Common Expression Language (CEL) syntax. For more information on
     * CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
     *
     * ```proto
     * message MyMessage {
     *   // The field `value` must be greater than 42.
     *   optional int32 value = 1 [(buf.validate.field).cel = {
     *     id: "my_message.value",
     *     message: "value must be greater than 42",
     *     expression: "this > 42",
     *   }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated buf.validate.Constraint cel = 23;
     */
    cel: Constraint[];
    /**
     * If `required` is true, the field must be populated. A populated field can be
     * described as "serialized in the wire format," which includes:
     *
     * - the following "nullable" fields must be explicitly set to be considered populated:
     *   - singular message fields (whose fields may be unpopulated/default values)
     *   - member fields of a oneof (may be their default value)
     *   - proto3 optional fields (may be their default value)
     *   - proto2 scalar fields (both optional and required)
     * - proto3 scalar fields must be non-zero to be considered populated
     * - repeated and map fields must be non-empty to be considered populated
     *
     * ```proto
     * message MyMessage {
     *   // The field `value` must be set to a non-null value.
     *   optional MyOtherMessage value = 1 [(buf.validate.field).required = true];
     * }
     * ```
     *
     * @generated from protobuf field: optional bool required = 25;
     */
    required?: boolean;
    /**
     * Skip validation on the field if its value matches the specified criteria.
     * See Ignore enum for details.
     *
     * ```proto
     * message UpdateRequest {
     *   // The uri rule only applies if the field is populated and not an empty
     *   // string.
     *   optional string url = 1 [
     *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE,
     *     (buf.validate.field).string.uri = true,
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: optional buf.validate.Ignore ignore = 27;
     */
    ignore?: Ignore;
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "float";
        /**
         * Scalar Field Types
         *
         * @generated from protobuf field: buf.validate.FloatRules float = 1;
         */
        float: FloatRules;
    } | {
        oneofKind: "double";
        /**
         * @generated from protobuf field: buf.validate.DoubleRules double = 2;
         */
        double: DoubleRules;
    } | {
        oneofKind: "int32";
        /**
         * @generated from protobuf field: buf.validate.Int32Rules int32 = 3;
         */
        int32: Int32Rules;
    } | {
        oneofKind: "int64";
        /**
         * @generated from protobuf field: buf.validate.Int64Rules int64 = 4;
         */
        int64: Int64Rules;
    } | {
        oneofKind: "uint32";
        /**
         * @generated from protobuf field: buf.validate.UInt32Rules uint32 = 5;
         */
        uint32: UInt32Rules;
    } | {
        oneofKind: "uint64";
        /**
         * @generated from protobuf field: buf.validate.UInt64Rules uint64 = 6;
         */
        uint64: UInt64Rules;
    } | {
        oneofKind: "sint32";
        /**
         * @generated from protobuf field: buf.validate.SInt32Rules sint32 = 7;
         */
        sint32: SInt32Rules;
    } | {
        oneofKind: "sint64";
        /**
         * @generated from protobuf field: buf.validate.SInt64Rules sint64 = 8;
         */
        sint64: SInt64Rules;
    } | {
        oneofKind: "fixed32";
        /**
         * @generated from protobuf field: buf.validate.Fixed32Rules fixed32 = 9;
         */
        fixed32: Fixed32Rules;
    } | {
        oneofKind: "fixed64";
        /**
         * @generated from protobuf field: buf.validate.Fixed64Rules fixed64 = 10;
         */
        fixed64: Fixed64Rules;
    } | {
        oneofKind: "sfixed32";
        /**
         * @generated from protobuf field: buf.validate.SFixed32Rules sfixed32 = 11;
         */
        sfixed32: SFixed32Rules;
    } | {
        oneofKind: "sfixed64";
        /**
         * @generated from protobuf field: buf.validate.SFixed64Rules sfixed64 = 12;
         */
        sfixed64: SFixed64Rules;
    } | {
        oneofKind: "bool";
        /**
         * @generated from protobuf field: buf.validate.BoolRules bool = 13;
         */
        bool: BoolRules;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: buf.validate.StringRules string = 14;
         */
        string: StringRules;
    } | {
        oneofKind: "bytes";
        /**
         * @generated from protobuf field: buf.validate.BytesRules bytes = 15;
         */
        bytes: BytesRules;
    } | {
        oneofKind: "enum";
        /**
         * Complex Field Types
         *
         * @generated from protobuf field: buf.validate.EnumRules enum = 16;
         */
        enum: EnumRules;
    } | {
        oneofKind: "repeated";
        /**
         * @generated from protobuf field: buf.validate.RepeatedRules repeated = 18;
         */
        repeated: RepeatedRules;
    } | {
        oneofKind: "map";
        /**
         * @generated from protobuf field: buf.validate.MapRules map = 19;
         */
        map: MapRules;
    } | {
        oneofKind: "any";
        /**
         * Well-Known Field Types
         *
         * @generated from protobuf field: buf.validate.AnyRules any = 20;
         */
        any: AnyRules;
    } | {
        oneofKind: "duration";
        /**
         * @generated from protobuf field: buf.validate.DurationRules duration = 21;
         */
        duration: DurationRules;
    } | {
        oneofKind: "timestamp";
        /**
         * @generated from protobuf field: buf.validate.TimestampRules timestamp = 22;
         */
        timestamp: TimestampRules;
    } | {
        oneofKind: undefined;
    };
}
/**
 * PredefinedConstraints are custom constraints that can be re-used with
 * multiple fields.
 *
 * @generated from protobuf message buf.validate.PredefinedConstraints
 */
export interface PredefinedConstraints {
    /**
     * `cel` is a repeated field used to represent a textual expression
     * in the Common Expression Language (CEL) syntax. For more information on
     * CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
     *
     * ```proto
     * message MyMessage {
     *   // The field `value` must be greater than 42.
     *   optional int32 value = 1 [(buf.validate.predefined).cel = {
     *     id: "my_message.value",
     *     message: "value must be greater than 42",
     *     expression: "this > 42",
     *   }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated buf.validate.Constraint cel = 1;
     */
    cel: Constraint[];
}
/**
 * FloatRules describes the constraints applied to `float` values. These
 * rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.FloatRules
 */
export interface FloatRules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyFloat {
     *   // value must equal 42.0
     *   float value = 1 [(buf.validate.field).float.const = 42.0];
     * }
     * ```
     *
     * @generated from protobuf field: optional float const = 1;
     */
    const?: number;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MyFloat {
         *   // value must be less than 10.0
         *   float value = 1 [(buf.validate.field).float.lt = 10.0];
         * }
         * ```
         *
         * @generated from protobuf field: float lt = 2;
         */
        lt: number;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyFloat {
         *   // value must be less than or equal to 10.0
         *   float value = 1 [(buf.validate.field).float.lte = 10.0];
         * }
         * ```
         *
         * @generated from protobuf field: float lte = 3;
         */
        lte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyFloat {
         *   // value must be greater than 5.0 [float.gt]
         *   float value = 1 [(buf.validate.field).float.gt = 5.0];
         *
         *   // value must be greater than 5 and less than 10.0 [float.gt_lt]
         *   float other_value = 2 [(buf.validate.field).float = { gt: 5.0, lt: 10.0 }];
         *
         *   // value must be greater than 10 or less than 5.0 [float.gt_lt_exclusive]
         *   float another_value = 3 [(buf.validate.field).float = { gt: 10.0, lt: 5.0 }];
         * }
         * ```
         *
         * @generated from protobuf field: float gt = 4;
         */
        gt: number;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyFloat {
         *   // value must be greater than or equal to 5.0 [float.gte]
         *   float value = 1 [(buf.validate.field).float.gte = 5.0];
         *
         *   // value must be greater than or equal to 5.0 and less than 10.0 [float.gte_lt]
         *   float other_value = 2 [(buf.validate.field).float = { gte: 5.0, lt: 10.0 }];
         *
         *   // value must be greater than or equal to 10.0 or less than 5.0 [float.gte_lt_exclusive]
         *   float another_value = 3 [(buf.validate.field).float = { gte: 10.0, lt: 5.0 }];
         * }
         * ```
         *
         * @generated from protobuf field: float gte = 5;
         */
        gte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message
     * is generated.
     *
     * ```proto
     * message MyFloat {
     *   // value must be in list [1.0, 2.0, 3.0]
     *   float value = 1 [(buf.validate.field).float = { in: [1.0, 2.0, 3.0] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated float in = 6;
     */
    in: number[];
    /**
     * `in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MyFloat {
     *   // value must not be in list [1.0, 2.0, 3.0]
     *   float value = 1 [(buf.validate.field).float = { not_in: [1.0, 2.0, 3.0] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated float not_in = 7;
     */
    notIn: number[];
    /**
     * `finite` requires the field value to be finite. If the field value is
     * infinite or NaN, an error message is generated.
     *
     * @generated from protobuf field: optional bool finite = 8;
     */
    finite?: boolean;
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyFloat {
     *   float value = 1 [
     *     (buf.validate.field).float.example = 1.0,
     *     (buf.validate.field).float.example = "Infinity"
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated float example = 9;
     */
    example: number[];
}
/**
 * DoubleRules describes the constraints applied to `double` values. These
 * rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.DoubleRules
 */
export interface DoubleRules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyDouble {
     *   // value must equal 42.0
     *   double value = 1 [(buf.validate.field).double.const = 42.0];
     * }
     * ```
     *
     * @generated from protobuf field: optional double const = 1;
     */
    const?: number;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyDouble {
         *   // value must be less than 10.0
         *   double value = 1 [(buf.validate.field).double.lt = 10.0];
         * }
         * ```
         *
         * @generated from protobuf field: double lt = 2;
         */
        lt: number;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified value
         * (field <= value). If the field value is greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MyDouble {
         *   // value must be less than or equal to 10.0
         *   double value = 1 [(buf.validate.field).double.lte = 10.0];
         * }
         * ```
         *
         * @generated from protobuf field: double lte = 3;
         */
        lte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,
         * the range is reversed, and the field value must be outside the specified
         * range. If the field value doesn't meet the required conditions, an error
         * message is generated.
         *
         * ```proto
         * message MyDouble {
         *   // value must be greater than 5.0 [double.gt]
         *   double value = 1 [(buf.validate.field).double.gt = 5.0];
         *
         *   // value must be greater than 5 and less than 10.0 [double.gt_lt]
         *   double other_value = 2 [(buf.validate.field).double = { gt: 5.0, lt: 10.0 }];
         *
         *   // value must be greater than 10 or less than 5.0 [double.gt_lt_exclusive]
         *   double another_value = 3 [(buf.validate.field).double = { gt: 10.0, lt: 5.0 }];
         * }
         * ```
         *
         * @generated from protobuf field: double gt = 4;
         */
        gt: number;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyDouble {
         *   // value must be greater than or equal to 5.0 [double.gte]
         *   double value = 1 [(buf.validate.field).double.gte = 5.0];
         *
         *   // value must be greater than or equal to 5.0 and less than 10.0 [double.gte_lt]
         *   double other_value = 2 [(buf.validate.field).double = { gte: 5.0, lt: 10.0 }];
         *
         *   // value must be greater than or equal to 10.0 or less than 5.0 [double.gte_lt_exclusive]
         *   double another_value = 3 [(buf.validate.field).double = { gte: 10.0, lt: 5.0 }];
         * }
         * ```
         *
         * @generated from protobuf field: double gte = 5;
         */
        gte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MyDouble {
     *   // value must be in list [1.0, 2.0, 3.0]
     *   double value = 1 [(buf.validate.field).double = { in: [1.0, 2.0, 3.0] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated double in = 6;
     */
    in: number[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MyDouble {
     *   // value must not be in list [1.0, 2.0, 3.0]
     *   double value = 1 [(buf.validate.field).double = { not_in: [1.0, 2.0, 3.0] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated double not_in = 7;
     */
    notIn: number[];
    /**
     * `finite` requires the field value to be finite. If the field value is
     * infinite or NaN, an error message is generated.
     *
     * @generated from protobuf field: optional bool finite = 8;
     */
    finite?: boolean;
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyDouble {
     *   double value = 1 [
     *     (buf.validate.field).double.example = 1.0,
     *     (buf.validate.field).double.example = "Infinity"
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated double example = 9;
     */
    example: number[];
}
/**
 * Int32Rules describes the constraints applied to `int32` values. These
 * rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.Int32Rules
 */
export interface Int32Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyInt32 {
     *   // value must equal 42
     *   int32 value = 1 [(buf.validate.field).int32.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional int32 const = 1;
     */
    const?: number;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field
         * < value). If the field value is equal to or greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyInt32 {
         *   // value must be less than 10
         *   int32 value = 1 [(buf.validate.field).int32.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: int32 lt = 2;
         */
        lt: number;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyInt32 {
         *   // value must be less than or equal to 10
         *   int32 value = 1 [(buf.validate.field).int32.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: int32 lte = 3;
         */
        lte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyInt32 {
         *   // value must be greater than 5 [int32.gt]
         *   int32 value = 1 [(buf.validate.field).int32.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [int32.gt_lt]
         *   int32 other_value = 2 [(buf.validate.field).int32 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [int32.gt_lt_exclusive]
         *   int32 another_value = 3 [(buf.validate.field).int32 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: int32 gt = 4;
         */
        gt: number;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified value
         * (exclusive). If the value of `gte` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyInt32 {
         *   // value must be greater than or equal to 5 [int32.gte]
         *   int32 value = 1 [(buf.validate.field).int32.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [int32.gte_lt]
         *   int32 other_value = 2 [(buf.validate.field).int32 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [int32.gte_lt_exclusive]
         *   int32 another_value = 3 [(buf.validate.field).int32 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: int32 gte = 5;
         */
        gte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MyInt32 {
     *   // value must be in list [1, 2, 3]
     *   int32 value = 1 [(buf.validate.field).int32 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated int32 in = 6;
     */
    in: number[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error message
     * is generated.
     *
     * ```proto
     * message MyInt32 {
     *   // value must not be in list [1, 2, 3]
     *   int32 value = 1 [(buf.validate.field).int32 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated int32 not_in = 7;
     */
    notIn: number[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyInt32 {
     *   int32 value = 1 [
     *     (buf.validate.field).int32.example = 1,
     *     (buf.validate.field).int32.example = -10
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated int32 example = 8;
     */
    example: number[];
}
/**
 * Int64Rules describes the constraints applied to `int64` values. These
 * rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.Int64Rules
 */
export interface Int64Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyInt64 {
     *   // value must equal 42
     *   int64 value = 1 [(buf.validate.field).int64.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional int64 const = 1;
     */
    const?: string;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MyInt64 {
         *   // value must be less than 10
         *   int64 value = 1 [(buf.validate.field).int64.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: int64 lt = 2;
         */
        lt: string;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyInt64 {
         *   // value must be less than or equal to 10
         *   int64 value = 1 [(buf.validate.field).int64.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: int64 lte = 3;
         */
        lte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyInt64 {
         *   // value must be greater than 5 [int64.gt]
         *   int64 value = 1 [(buf.validate.field).int64.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [int64.gt_lt]
         *   int64 other_value = 2 [(buf.validate.field).int64 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [int64.gt_lt_exclusive]
         *   int64 another_value = 3 [(buf.validate.field).int64 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: int64 gt = 4;
         */
        gt: string;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyInt64 {
         *   // value must be greater than or equal to 5 [int64.gte]
         *   int64 value = 1 [(buf.validate.field).int64.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [int64.gte_lt]
         *   int64 other_value = 2 [(buf.validate.field).int64 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [int64.gte_lt_exclusive]
         *   int64 another_value = 3 [(buf.validate.field).int64 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: int64 gte = 5;
         */
        gte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MyInt64 {
     *   // value must be in list [1, 2, 3]
     *   int64 value = 1 [(buf.validate.field).int64 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated int64 in = 6;
     */
    in: string[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MyInt64 {
     *   // value must not be in list [1, 2, 3]
     *   int64 value = 1 [(buf.validate.field).int64 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated int64 not_in = 7;
     */
    notIn: string[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyInt64 {
     *   int64 value = 1 [
     *     (buf.validate.field).int64.example = 1,
     *     (buf.validate.field).int64.example = -10
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated int64 example = 9;
     */
    example: string[];
}
/**
 * UInt32Rules describes the constraints applied to `uint32` values. These
 * rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.UInt32Rules
 */
export interface UInt32Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyUInt32 {
     *   // value must equal 42
     *   uint32 value = 1 [(buf.validate.field).uint32.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint32 const = 1;
     */
    const?: number;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MyUInt32 {
         *   // value must be less than 10
         *   uint32 value = 1 [(buf.validate.field).uint32.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: uint32 lt = 2;
         */
        lt: number;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyUInt32 {
         *   // value must be less than or equal to 10
         *   uint32 value = 1 [(buf.validate.field).uint32.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: uint32 lte = 3;
         */
        lte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyUInt32 {
         *   // value must be greater than 5 [uint32.gt]
         *   uint32 value = 1 [(buf.validate.field).uint32.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [uint32.gt_lt]
         *   uint32 other_value = 2 [(buf.validate.field).uint32 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [uint32.gt_lt_exclusive]
         *   uint32 another_value = 3 [(buf.validate.field).uint32 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: uint32 gt = 4;
         */
        gt: number;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyUInt32 {
         *   // value must be greater than or equal to 5 [uint32.gte]
         *   uint32 value = 1 [(buf.validate.field).uint32.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [uint32.gte_lt]
         *   uint32 other_value = 2 [(buf.validate.field).uint32 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [uint32.gte_lt_exclusive]
         *   uint32 another_value = 3 [(buf.validate.field).uint32 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: uint32 gte = 5;
         */
        gte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MyUInt32 {
     *   // value must be in list [1, 2, 3]
     *   uint32 value = 1 [(buf.validate.field).uint32 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated uint32 in = 6;
     */
    in: number[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MyUInt32 {
     *   // value must not be in list [1, 2, 3]
     *   uint32 value = 1 [(buf.validate.field).uint32 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated uint32 not_in = 7;
     */
    notIn: number[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyUInt32 {
     *   uint32 value = 1 [
     *     (buf.validate.field).uint32.example = 1,
     *     (buf.validate.field).uint32.example = 10
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated uint32 example = 8;
     */
    example: number[];
}
/**
 * UInt64Rules describes the constraints applied to `uint64` values. These
 * rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.UInt64Rules
 */
export interface UInt64Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyUInt64 {
     *   // value must equal 42
     *   uint64 value = 1 [(buf.validate.field).uint64.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 const = 1;
     */
    const?: string;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MyUInt64 {
         *   // value must be less than 10
         *   uint64 value = 1 [(buf.validate.field).uint64.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: uint64 lt = 2;
         */
        lt: string;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyUInt64 {
         *   // value must be less than or equal to 10
         *   uint64 value = 1 [(buf.validate.field).uint64.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: uint64 lte = 3;
         */
        lte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyUInt64 {
         *   // value must be greater than 5 [uint64.gt]
         *   uint64 value = 1 [(buf.validate.field).uint64.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [uint64.gt_lt]
         *   uint64 other_value = 2 [(buf.validate.field).uint64 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [uint64.gt_lt_exclusive]
         *   uint64 another_value = 3 [(buf.validate.field).uint64 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: uint64 gt = 4;
         */
        gt: string;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyUInt64 {
         *   // value must be greater than or equal to 5 [uint64.gte]
         *   uint64 value = 1 [(buf.validate.field).uint64.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [uint64.gte_lt]
         *   uint64 other_value = 2 [(buf.validate.field).uint64 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [uint64.gte_lt_exclusive]
         *   uint64 another_value = 3 [(buf.validate.field).uint64 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: uint64 gte = 5;
         */
        gte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MyUInt64 {
     *   // value must be in list [1, 2, 3]
     *   uint64 value = 1 [(buf.validate.field).uint64 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated uint64 in = 6;
     */
    in: string[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MyUInt64 {
     *   // value must not be in list [1, 2, 3]
     *   uint64 value = 1 [(buf.validate.field).uint64 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated uint64 not_in = 7;
     */
    notIn: string[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyUInt64 {
     *   uint64 value = 1 [
     *     (buf.validate.field).uint64.example = 1,
     *     (buf.validate.field).uint64.example = -10
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated uint64 example = 8;
     */
    example: string[];
}
/**
 * SInt32Rules describes the constraints applied to `sint32` values.
 *
 * @generated from protobuf message buf.validate.SInt32Rules
 */
export interface SInt32Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MySInt32 {
     *   // value must equal 42
     *   sint32 value = 1 [(buf.validate.field).sint32.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional sint32 const = 1;
     */
    const?: number;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field
         * < value). If the field value is equal to or greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MySInt32 {
         *   // value must be less than 10
         *   sint32 value = 1 [(buf.validate.field).sint32.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: sint32 lt = 2;
         */
        lt: number;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MySInt32 {
         *   // value must be less than or equal to 10
         *   sint32 value = 1 [(buf.validate.field).sint32.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: sint32 lte = 3;
         */
        lte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MySInt32 {
         *   // value must be greater than 5 [sint32.gt]
         *   sint32 value = 1 [(buf.validate.field).sint32.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [sint32.gt_lt]
         *   sint32 other_value = 2 [(buf.validate.field).sint32 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [sint32.gt_lt_exclusive]
         *   sint32 another_value = 3 [(buf.validate.field).sint32 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: sint32 gt = 4;
         */
        gt: number;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MySInt32 {
         *  // value must be greater than or equal to 5 [sint32.gte]
         *  sint32 value = 1 [(buf.validate.field).sint32.gte = 5];
         *
         *  // value must be greater than or equal to 5 and less than 10 [sint32.gte_lt]
         *  sint32 other_value = 2 [(buf.validate.field).sint32 = { gte: 5, lt: 10 }];
         *
         *  // value must be greater than or equal to 10 or less than 5 [sint32.gte_lt_exclusive]
         *  sint32 another_value = 3 [(buf.validate.field).sint32 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: sint32 gte = 5;
         */
        gte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MySInt32 {
     *   // value must be in list [1, 2, 3]
     *   sint32 value = 1 [(buf.validate.field).sint32 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sint32 in = 6;
     */
    in: number[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MySInt32 {
     *   // value must not be in list [1, 2, 3]
     *   sint32 value = 1 [(buf.validate.field).sint32 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sint32 not_in = 7;
     */
    notIn: number[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MySInt32 {
     *   sint32 value = 1 [
     *     (buf.validate.field).sint32.example = 1,
     *     (buf.validate.field).sint32.example = -10
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sint32 example = 8;
     */
    example: number[];
}
/**
 * SInt64Rules describes the constraints applied to `sint64` values.
 *
 * @generated from protobuf message buf.validate.SInt64Rules
 */
export interface SInt64Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MySInt64 {
     *   // value must equal 42
     *   sint64 value = 1 [(buf.validate.field).sint64.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional sint64 const = 1;
     */
    const?: string;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field
         * < value). If the field value is equal to or greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MySInt64 {
         *   // value must be less than 10
         *   sint64 value = 1 [(buf.validate.field).sint64.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: sint64 lt = 2;
         */
        lt: string;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MySInt64 {
         *   // value must be less than or equal to 10
         *   sint64 value = 1 [(buf.validate.field).sint64.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: sint64 lte = 3;
         */
        lte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MySInt64 {
         *   // value must be greater than 5 [sint64.gt]
         *   sint64 value = 1 [(buf.validate.field).sint64.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [sint64.gt_lt]
         *   sint64 other_value = 2 [(buf.validate.field).sint64 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [sint64.gt_lt_exclusive]
         *   sint64 another_value = 3 [(buf.validate.field).sint64 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: sint64 gt = 4;
         */
        gt: string;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MySInt64 {
         *   // value must be greater than or equal to 5 [sint64.gte]
         *   sint64 value = 1 [(buf.validate.field).sint64.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [sint64.gte_lt]
         *   sint64 other_value = 2 [(buf.validate.field).sint64 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [sint64.gte_lt_exclusive]
         *   sint64 another_value = 3 [(buf.validate.field).sint64 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: sint64 gte = 5;
         */
        gte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message
     * is generated.
     *
     * ```proto
     * message MySInt64 {
     *   // value must be in list [1, 2, 3]
     *   sint64 value = 1 [(buf.validate.field).sint64 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sint64 in = 6;
     */
    in: string[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MySInt64 {
     *   // value must not be in list [1, 2, 3]
     *   sint64 value = 1 [(buf.validate.field).sint64 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sint64 not_in = 7;
     */
    notIn: string[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MySInt64 {
     *   sint64 value = 1 [
     *     (buf.validate.field).sint64.example = 1,
     *     (buf.validate.field).sint64.example = -10
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sint64 example = 8;
     */
    example: string[];
}
/**
 * Fixed32Rules describes the constraints applied to `fixed32` values.
 *
 * @generated from protobuf message buf.validate.Fixed32Rules
 */
export interface Fixed32Rules {
    /**
     * `const` requires the field value to exactly match the specified value.
     * If the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyFixed32 {
     *   // value must equal 42
     *   fixed32 value = 1 [(buf.validate.field).fixed32.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional fixed32 const = 1;
     */
    const?: number;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MyFixed32 {
         *   // value must be less than 10
         *   fixed32 value = 1 [(buf.validate.field).fixed32.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: fixed32 lt = 2;
         */
        lt: number;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyFixed32 {
         *   // value must be less than or equal to 10
         *   fixed32 value = 1 [(buf.validate.field).fixed32.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: fixed32 lte = 3;
         */
        lte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyFixed32 {
         *   // value must be greater than 5 [fixed32.gt]
         *   fixed32 value = 1 [(buf.validate.field).fixed32.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [fixed32.gt_lt]
         *   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [fixed32.gt_lt_exclusive]
         *   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: fixed32 gt = 4;
         */
        gt: number;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyFixed32 {
         *   // value must be greater than or equal to 5 [fixed32.gte]
         *   fixed32 value = 1 [(buf.validate.field).fixed32.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [fixed32.gte_lt]
         *   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [fixed32.gte_lt_exclusive]
         *   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: fixed32 gte = 5;
         */
        gte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message
     * is generated.
     *
     * ```proto
     * message MyFixed32 {
     *   // value must be in list [1, 2, 3]
     *   fixed32 value = 1 [(buf.validate.field).fixed32 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated fixed32 in = 6;
     */
    in: number[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MyFixed32 {
     *   // value must not be in list [1, 2, 3]
     *   fixed32 value = 1 [(buf.validate.field).fixed32 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated fixed32 not_in = 7;
     */
    notIn: number[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyFixed32 {
     *   fixed32 value = 1 [
     *     (buf.validate.field).fixed32.example = 1,
     *     (buf.validate.field).fixed32.example = 2
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated fixed32 example = 8;
     */
    example: number[];
}
/**
 * Fixed64Rules describes the constraints applied to `fixed64` values.
 *
 * @generated from protobuf message buf.validate.Fixed64Rules
 */
export interface Fixed64Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyFixed64 {
     *   // value must equal 42
     *   fixed64 value = 1 [(buf.validate.field).fixed64.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional fixed64 const = 1;
     */
    const?: string;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MyFixed64 {
         *   // value must be less than 10
         *   fixed64 value = 1 [(buf.validate.field).fixed64.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: fixed64 lt = 2;
         */
        lt: string;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MyFixed64 {
         *   // value must be less than or equal to 10
         *   fixed64 value = 1 [(buf.validate.field).fixed64.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: fixed64 lte = 3;
         */
        lte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyFixed64 {
         *   // value must be greater than 5 [fixed64.gt]
         *   fixed64 value = 1 [(buf.validate.field).fixed64.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [fixed64.gt_lt]
         *   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [fixed64.gt_lt_exclusive]
         *   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: fixed64 gt = 4;
         */
        gt: string;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyFixed64 {
         *   // value must be greater than or equal to 5 [fixed64.gte]
         *   fixed64 value = 1 [(buf.validate.field).fixed64.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [fixed64.gte_lt]
         *   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [fixed64.gte_lt_exclusive]
         *   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: fixed64 gte = 5;
         */
        gte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MyFixed64 {
     *   // value must be in list [1, 2, 3]
     *   fixed64 value = 1 [(buf.validate.field).fixed64 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated fixed64 in = 6;
     */
    in: string[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MyFixed64 {
     *   // value must not be in list [1, 2, 3]
     *   fixed64 value = 1 [(buf.validate.field).fixed64 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated fixed64 not_in = 7;
     */
    notIn: string[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyFixed64 {
     *   fixed64 value = 1 [
     *     (buf.validate.field).fixed64.example = 1,
     *     (buf.validate.field).fixed64.example = 2
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated fixed64 example = 8;
     */
    example: string[];
}
/**
 * SFixed32Rules describes the constraints applied to `fixed32` values.
 *
 * @generated from protobuf message buf.validate.SFixed32Rules
 */
export interface SFixed32Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MySFixed32 {
     *   // value must equal 42
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional sfixed32 const = 1;
     */
    const?: number;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MySFixed32 {
         *   // value must be less than 10
         *   sfixed32 value = 1 [(buf.validate.field).sfixed32.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: sfixed32 lt = 2;
         */
        lt: number;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MySFixed32 {
         *   // value must be less than or equal to 10
         *   sfixed32 value = 1 [(buf.validate.field).sfixed32.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: sfixed32 lte = 3;
         */
        lte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MySFixed32 {
         *   // value must be greater than 5 [sfixed32.gt]
         *   sfixed32 value = 1 [(buf.validate.field).sfixed32.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [sfixed32.gt_lt]
         *   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [sfixed32.gt_lt_exclusive]
         *   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: sfixed32 gt = 4;
         */
        gt: number;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MySFixed32 {
         *   // value must be greater than or equal to 5 [sfixed32.gte]
         *   sfixed32 value = 1 [(buf.validate.field).sfixed32.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [sfixed32.gte_lt]
         *   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [sfixed32.gte_lt_exclusive]
         *   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: sfixed32 gte = 5;
         */
        gte: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MySFixed32 {
     *   // value must be in list [1, 2, 3]
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sfixed32 in = 6;
     */
    in: number[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MySFixed32 {
     *   // value must not be in list [1, 2, 3]
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sfixed32 not_in = 7;
     */
    notIn: number[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MySFixed32 {
     *   sfixed32 value = 1 [
     *     (buf.validate.field).sfixed32.example = 1,
     *     (buf.validate.field).sfixed32.example = 2
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sfixed32 example = 8;
     */
    example: number[];
}
/**
 * SFixed64Rules describes the constraints applied to `fixed64` values.
 *
 * @generated from protobuf message buf.validate.SFixed64Rules
 */
export interface SFixed64Rules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MySFixed64 {
     *   // value must equal 42
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.const = 42];
     * }
     * ```
     *
     * @generated from protobuf field: optional sfixed64 const = 1;
     */
    const?: string;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` requires the field value to be less than the specified value (field <
         * value). If the field value is equal to or greater than the specified value,
         * an error message is generated.
         *
         * ```proto
         * message MySFixed64 {
         *   // value must be less than 10
         *   sfixed64 value = 1 [(buf.validate.field).sfixed64.lt = 10];
         * }
         * ```
         *
         * @generated from protobuf field: sfixed64 lt = 2;
         */
        lt: string;
    } | {
        oneofKind: "lte";
        /**
         * `lte` requires the field value to be less than or equal to the specified
         * value (field <= value). If the field value is greater than the specified
         * value, an error message is generated.
         *
         * ```proto
         * message MySFixed64 {
         *   // value must be less than or equal to 10
         *   sfixed64 value = 1 [(buf.validate.field).sfixed64.lte = 10];
         * }
         * ```
         *
         * @generated from protobuf field: sfixed64 lte = 3;
         */
        lte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the field value to be greater than the specified value
         * (exclusive). If the value of `gt` is larger than a specified `lt` or
         * `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MySFixed64 {
         *   // value must be greater than 5 [sfixed64.gt]
         *   sfixed64 value = 1 [(buf.validate.field).sfixed64.gt = 5];
         *
         *   // value must be greater than 5 and less than 10 [sfixed64.gt_lt]
         *   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }];
         *
         *   // value must be greater than 10 or less than 5 [sfixed64.gt_lt_exclusive]
         *   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: sfixed64 gt = 4;
         */
        gt: string;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the field value to be greater than or equal to the specified
         * value (exclusive). If the value of `gte` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MySFixed64 {
         *   // value must be greater than or equal to 5 [sfixed64.gte]
         *   sfixed64 value = 1 [(buf.validate.field).sfixed64.gte = 5];
         *
         *   // value must be greater than or equal to 5 and less than 10 [sfixed64.gte_lt]
         *   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }];
         *
         *   // value must be greater than or equal to 10 or less than 5 [sfixed64.gte_lt_exclusive]
         *   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }];
         * }
         * ```
         *
         * @generated from protobuf field: sfixed64 gte = 5;
         */
        gte: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` requires the field value to be equal to one of the specified values.
     * If the field value isn't one of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MySFixed64 {
     *   // value must be in list [1, 2, 3]
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sfixed64 in = 6;
     */
    in: string[];
    /**
     * `not_in` requires the field value to not be equal to any of the specified
     * values. If the field value is one of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MySFixed64 {
     *   // value must not be in list [1, 2, 3]
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { not_in: [1, 2, 3] }];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sfixed64 not_in = 7;
     */
    notIn: string[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MySFixed64 {
     *   sfixed64 value = 1 [
     *     (buf.validate.field).sfixed64.example = 1,
     *     (buf.validate.field).sfixed64.example = 2
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated sfixed64 example = 8;
     */
    example: string[];
}
/**
 * BoolRules describes the constraints applied to `bool` values. These rules
 * may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.BoolRules
 */
export interface BoolRules {
    /**
     * `const` requires the field value to exactly match the specified boolean value.
     * If the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyBool {
     *   // value must equal true
     *   bool value = 1 [(buf.validate.field).bool.const = true];
     * }
     * ```
     *
     * @generated from protobuf field: optional bool const = 1;
     */
    const?: boolean;
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyBool {
     *   bool value = 1 [
     *     (buf.validate.field).bool.example = 1,
     *     (buf.validate.field).bool.example = 2
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated bool example = 2;
     */
    example: boolean[];
}
/**
 * StringRules describes the constraints applied to `string` values These
 * rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.StringRules
 */
export interface StringRules {
    /**
     * `const` requires the field value to exactly match the specified value. If
     * the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyString {
     *   // value must equal `hello`
     *   string value = 1 [(buf.validate.field).string.const = "hello"];
     * }
     * ```
     *
     * @generated from protobuf field: optional string const = 1;
     */
    const?: string;
    /**
     * `len` dictates that the field value must have the specified
     * number of characters (Unicode code points), which may differ from the number
     * of bytes in the string. If the field value does not meet the specified
     * length, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value length must be 5 characters
     *   string value = 1 [(buf.validate.field).string.len = 5];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 len = 19;
     */
    len?: string;
    /**
     * `min_len` specifies that the field value must have at least the specified
     * number of characters (Unicode code points), which may differ from the number
     * of bytes in the string. If the field value contains fewer characters, an error
     * message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value length must be at least 3 characters
     *   string value = 1 [(buf.validate.field).string.min_len = 3];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 min_len = 2;
     */
    minLen?: string;
    /**
     * `max_len` specifies that the field value must have no more than the specified
     * number of characters (Unicode code points), which may differ from the
     * number of bytes in the string. If the field value contains more characters,
     * an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value length must be at most 10 characters
     *   string value = 1 [(buf.validate.field).string.max_len = 10];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 max_len = 3;
     */
    maxLen?: string;
    /**
     * `len_bytes` dictates that the field value must have the specified number of
     * bytes. If the field value does not match the specified length in bytes,
     * an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value length must be 6 bytes
     *   string value = 1 [(buf.validate.field).string.len_bytes = 6];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 len_bytes = 20;
     */
    lenBytes?: string;
    /**
     * `min_bytes` specifies that the field value must have at least the specified
     * number of bytes. If the field value contains fewer bytes, an error message
     * will be generated.
     *
     * ```proto
     * message MyString {
     *   // value length must be at least 4 bytes
     *   string value = 1 [(buf.validate.field).string.min_bytes = 4];
     * }
     *
     * ```
     *
     * @generated from protobuf field: optional uint64 min_bytes = 4;
     */
    minBytes?: string;
    /**
     * `max_bytes` specifies that the field value must have no more than the
     * specified number of bytes. If the field value contains more bytes, an
     * error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value length must be at most 8 bytes
     *   string value = 1 [(buf.validate.field).string.max_bytes = 8];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 max_bytes = 5;
     */
    maxBytes?: string;
    /**
     * `pattern` specifies that the field value must match the specified
     * regular expression (RE2 syntax), with the expression provided without any
     * delimiters. If the field value doesn't match the regular expression, an
     * error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value does not match regex pattern `^[a-zA-Z]//$`
     *   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
     * }
     * ```
     *
     * @generated from protobuf field: optional string pattern = 6;
     */
    pattern?: string;
    /**
     * `prefix` specifies that the field value must have the
     * specified substring at the beginning of the string. If the field value
     * doesn't start with the specified prefix, an error message will be
     * generated.
     *
     * ```proto
     * message MyString {
     *   // value does not have prefix `pre`
     *   string value = 1 [(buf.validate.field).string.prefix = "pre"];
     * }
     * ```
     *
     * @generated from protobuf field: optional string prefix = 7;
     */
    prefix?: string;
    /**
     * `suffix` specifies that the field value must have the
     * specified substring at the end of the string. If the field value doesn't
     * end with the specified suffix, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value does not have suffix `post`
     *   string value = 1 [(buf.validate.field).string.suffix = "post"];
     * }
     * ```
     *
     * @generated from protobuf field: optional string suffix = 8;
     */
    suffix?: string;
    /**
     * `contains` specifies that the field value must have the
     * specified substring anywhere in the string. If the field value doesn't
     * contain the specified substring, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value does not contain substring `inside`.
     *   string value = 1 [(buf.validate.field).string.contains = "inside"];
     * }
     * ```
     *
     * @generated from protobuf field: optional string contains = 9;
     */
    contains?: string;
    /**
     * `not_contains` specifies that the field value must not have the
     * specified substring anywhere in the string. If the field value contains
     * the specified substring, an error message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value contains substring `inside`.
     *   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
     * }
     * ```
     *
     * @generated from protobuf field: optional string not_contains = 23;
     */
    notContains?: string;
    /**
     * `in` specifies that the field value must be equal to one of the specified
     * values. If the field value isn't one of the specified values, an error
     * message will be generated.
     *
     * ```proto
     * message MyString {
     *   // value must be in list ["apple", "banana"]
     *   string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
     * }
     * ```
     *
     * @generated from protobuf field: repeated string in = 10;
     */
    in: string[];
    /**
     * `not_in` specifies that the field value cannot be equal to any
     * of the specified values. If the field value is one of the specified values,
     * an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must not be in list ["orange", "grape"]
     *   string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
     * }
     * ```
     *
     * @generated from protobuf field: repeated string not_in = 11;
     */
    notIn: string[];
    /**
     * @generated from protobuf oneof: well_known
     */
    wellKnown: {
        oneofKind: "email";
        /**
         * `email` specifies that the field value must be a valid email address
         * (addr-spec only) as defined by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1).
         * If the field value isn't a valid email address, an error message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid email address
         *   string value = 1 [(buf.validate.field).string.email = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool email = 12;
         */
        email: boolean;
    } | {
        oneofKind: "hostname";
        /**
         * `hostname` specifies that the field value must be a valid
         * hostname as defined by [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5). This constraint doesn't support
         * internationalized domain names (IDNs). If the field value isn't a
         * valid hostname, an error message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid hostname
         *   string value = 1 [(buf.validate.field).string.hostname = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool hostname = 13;
         */
        hostname: boolean;
    } | {
        oneofKind: "ip";
        /**
         * `ip` specifies that the field value must be a valid IP
         * (v4 or v6) address, without surrounding square brackets for IPv6 addresses.
         * If the field value isn't a valid IP address, an error message will be
         * generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IP address
         *   string value = 1 [(buf.validate.field).string.ip = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ip = 14;
         */
        ip: boolean;
    } | {
        oneofKind: "ipv4";
        /**
         * `ipv4` specifies that the field value must be a valid IPv4
         * address. If the field value isn't a valid IPv4 address, an error message
         * will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IPv4 address
         *   string value = 1 [(buf.validate.field).string.ipv4 = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ipv4 = 15;
         */
        ipv4: boolean;
    } | {
        oneofKind: "ipv6";
        /**
         * `ipv6` specifies that the field value must be a valid
         * IPv6 address, without surrounding square brackets. If the field value is
         * not a valid IPv6 address, an error message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IPv6 address
         *   string value = 1 [(buf.validate.field).string.ipv6 = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ipv6 = 16;
         */
        ipv6: boolean;
    } | {
        oneofKind: "uri";
        /**
         * `uri` specifies that the field value must be a valid URI as defined by
         * [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-3).
         *
         * If the field value isn't a valid URI, an error message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid URI
         *   string value = 1 [(buf.validate.field).string.uri = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool uri = 17;
         */
        uri: boolean;
    } | {
        oneofKind: "uriRef";
        /**
         * `uri_ref` specifies that the field value must be a valid URI Reference as
         * defined by [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-4.1).
         *
         * A URI Reference is either a [URI](https://datatracker.ietf.org/doc/html/rfc3986#section-3),
         * or a [Relative Reference](https://datatracker.ietf.org/doc/html/rfc3986#section-4.2).
         *
         * If the field value isn't a valid URI Reference, an error message will be
         * generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid URI Reference
         *   string value = 1 [(buf.validate.field).string.uri_ref = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool uri_ref = 18;
         */
        uriRef: boolean;
    } | {
        oneofKind: "address";
        /**
         * `address` specifies that the field value must be either a valid hostname
         * as defined by [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5)
         * (which doesn't support internationalized domain names or IDNs) or a valid
         * IP (v4 or v6). If the field value isn't a valid hostname or IP, an error
         * message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid hostname, or ip address
         *   string value = 1 [(buf.validate.field).string.address = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool address = 21;
         */
        address: boolean;
    } | {
        oneofKind: "uuid";
        /**
         * `uuid` specifies that the field value must be a valid UUID as defined by
         * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2). If the
         * field value isn't a valid UUID, an error message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid UUID
         *   string value = 1 [(buf.validate.field).string.uuid = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool uuid = 22;
         */
        uuid: boolean;
    } | {
        oneofKind: "tuuid";
        /**
         * `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
         * defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2) with all dashes
         * omitted. If the field value isn't a valid UUID without dashes, an error message
         * will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid trimmed UUID
         *   string value = 1 [(buf.validate.field).string.tuuid = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool tuuid = 33;
         */
        tuuid: boolean;
    } | {
        oneofKind: "ipWithPrefixlen";
        /**
         * `ip_with_prefixlen` specifies that the field value must be a valid IP (v4 or v6)
         * address with prefix length. If the field value isn't a valid IP with prefix
         * length, an error message will be generated.
         *
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IP with prefix length
         *    string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ip_with_prefixlen = 26;
         */
        ipWithPrefixlen: boolean;
    } | {
        oneofKind: "ipv4WithPrefixlen";
        /**
         * `ipv4_with_prefixlen` specifies that the field value must be a valid
         * IPv4 address with prefix.
         * If the field value isn't a valid IPv4 address with prefix length,
         * an error message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IPv4 address with prefix length
         *    string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ipv4_with_prefixlen = 27;
         */
        ipv4WithPrefixlen: boolean;
    } | {
        oneofKind: "ipv6WithPrefixlen";
        /**
         * `ipv6_with_prefixlen` specifies that the field value must be a valid
         * IPv6 address with prefix length.
         * If the field value is not a valid IPv6 address with prefix length,
         * an error message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IPv6 address prefix length
         *    string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ipv6_with_prefixlen = 28;
         */
        ipv6WithPrefixlen: boolean;
    } | {
        oneofKind: "ipPrefix";
        /**
         * `ip_prefix` specifies that the field value must be a valid IP (v4 or v6) prefix.
         * If the field value isn't a valid IP prefix, an error message will be
         * generated. The prefix must have all zeros for the masked bits of the prefix (e.g.,
         * `127.0.0.0/16`, not `127.0.0.1/16`).
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IP prefix
         *    string value = 1 [(buf.validate.field).string.ip_prefix = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ip_prefix = 29;
         */
        ipPrefix: boolean;
    } | {
        oneofKind: "ipv4Prefix";
        /**
         * `ipv4_prefix` specifies that the field value must be a valid IPv4
         * prefix. If the field value isn't a valid IPv4 prefix, an error message
         * will be generated. The prefix must have all zeros for the masked bits of
         * the prefix (e.g., `127.0.0.0/16`, not `127.0.0.1/16`).
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IPv4 prefix
         *    string value = 1 [(buf.validate.field).string.ipv4_prefix = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ipv4_prefix = 30;
         */
        ipv4Prefix: boolean;
    } | {
        oneofKind: "ipv6Prefix";
        /**
         * `ipv6_prefix` specifies that the field value must be a valid IPv6 prefix.
         * If the field value is not a valid IPv6 prefix, an error message will be
         * generated. The prefix must have all zeros for the masked bits of the prefix
         * (e.g., `2001:db8::/48`, not `2001:db8::1/48`).
         *
         * ```proto
         * message MyString {
         *   // value must be a valid IPv6 prefix
         *    string value = 1 [(buf.validate.field).string.ipv6_prefix = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ipv6_prefix = 31;
         */
        ipv6Prefix: boolean;
    } | {
        oneofKind: "hostAndPort";
        /**
         * `host_and_port` specifies the field value must be a valid host and port
         * pair. The host must be a valid hostname or IP address while the port
         * must be in the range of 0-65535, inclusive. IPv6 addresses must be delimited
         * with square brackets (e.g., `[::1]:1234`).
         *
         * @generated from protobuf field: bool host_and_port = 32;
         */
        hostAndPort: boolean;
    } | {
        oneofKind: "wellKnownRegex";
        /**
         * `well_known_regex` specifies a common well-known pattern
         * defined as a regex. If the field value doesn't match the well-known
         * regex, an error message will be generated.
         *
         * ```proto
         * message MyString {
         *   // value must be a valid HTTP header value
         *   string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];
         * }
         * ```
         *
         * #### KnownRegex
         *
         * `well_known_regex` contains some well-known patterns.
         *
         * | Name                          | Number | Description                               |
         * |-------------------------------|--------|-------------------------------------------|
         * | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
         * | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2)  |
         * | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4) |
         *
         * @generated from protobuf field: buf.validate.KnownRegex well_known_regex = 24;
         */
        wellKnownRegex: KnownRegex;
    } | {
        oneofKind: undefined;
    };
    /**
     * This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
     * enable strict header validation. By default, this is true, and HTTP header
     * validations are [RFC-compliant](https://datatracker.ietf.org/doc/html/rfc7230#section-3). Setting to false will enable looser
     * validations that only disallow `\r\n\0` characters, which can be used to
     * bypass header matching rules.
     *
     * ```proto
     * message MyString {
     *   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
     *   string value = 1 [(buf.validate.field).string.strict = false];
     * }
     * ```
     *
     * @generated from protobuf field: optional bool strict = 25;
     */
    strict?: boolean;
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyString {
     *   string value = 1 [
     *     (buf.validate.field).string.example = "hello",
     *     (buf.validate.field).string.example = "world"
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated string example = 34;
     */
    example: string[];
}
/**
 * BytesRules describe the constraints applied to `bytes` values. These rules
 * may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.
 *
 * @generated from protobuf message buf.validate.BytesRules
 */
export interface BytesRules {
    /**
     * `const` requires the field value to exactly match the specified bytes
     * value. If the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value must be "\x01\x02\x03\x04"
     *   bytes value = 1 [(buf.validate.field).bytes.const = "\x01\x02\x03\x04"];
     * }
     * ```
     *
     * @generated from protobuf field: optional bytes const = 1;
     */
    const?: Uint8Array;
    /**
     * `len` requires the field value to have the specified length in bytes.
     * If the field value doesn't match, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value length must be 4 bytes.
     *   optional bytes value = 1 [(buf.validate.field).bytes.len = 4];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 len = 13;
     */
    len?: string;
    /**
     * `min_len` requires the field value to have at least the specified minimum
     * length in bytes.
     * If the field value doesn't meet the requirement, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value length must be at least 2 bytes.
     *   optional bytes value = 1 [(buf.validate.field).bytes.min_len = 2];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 min_len = 2;
     */
    minLen?: string;
    /**
     * `max_len` requires the field value to have at most the specified maximum
     * length in bytes.
     * If the field value exceeds the requirement, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value must be at most 6 bytes.
     *   optional bytes value = 1 [(buf.validate.field).bytes.max_len = 6];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 max_len = 3;
     */
    maxLen?: string;
    /**
     * `pattern` requires the field value to match the specified regular
     * expression ([RE2 syntax](https://github.com/google/re2/wiki/Syntax)).
     * The value of the field must be valid UTF-8 or validation will fail with a
     * runtime error.
     * If the field value doesn't match the pattern, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value must match regex pattern "^[a-zA-Z0-9]+$".
     *   optional bytes value = 1 [(buf.validate.field).bytes.pattern = "^[a-zA-Z0-9]+$"];
     * }
     * ```
     *
     * @generated from protobuf field: optional string pattern = 4;
     */
    pattern?: string;
    /**
     * `prefix` requires the field value to have the specified bytes at the
     * beginning of the string.
     * If the field value doesn't meet the requirement, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value does not have prefix \x01\x02
     *   optional bytes value = 1 [(buf.validate.field).bytes.prefix = "\x01\x02"];
     * }
     * ```
     *
     * @generated from protobuf field: optional bytes prefix = 5;
     */
    prefix?: Uint8Array;
    /**
     * `suffix` requires the field value to have the specified bytes at the end
     * of the string.
     * If the field value doesn't meet the requirement, an error message is generated.
     *
     * ```proto
     * message MyBytes {
     *   // value does not have suffix \x03\x04
     *   optional bytes value = 1 [(buf.validate.field).bytes.suffix = "\x03\x04"];
     * }
     * ```
     *
     * @generated from protobuf field: optional bytes suffix = 6;
     */
    suffix?: Uint8Array;
    /**
     * `contains` requires the field value to have the specified bytes anywhere in
     * the string.
     * If the field value doesn't meet the requirement, an error message is generated.
     *
     * ```protobuf
     * message MyBytes {
     *   // value does not contain \x02\x03
     *   optional bytes value = 1 [(buf.validate.field).bytes.contains = "\x02\x03"];
     * }
     * ```
     *
     * @generated from protobuf field: optional bytes contains = 7;
     */
    contains?: Uint8Array;
    /**
     * `in` requires the field value to be equal to one of the specified
     * values. If the field value doesn't match any of the specified values, an
     * error message is generated.
     *
     * ```protobuf
     * message MyBytes {
     *   // value must in ["\x01\x02", "\x02\x03", "\x03\x04"]
     *   optional bytes value = 1 [(buf.validate.field).bytes.in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
     * }
     * ```
     *
     * @generated from protobuf field: repeated bytes in = 8;
     */
    in: Uint8Array[];
    /**
     * `not_in` requires the field value to be not equal to any of the specified
     * values.
     * If the field value matches any of the specified values, an error message is
     * generated.
     *
     * ```proto
     * message MyBytes {
     *   // value must not in ["\x01\x02", "\x02\x03", "\x03\x04"]
     *   optional bytes value = 1 [(buf.validate.field).bytes.not_in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
     * }
     * ```
     *
     * @generated from protobuf field: repeated bytes not_in = 9;
     */
    notIn: Uint8Array[];
    /**
     * @generated from protobuf oneof: well_known
     */
    wellKnown: {
        oneofKind: "ip";
        /**
         * `ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.
         * If the field value doesn't meet this constraint, an error message is generated.
         *
         * ```proto
         * message MyBytes {
         *   // value must be a valid IP address
         *   optional bytes value = 1 [(buf.validate.field).bytes.ip = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ip = 10;
         */
        ip: boolean;
    } | {
        oneofKind: "ipv4";
        /**
         * `ipv4` ensures that the field `value` is a valid IPv4 address in byte format.
         * If the field value doesn't meet this constraint, an error message is generated.
         *
         * ```proto
         * message MyBytes {
         *   // value must be a valid IPv4 address
         *   optional bytes value = 1 [(buf.validate.field).bytes.ipv4 = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ipv4 = 11;
         */
        ipv4: boolean;
    } | {
        oneofKind: "ipv6";
        /**
         * `ipv6` ensures that the field `value` is a valid IPv6 address in byte format.
         * If the field value doesn't meet this constraint, an error message is generated.
         * ```proto
         * message MyBytes {
         *   // value must be a valid IPv6 address
         *   optional bytes value = 1 [(buf.validate.field).bytes.ipv6 = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool ipv6 = 12;
         */
        ipv6: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyBytes {
     *   bytes value = 1 [
     *     (buf.validate.field).bytes.example = "\x01\x02",
     *     (buf.validate.field).bytes.example = "\x02\x03"
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated bytes example = 14;
     */
    example: Uint8Array[];
}
/**
 * EnumRules describe the constraints applied to `enum` values.
 *
 * @generated from protobuf message buf.validate.EnumRules
 */
export interface EnumRules {
    /**
     * `const` requires the field value to exactly match the specified enum value.
     * If the field value doesn't match, an error message is generated.
     *
     * ```proto
     * enum MyEnum {
     *   MY_ENUM_UNSPECIFIED = 0;
     *   MY_ENUM_VALUE1 = 1;
     *   MY_ENUM_VALUE2 = 2;
     * }
     *
     * message MyMessage {
     *   // The field `value` must be exactly MY_ENUM_VALUE1.
     *   MyEnum value = 1 [(buf.validate.field).enum.const = 1];
     * }
     * ```
     *
     * @generated from protobuf field: optional int32 const = 1;
     */
    const?: number;
    /**
     * `defined_only` requires the field value to be one of the defined values for
     * this enum, failing on any undefined value.
     *
     * ```proto
     * enum MyEnum {
     *   MY_ENUM_UNSPECIFIED = 0;
     *   MY_ENUM_VALUE1 = 1;
     *   MY_ENUM_VALUE2 = 2;
     * }
     *
     * message MyMessage {
     *   // The field `value` must be a defined value of MyEnum.
     *   MyEnum value = 1 [(buf.validate.field).enum.defined_only = true];
     * }
     * ```
     *
     * @generated from protobuf field: optional bool defined_only = 2;
     */
    definedOnly?: boolean;
    /**
     * `in` requires the field value to be equal to one of the
     * specified enum values. If the field value doesn't match any of the
     * specified values, an error message is generated.
     *
     * ```proto
     * enum MyEnum {
     *   MY_ENUM_UNSPECIFIED = 0;
     *   MY_ENUM_VALUE1 = 1;
     *   MY_ENUM_VALUE2 = 2;
     * }
     *
     * message MyMessage {
     *   // The field `value` must be equal to one of the specified values.
     *   MyEnum value = 1 [(buf.validate.field).enum = { in: [1, 2]}];
     * }
     * ```
     *
     * @generated from protobuf field: repeated int32 in = 3;
     */
    in: number[];
    /**
     * `not_in` requires the field value to be not equal to any of the
     * specified enum values. If the field value matches one of the specified
     * values, an error message is generated.
     *
     * ```proto
     * enum MyEnum {
     *   MY_ENUM_UNSPECIFIED = 0;
     *   MY_ENUM_VALUE1 = 1;
     *   MY_ENUM_VALUE2 = 2;
     * }
     *
     * message MyMessage {
     *   // The field `value` must not be equal to any of the specified values.
     *   MyEnum value = 1 [(buf.validate.field).enum = { not_in: [1, 2]}];
     * }
     * ```
     *
     * @generated from protobuf field: repeated int32 not_in = 4;
     */
    notIn: number[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * enum MyEnum {
     *   MY_ENUM_UNSPECIFIED = 0;
     *   MY_ENUM_VALUE1 = 1;
     *   MY_ENUM_VALUE2 = 2;
     * }
     *
     * message MyMessage {
     *     (buf.validate.field).enum.example = 1,
     *     (buf.validate.field).enum.example = 2
     * }
     * ```
     *
     * @generated from protobuf field: repeated int32 example = 5;
     */
    example: number[];
}
/**
 * RepeatedRules describe the constraints applied to `repeated` values.
 *
 * @generated from protobuf message buf.validate.RepeatedRules
 */
export interface RepeatedRules {
    /**
     * `min_items` requires that this field must contain at least the specified
     * minimum number of items.
     *
     * Note that `min_items = 1` is equivalent to setting a field as `required`.
     *
     * ```proto
     * message MyRepeated {
     *   // value must contain at least  2 items
     *   repeated string value = 1 [(buf.validate.field).repeated.min_items = 2];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 min_items = 1;
     */
    minItems?: string;
    /**
     * `max_items` denotes that this field must not exceed a
     * certain number of items as the upper limit. If the field contains more
     * items than specified, an error message will be generated, requiring the
     * field to maintain no more than the specified number of items.
     *
     * ```proto
     * message MyRepeated {
     *   // value must contain no more than 3 item(s)
     *   repeated string value = 1 [(buf.validate.field).repeated.max_items = 3];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 max_items = 2;
     */
    maxItems?: string;
    /**
     * `unique` indicates that all elements in this field must
     * be unique. This constraint is strictly applicable to scalar and enum
     * types, with message types not being supported.
     *
     * ```proto
     * message MyRepeated {
     *   // repeated value must contain unique items
     *   repeated string value = 1 [(buf.validate.field).repeated.unique = true];
     * }
     * ```
     *
     * @generated from protobuf field: optional bool unique = 3;
     */
    unique?: boolean;
    /**
     * `items` details the constraints to be applied to each item
     * in the field. Even for repeated message fields, validation is executed
     * against each item unless skip is explicitly specified.
     *
     * ```proto
     * message MyRepeated {
     *   // The items in the field `value` must follow the specified constraints.
     *   repeated string value = 1 [(buf.validate.field).repeated.items = {
     *     string: {
     *       min_len: 3
     *       max_len: 10
     *     }
     *   }];
     * }
     * ```
     *
     * @generated from protobuf field: optional buf.validate.FieldConstraints items = 4;
     */
    items?: FieldConstraints;
}
/**
 * MapRules describe the constraints applied to `map` values.
 *
 * @generated from protobuf message buf.validate.MapRules
 */
export interface MapRules {
    /**
     * Specifies the minimum number of key-value pairs allowed. If the field has
     * fewer key-value pairs than specified, an error message is generated.
     *
     * ```proto
     * message MyMap {
     *   // The field `value` must have at least 2 key-value pairs.
     *   map<string, string> value = 1 [(buf.validate.field).map.min_pairs = 2];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 min_pairs = 1;
     */
    minPairs?: string;
    /**
     * Specifies the maximum number of key-value pairs allowed. If the field has
     * more key-value pairs than specified, an error message is generated.
     *
     * ```proto
     * message MyMap {
     *   // The field `value` must have at most 3 key-value pairs.
     *   map<string, string> value = 1 [(buf.validate.field).map.max_pairs = 3];
     * }
     * ```
     *
     * @generated from protobuf field: optional uint64 max_pairs = 2;
     */
    maxPairs?: string;
    /**
     * Specifies the constraints to be applied to each key in the field.
     *
     * ```proto
     * message MyMap {
     *   // The keys in the field `value` must follow the specified constraints.
     *   map<string, string> value = 1 [(buf.validate.field).map.keys = {
     *     string: {
     *       min_len: 3
     *       max_len: 10
     *     }
     *   }];
     * }
     * ```
     *
     * @generated from protobuf field: optional buf.validate.FieldConstraints keys = 4;
     */
    keys?: FieldConstraints;
    /**
     * Specifies the constraints to be applied to the value of each key in the
     * field. Message values will still have their validations evaluated unless
     * skip is specified here.
     *
     * ```proto
     * message MyMap {
     *   // The values in the field `value` must follow the specified constraints.
     *   map<string, string> value = 1 [(buf.validate.field).map.values = {
     *     string: {
     *       min_len: 5
     *       max_len: 20
     *     }
     *   }];
     * }
     * ```
     *
     * @generated from protobuf field: optional buf.validate.FieldConstraints values = 5;
     */
    values?: FieldConstraints;
}
/**
 * AnyRules describe constraints applied exclusively to the `google.protobuf.Any` well-known type.
 *
 * @generated from protobuf message buf.validate.AnyRules
 */
export interface AnyRules {
    /**
     * `in` requires the field's `type_url` to be equal to one of the
     * specified values. If it doesn't match any of the specified values, an error
     * message is generated.
     *
     * ```proto
     * message MyAny {
     *   //  The `value` field must have a `type_url` equal to one of the specified values.
     *   google.protobuf.Any value = 1 [(buf.validate.field).any.in = ["type.googleapis.com/MyType1", "type.googleapis.com/MyType2"]];
     * }
     * ```
     *
     * @generated from protobuf field: repeated string in = 2;
     */
    in: string[];
    /**
     * requires the field's type_url to be not equal to any of the specified values. If it matches any of the specified values, an error message is generated.
     *
     * ```proto
     * message MyAny {
     *   // The field `value` must not have a `type_url` equal to any of the specified values.
     *   google.protobuf.Any value = 1 [(buf.validate.field).any.not_in = ["type.googleapis.com/ForbiddenType1", "type.googleapis.com/ForbiddenType2"]];
     * }
     * ```
     *
     * @generated from protobuf field: repeated string not_in = 3;
     */
    notIn: string[];
}
/**
 * DurationRules describe the constraints applied exclusively to the `google.protobuf.Duration` well-known type.
 *
 * @generated from protobuf message buf.validate.DurationRules
 */
export interface DurationRules {
    /**
     * `const` dictates that the field must match the specified value of the `google.protobuf.Duration` type exactly.
     * If the field's value deviates from the specified value, an error message
     * will be generated.
     *
     * ```proto
     * message MyDuration {
     *   // value must equal 5s
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.const = "5s"];
     * }
     * ```
     *
     * @generated from protobuf field: optional google.protobuf.Duration const = 2;
     */
    const?: Duration;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * `lt` stipulates that the field must be less than the specified value of the `google.protobuf.Duration` type,
         * exclusive. If the field's value is greater than or equal to the specified
         * value, an error message will be generated.
         *
         * ```proto
         * message MyDuration {
         *   // value must be less than 5s
         *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = "5s"];
         * }
         * ```
         *
         * @generated from protobuf field: google.protobuf.Duration lt = 3;
         */
        lt: Duration;
    } | {
        oneofKind: "lte";
        /**
         * `lte` indicates that the field must be less than or equal to the specified
         * value of the `google.protobuf.Duration` type, inclusive. If the field's value is greater than the specified value,
         * an error message will be generated.
         *
         * ```proto
         * message MyDuration {
         *   // value must be less than or equal to 10s
         *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lte = "10s"];
         * }
         * ```
         *
         * @generated from protobuf field: google.protobuf.Duration lte = 4;
         */
        lte: Duration;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the duration field value to be greater than the specified
         * value (exclusive). If the value of `gt` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyDuration {
         *   // duration must be greater than 5s [duration.gt]
         *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.gt = { seconds: 5 }];
         *
         *   // duration must be greater than 5s and less than 10s [duration.gt_lt]
         *   google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gt: { seconds: 5 }, lt: { seconds: 10 } }];
         *
         *   // duration must be greater than 10s or less than 5s [duration.gt_lt_exclusive]
         *   google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gt: { seconds: 10 }, lt: { seconds: 5 } }];
         * }
         * ```
         *
         * @generated from protobuf field: google.protobuf.Duration gt = 5;
         */
        gt: Duration;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the duration field value to be greater than or equal to the
         * specified value (exclusive). If the value of `gte` is larger than a
         * specified `lt` or `lte`, the range is reversed, and the field value must
         * be outside the specified range. If the field value doesn't meet the
         * required conditions, an error message is generated.
         *
         * ```proto
         * message MyDuration {
         *  // duration must be greater than or equal to 5s [duration.gte]
         *  google.protobuf.Duration value = 1 [(buf.validate.field).duration.gte = { seconds: 5 }];
         *
         *  // duration must be greater than or equal to 5s and less than 10s [duration.gte_lt]
         *  google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gte: { seconds: 5 }, lt: { seconds: 10 } }];
         *
         *  // duration must be greater than or equal to 10s or less than 5s [duration.gte_lt_exclusive]
         *  google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gte: { seconds: 10 }, lt: { seconds: 5 } }];
         * }
         * ```
         *
         * @generated from protobuf field: google.protobuf.Duration gte = 6;
         */
        gte: Duration;
    } | {
        oneofKind: undefined;
    };
    /**
     * `in` asserts that the field must be equal to one of the specified values of the `google.protobuf.Duration` type.
     * If the field's value doesn't correspond to any of the specified values,
     * an error message will be generated.
     *
     * ```proto
     * message MyDuration {
     *   // value must be in list [1s, 2s, 3s]
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.in = ["1s", "2s", "3s"]];
     * }
     * ```
     *
     * @generated from protobuf field: repeated google.protobuf.Duration in = 7;
     */
    in: Duration[];
    /**
     * `not_in` denotes that the field must not be equal to
     * any of the specified values of the `google.protobuf.Duration` type.
     * If the field's value matches any of these values, an error message will be
     * generated.
     *
     * ```proto
     * message MyDuration {
     *   // value must not be in list [1s, 2s, 3s]
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.not_in = ["1s", "2s", "3s"]];
     * }
     * ```
     *
     * @generated from protobuf field: repeated google.protobuf.Duration not_in = 8;
     */
    notIn: Duration[];
    /**
     * `example` specifies values that the field may have. These values SHOULD
     * conform to other constraints. `example` values will not impact validation
     * but may be used as helpful guidance on how to populate the given field.
     *
     * ```proto
     * message MyDuration {
     *   google.protobuf.Duration value = 1 [
     *     (buf.validate.field).duration.example = { seconds: 1 },
     *     (buf.validate.field).duration.example = { seconds: 2 },
     *   ];
     * }
     * ```
     *
     * @generated from protobuf field: repeated google.protobuf.Duration example = 9;
     */
    example: Duration[];
}
/**
 * TimestampRules describe the constraints applied exclusively to the `google.protobuf.Timestamp` well-known type.
 *
 * @generated from protobuf message buf.validate.TimestampRules
 */
export interface TimestampRules {
    /**
     * `const` dictates that this field, of the `google.protobuf.Timestamp` type, must exactly match the specified value. If the field value doesn't correspond to the specified timestamp, an error message will be generated.
     *
     * ```proto
     * message MyTimestamp {
     *   // value must equal 2023-05-03T10:00:00Z
     *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.const = {seconds: 1727998800}];
     * }
     * ```
     *
     * @generated from protobuf field: optional google.protobuf.Timestamp const = 2;
     */
    const?: Timestamp;
    /**
     * @generated from protobuf oneof: less_than
     */
    lessThan: {
        oneofKind: "lt";
        /**
         * requires the duration field value to be less than the specified value (field < value). If the field value doesn't meet the required conditions, an error message is generated.
         *
         * ```proto
         * message MyDuration {
         *   // duration must be less than 'P3D' [duration.lt]
         *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = { seconds: 259200 }];
         * }
         * ```
         *
         * @generated from protobuf field: google.protobuf.Timestamp lt = 3;
         */
        lt: Timestamp;
    } | {
        oneofKind: "lte";
        /**
         * requires the timestamp field value to be less than or equal to the specified value (field <= value). If the field value doesn't meet the required conditions, an error message is generated.
         *
         * ```proto
         * message MyTimestamp {
         *   // timestamp must be less than or equal to '2023-05-14T00:00:00Z' [timestamp.lte]
         *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.lte = { seconds: 1678867200 }];
         * }
         * ```
         *
         * @generated from protobuf field: google.protobuf.Timestamp lte = 4;
         */
        lte: Timestamp;
    } | {
        oneofKind: "ltNow";
        /**
         * `lt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be less than the current time. `lt_now` can only be used with the `within` rule.
         *
         * ```proto
         * message MyTimestamp {
         *  // value must be less than now
         *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.lt_now = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool lt_now = 7;
         */
        ltNow: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: greater_than
     */
    greaterThan: {
        oneofKind: "gt";
        /**
         * `gt` requires the timestamp field value to be greater than the specified
         * value (exclusive). If the value of `gt` is larger than a specified `lt`
         * or `lte`, the range is reversed, and the field value must be outside the
         * specified range. If the field value doesn't meet the required conditions,
         * an error message is generated.
         *
         * ```proto
         * message MyTimestamp {
         *   // timestamp must be greater than '2023-01-01T00:00:00Z' [timestamp.gt]
         *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gt = { seconds: 1672444800 }];
         *
         *   // timestamp must be greater than '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gt_lt]
         *   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gt: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
         *
         *   // timestamp must be greater than '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gt_lt_exclusive]
         *   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gt: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
         * }
         * ```
         *
         * @generated from protobuf field: google.protobuf.Timestamp gt = 5;
         */
        gt: Timestamp;
    } | {
        oneofKind: "gte";
        /**
         * `gte` requires the timestamp field value to be greater than or equal to the
         * specified value (exclusive). If the value of `gte` is larger than a
         * specified `lt` or `lte`, the range is reversed, and the field value
         * must be outside the specified range. If the field value doesn't meet
         * the required conditions, an error message is generated.
         *
         * ```proto
         * message MyTimestamp {
         *   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' [timestamp.gte]
         *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gte = { seconds: 1672444800 }];
         *
         *   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gte_lt]
         *   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gte: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
         *
         *   // timestamp must be greater than or equal to '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gte_lt_exclusive]
         *   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gte: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
         * }
         * ```
         *
         * @generated from protobuf field: google.protobuf.Timestamp gte = 6;
         */
        gte: Timestamp;
    } | {
        oneofKind: "gtNow";
        /**
         * `gt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be greater than the current time. `gt_now` can only be used with the `within` rule.
         *
         * ```proto
         * message MyTimestamp {
         *   // value must be greater than now
         *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.gt_now = true];
         * }
         * ```
         *
         * @generated from protobuf field: bool gt_now = 8;
         */
        gtNow: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     * `within` specifies that this field, of the `google.protobuf.Timestamp` type, must be within the specified duration of the current time. If the field value isn't within the duration, an error message is generated.
     *
     * ```proto
     * message MyTimestamp {
     *   // value must be within 1 hour of now
     *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.within = {seconds: 3600}];
     * }
     * ```
     *
     * @generated from protobuf field: optional google.protobuf.Duration within = 9;
     */
    within?: Duration;
    // `example` specifies values that the field may have. These values SHOULD
    // conform to other constraints. `example` values will not impact validation
    // but may be used as helpful guidance on how to populate the given field.
    // 
    // ```proto
    // message MyTimestamp {
    //   google.protobuf.Timestamp value = 1 [
    //     (buf.validate.field).timestamp.example = { seconds: 1672444800 },
    //     (buf.validate.field).timestamp.example = { seconds: 1672531200 },
    //   ];
    // }
    // ```

    /**
     * @generated from protobuf field: repeated google.protobuf.Timestamp example = 10;
     */
    example: Timestamp[];
}
/**
 * `Violations` is a collection of `Violation` messages. This message type is returned by
 * protovalidate when a proto message fails to meet the requirements set by the `Constraint` validation rules.
 * Each individual violation is represented by a `Violation` message.
 *
 * @generated from protobuf message buf.validate.Violations
 */
export interface Violations {
    /**
     * `violations` is a repeated field that contains all the `Violation` messages corresponding to the violations detected.
     *
     * @generated from protobuf field: repeated buf.validate.Violation violations = 1;
     */
    violations: Violation[];
}
/**
 * `Violation` represents a single instance where a validation rule, expressed
 * as a `Constraint`, was not met. It provides information about the field that
 * caused the violation, the specific constraint that wasn't fulfilled, and a
 * human-readable error message.
 *
 * ```json
 * {
 *   "fieldPath": "bar",
 *   "constraintId": "foo.bar",
 *   "message": "bar must be greater than 0"
 * }
 * ```
 *
 * @generated from protobuf message buf.validate.Violation
 */
export interface Violation {
    /**
     * `field` is a machine-readable path to the field that failed validation.
     * This could be a nested field, in which case the path will include all the parent fields leading to the actual field that caused the violation.
     *
     * For example, consider the following message:
     *
     * ```proto
     * message Message {
     *   bool a = 1 [(buf.validate.field).required = true];
     * }
     * ```
     *
     * It could produce the following violation:
     *
     * ```textproto
     * violation {
     *   field { element { field_number: 1, field_name: "a", field_type: 8 } }
     *   ...
     * }
     * ```
     *
     * @generated from protobuf field: optional buf.validate.FieldPath field = 5;
     */
    field?: FieldPath;
    /**
     * `rule` is a machine-readable path that points to the specific constraint rule that failed validation.
     * This will be a nested field starting from the FieldConstraints of the field that failed validation.
     * For custom constraints, this will provide the path of the constraint, e.g. `cel[0]`.
     *
     * For example, consider the following message:
     *
     * ```proto
     * message Message {
     *   bool a = 1 [(buf.validate.field).required = true];
     *   bool b = 2 [(buf.validate.field).cel = {
     *     id: "custom_constraint",
     *     expression: "!this ? 'b must be true': ''"
     *   }]
     * }
     * ```
     *
     * It could produce the following violations:
     *
     * ```textproto
     * violation {
     *   rule { element { field_number: 25, field_name: "required", field_type: 8 } }
     *   ...
     * }
     * violation {
     *   rule { element { field_number: 23, field_name: "cel", field_type: 11, index: 0 } }
     *   ...
     * }
     * ```
     *
     * @generated from protobuf field: optional buf.validate.FieldPath rule = 6;
     */
    rule?: FieldPath;
    /**
     * `constraint_id` is the unique identifier of the `Constraint` that was not fulfilled.
     * This is the same `id` that was specified in the `Constraint` message, allowing easy tracing of which rule was violated.
     *
     * @generated from protobuf field: optional string constraint_id = 2;
     */
    constraintId?: string;
    /**
     * `message` is a human-readable error message that describes the nature of the violation.
     * This can be the default error message from the violated `Constraint`, or it can be a custom message that gives more context about the violation.
     *
     * @generated from protobuf field: optional string message = 3;
     */
    message?: string;
    /**
     * `for_key` indicates whether the violation was caused by a map key, rather than a value.
     *
     * @generated from protobuf field: optional bool for_key = 4;
     */
    forKey?: boolean;
}
/**
 * `FieldPath` provides a path to a nested protobuf field.
 *
 * This message provides enough information to render a dotted field path even without protobuf descriptors.
 * It also provides enough information to resolve a nested field through unknown wire data.
 *
 * @generated from protobuf message buf.validate.FieldPath
 */
export interface FieldPath {
    /**
     * `elements` contains each element of the path, starting from the root and recursing downward.
     *
     * @generated from protobuf field: repeated buf.validate.FieldPathElement elements = 1;
     */
    elements: FieldPathElement[];
}
/**
 * `FieldPathElement` provides enough information to nest through a single protobuf field.
 *
 * If the selected field is a map or repeated field, the `subscript` value selects a specific element from it.
 * A path that refers to a value nested under a map key or repeated field index will have a `subscript` value.
 * The `field_type` field allows unambiguous resolution of a field even if descriptors are not available.
 *
 * @generated from protobuf message buf.validate.FieldPathElement
 */
export interface FieldPathElement {
    /**
     * `field_number` is the field number this path element refers to.
     *
     * @generated from protobuf field: optional int32 field_number = 1;
     */
    fieldNumber?: number;
    /**
     * `field_name` contains the field name this path element refers to.
     * This can be used to display a human-readable path even if the field number is unknown.
     *
     * @generated from protobuf field: optional string field_name = 2;
     */
    fieldName?: string;
    /**
     * `field_type` specifies the type of this field. When using reflection, this value is not needed.
     *
     * This value is provided to make it possible to traverse unknown fields through wire data.
     * When traversing wire data, be mindful of both packed[1] and delimited[2] encoding schemes.
     *
     * [1]: https://protobuf.dev/programming-guides/encoding/#packed
     * [2]: https://protobuf.dev/programming-guides/encoding/#groups
     *
     * N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
     * can be explicitly used in Protocol Buffers 2023 Edition.
     *
     * @generated from protobuf field: optional google.protobuf.FieldDescriptorProto.Type field_type = 3;
     */
    fieldType?: FieldDescriptorProto_Type;
    /**
     * `key_type` specifies the map key type of this field. This value is useful when traversing
     * unknown fields through wire data: specifically, it allows handling the differences between
     * different integer encodings.
     *
     * @generated from protobuf field: optional google.protobuf.FieldDescriptorProto.Type key_type = 4;
     */
    keyType?: FieldDescriptorProto_Type;
    /**
     * `value_type` specifies map value type of this field. This is useful if you want to display a
     * value inside unknown fields through wire data.
     *
     * @generated from protobuf field: optional google.protobuf.FieldDescriptorProto.Type value_type = 5;
     */
    valueType?: FieldDescriptorProto_Type;
    /**
     * @generated from protobuf oneof: subscript
     */
    subscript: {
        oneofKind: "index";
        /**
         * `index` specifies a 0-based index into a repeated field.
         *
         * @generated from protobuf field: uint64 index = 6;
         */
        index: string;
    } | {
        oneofKind: "boolKey";
        /**
         * `bool_key` specifies a map key of type bool.
         *
         * @generated from protobuf field: bool bool_key = 7;
         */
        boolKey: boolean;
    } | {
        oneofKind: "intKey";
        /**
         * `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64.
         *
         * @generated from protobuf field: int64 int_key = 8;
         */
        intKey: string;
    } | {
        oneofKind: "uintKey";
        /**
         * `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64.
         *
         * @generated from protobuf field: uint64 uint_key = 9;
         */
        uintKey: string;
    } | {
        oneofKind: "stringKey";
        /**
         * `string_key` specifies a map key of type string.
         *
         * @generated from protobuf field: string string_key = 10;
         */
        stringKey: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies how FieldConstraints.ignore behaves. See the documentation for
 * FieldConstraints.required for definitions of "populated" and "nullable".
 *
 * @generated from protobuf enum buf.validate.Ignore
 */
export enum Ignore {
    /**
     * Validation is only skipped if it's an unpopulated nullable fields.
     *
     * ```proto
     * syntax="proto3";
     *
     * message Request {
     *   // The uri rule applies to any value, including the empty string.
     *   string foo = 1 [
     *     (buf.validate.field).string.uri = true
     *   ];
     *
     *   // The uri rule only applies if the field is set, including if it's
     *   // set to the empty string.
     *   optional string bar = 2 [
     *     (buf.validate.field).string.uri = true
     *   ];
     *
     *   // The min_items rule always applies, even if the list is empty.
     *   repeated string baz = 3 [
     *     (buf.validate.field).repeated.min_items = 3
     *   ];
     *
     *   // The custom CEL rule applies only if the field is set, including if
     *   // it's the "zero" value of that message.
     *   SomeMessage quux = 4 [
     *     (buf.validate.field).cel = {/* ... *\/}
     *   ];
     * }
     * ```
     *
     * @generated from protobuf enum value: IGNORE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Validation is skipped if the field is unpopulated. This rule is redundant
     * if the field is already nullable.
     *
     * ```proto
     * syntax="proto3
     *
     * message Request {
     *   // The uri rule applies only if the value is not the empty string.
     *   string foo = 1 [
     *     (buf.validate.field).string.uri = true,
     *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
     *   ];
     *
     *   // IGNORE_IF_UNPOPULATED is equivalent to IGNORE_UNSPECIFIED in this
     *   // case: the uri rule only applies if the field is set, including if
     *   // it's set to the empty string.
     *   optional string bar = 2 [
     *     (buf.validate.field).string.uri = true,
     *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
     *   ];
     *
     *   // The min_items rule only applies if the list has at least one item.
     *   repeated string baz = 3 [
     *     (buf.validate.field).repeated.min_items = 3,
     *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
     *   ];
     *
     *   // IGNORE_IF_UNPOPULATED is equivalent to IGNORE_UNSPECIFIED in this
     *   // case: the custom CEL rule applies only if the field is set, including
     *   // if it's the "zero" value of that message.
     *   SomeMessage quux = 4 [
     *     (buf.validate.field).cel = {/* ... *\/},
     *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
     *   ];
     * }
     * ```
     *
     * @generated from protobuf enum value: IGNORE_IF_UNPOPULATED = 1;
     */
    IF_UNPOPULATED = 1,
    /**
     * Validation is skipped if the field is unpopulated or if it is a nullable
     * field populated with its default value. This is typically the zero or
     * empty value, but proto2 scalars support custom defaults. For messages, the
     * default is a non-null message with all its fields unpopulated.
     *
     * ```proto
     * syntax="proto3
     *
     * message Request {
     *   // IGNORE_IF_DEFAULT_VALUE is equivalent to IGNORE_IF_UNPOPULATED in
     *   // this case; the uri rule applies only if the value is not the empty
     *   // string.
     *   string foo = 1 [
     *     (buf.validate.field).string.uri = true,
     *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
     *   ];
     *
     *   // The uri rule only applies if the field is set to a value other than
     *   // the empty string.
     *   optional string bar = 2 [
     *     (buf.validate.field).string.uri = true,
     *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
     *   ];
     *
     *   // IGNORE_IF_DEFAULT_VALUE is equivalent to IGNORE_IF_UNPOPULATED in
     *   // this case; the min_items rule only applies if the list has at least
     *   // one item.
     *   repeated string baz = 3 [
     *     (buf.validate.field).repeated.min_items = 3,
     *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
     *   ];
     *
     *   // The custom CEL rule only applies if the field is set to a value other
     *   // than an empty message (i.e., fields are unpopulated).
     *   SomeMessage quux = 4 [
     *     (buf.validate.field).cel = {/* ... *\/},
     *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
     *   ];
     * }
     * ```
     *
     * This rule is affected by proto2 custom default values:
     *
     * ```proto
     * syntax="proto2";
     *
     * message Request {
     *   // The gt rule only applies if the field is set and it's value is not
     *   the default (i.e., not -42). The rule even applies if the field is set
     *   to zero since the default value differs.
     *   optional int32 value = 1 [
     *     default = -42,
     *     (buf.validate.field).int32.gt = 0,
     *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE
     *   ];
     * }
     *
     * @generated from protobuf enum value: IGNORE_IF_DEFAULT_VALUE = 2;
     */
    IF_DEFAULT_VALUE = 2,
    /**
     * The validation rules of this field will be skipped and not evaluated. This
     * is useful for situations that necessitate turning off the rules of a field
     * containing a message that may not make sense in the current context, or to
     * temporarily disable constraints during development.
     *
     * ```proto
     * message MyMessage {
     *   // The field's rules will always be ignored, including any validation's
     *   // on value's fields.
     *   MyOtherMessage value = 1 [
     *     (buf.validate.field).ignore = IGNORE_ALWAYS];
     * }
     * ```
     *
     * @generated from protobuf enum value: IGNORE_ALWAYS = 3;
     */
    ALWAYS = 3
}
/**
 * WellKnownRegex contain some well-known patterns.
 *
 * @generated from protobuf enum buf.validate.KnownRegex
 */
export enum KnownRegex {
    /**
     * @generated from protobuf enum value: KNOWN_REGEX_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2).
     *
     * @generated from protobuf enum value: KNOWN_REGEX_HTTP_HEADER_NAME = 1;
     */
    HTTP_HEADER_NAME = 1,
    /**
     * HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4).
     *
     * @generated from protobuf enum value: KNOWN_REGEX_HTTP_HEADER_VALUE = 2;
     */
    HTTP_HEADER_VALUE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Constraint$Type extends MessageType<Constraint> {
    constructor() {
        super("buf.validate.Constraint", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expression", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Constraint>): Constraint {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Constraint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Constraint): Constraint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string message */ 2:
                    message.message = reader.string();
                    break;
                case /* optional string expression */ 3:
                    message.expression = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Constraint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string message = 2; */
        if (message.message !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* optional string expression = 3; */
        if (message.expression !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.expression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Constraint
 */
export const Constraint = new Constraint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageConstraints$Type extends MessageType<MessageConstraints> {
    constructor() {
        super("buf.validate.MessageConstraints", [
            { no: 1, name: "disabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "cel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Constraint }
        ]);
    }
    create(value?: PartialMessage<MessageConstraints>): MessageConstraints {
        const message = { cel: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageConstraints): MessageConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool disabled */ 1:
                    message.disabled = reader.bool();
                    break;
                case /* repeated buf.validate.Constraint cel */ 3:
                    message.cel.push(Constraint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool disabled = 1; */
        if (message.disabled !== undefined)
            writer.tag(1, WireType.Varint).bool(message.disabled);
        /* repeated buf.validate.Constraint cel = 3; */
        for (let i = 0; i < message.cel.length; i++)
            Constraint.internalBinaryWrite(message.cel[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.MessageConstraints
 */
export const MessageConstraints = new MessageConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneofConstraints$Type extends MessageType<OneofConstraints> {
    constructor() {
        super("buf.validate.OneofConstraints", [
            { no: 1, name: "required", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<OneofConstraints>): OneofConstraints {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OneofConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneofConstraints): OneofConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool required */ 1:
                    message.required = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneofConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool required = 1; */
        if (message.required !== undefined)
            writer.tag(1, WireType.Varint).bool(message.required);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.OneofConstraints
 */
export const OneofConstraints = new OneofConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldConstraints$Type extends MessageType<FieldConstraints> {
    constructor() {
        super("buf.validate.FieldConstraints", [
            { no: 23, name: "cel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Constraint },
            { no: 25, name: "required", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "ignore", kind: "enum", opt: true, T: () => ["buf.validate.Ignore", Ignore, "IGNORE_"] },
            { no: 1, name: "float", kind: "message", oneof: "type", T: () => FloatRules },
            { no: 2, name: "double", kind: "message", oneof: "type", T: () => DoubleRules },
            { no: 3, name: "int32", kind: "message", oneof: "type", T: () => Int32Rules },
            { no: 4, name: "int64", kind: "message", oneof: "type", T: () => Int64Rules },
            { no: 5, name: "uint32", kind: "message", oneof: "type", T: () => UInt32Rules },
            { no: 6, name: "uint64", kind: "message", oneof: "type", T: () => UInt64Rules },
            { no: 7, name: "sint32", kind: "message", oneof: "type", T: () => SInt32Rules },
            { no: 8, name: "sint64", kind: "message", oneof: "type", T: () => SInt64Rules },
            { no: 9, name: "fixed32", kind: "message", oneof: "type", T: () => Fixed32Rules },
            { no: 10, name: "fixed64", kind: "message", oneof: "type", T: () => Fixed64Rules },
            { no: 11, name: "sfixed32", kind: "message", oneof: "type", T: () => SFixed32Rules },
            { no: 12, name: "sfixed64", kind: "message", oneof: "type", T: () => SFixed64Rules },
            { no: 13, name: "bool", kind: "message", oneof: "type", T: () => BoolRules },
            { no: 14, name: "string", kind: "message", oneof: "type", T: () => StringRules },
            { no: 15, name: "bytes", kind: "message", oneof: "type", T: () => BytesRules },
            { no: 16, name: "enum", kind: "message", oneof: "type", T: () => EnumRules },
            { no: 18, name: "repeated", kind: "message", oneof: "type", T: () => RepeatedRules },
            { no: 19, name: "map", kind: "message", oneof: "type", T: () => MapRules },
            { no: 20, name: "any", kind: "message", oneof: "type", T: () => AnyRules },
            { no: 21, name: "duration", kind: "message", oneof: "type", T: () => DurationRules },
            { no: 22, name: "timestamp", kind: "message", oneof: "type", T: () => TimestampRules }
        ]);
    }
    create(value?: PartialMessage<FieldConstraints>): FieldConstraints {
        const message = { cel: [], type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FieldConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FieldConstraints): FieldConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated buf.validate.Constraint cel */ 23:
                    message.cel.push(Constraint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool required */ 25:
                    message.required = reader.bool();
                    break;
                case /* optional buf.validate.Ignore ignore */ 27:
                    message.ignore = reader.int32();
                    break;
                case /* buf.validate.FloatRules float */ 1:
                    message.type = {
                        oneofKind: "float",
                        float: FloatRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).float)
                    };
                    break;
                case /* buf.validate.DoubleRules double */ 2:
                    message.type = {
                        oneofKind: "double",
                        double: DoubleRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).double)
                    };
                    break;
                case /* buf.validate.Int32Rules int32 */ 3:
                    message.type = {
                        oneofKind: "int32",
                        int32: Int32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).int32)
                    };
                    break;
                case /* buf.validate.Int64Rules int64 */ 4:
                    message.type = {
                        oneofKind: "int64",
                        int64: Int64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).int64)
                    };
                    break;
                case /* buf.validate.UInt32Rules uint32 */ 5:
                    message.type = {
                        oneofKind: "uint32",
                        uint32: UInt32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).uint32)
                    };
                    break;
                case /* buf.validate.UInt64Rules uint64 */ 6:
                    message.type = {
                        oneofKind: "uint64",
                        uint64: UInt64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).uint64)
                    };
                    break;
                case /* buf.validate.SInt32Rules sint32 */ 7:
                    message.type = {
                        oneofKind: "sint32",
                        sint32: SInt32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).sint32)
                    };
                    break;
                case /* buf.validate.SInt64Rules sint64 */ 8:
                    message.type = {
                        oneofKind: "sint64",
                        sint64: SInt64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).sint64)
                    };
                    break;
                case /* buf.validate.Fixed32Rules fixed32 */ 9:
                    message.type = {
                        oneofKind: "fixed32",
                        fixed32: Fixed32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).fixed32)
                    };
                    break;
                case /* buf.validate.Fixed64Rules fixed64 */ 10:
                    message.type = {
                        oneofKind: "fixed64",
                        fixed64: Fixed64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).fixed64)
                    };
                    break;
                case /* buf.validate.SFixed32Rules sfixed32 */ 11:
                    message.type = {
                        oneofKind: "sfixed32",
                        sfixed32: SFixed32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).sfixed32)
                    };
                    break;
                case /* buf.validate.SFixed64Rules sfixed64 */ 12:
                    message.type = {
                        oneofKind: "sfixed64",
                        sfixed64: SFixed64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).sfixed64)
                    };
                    break;
                case /* buf.validate.BoolRules bool */ 13:
                    message.type = {
                        oneofKind: "bool",
                        bool: BoolRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).bool)
                    };
                    break;
                case /* buf.validate.StringRules string */ 14:
                    message.type = {
                        oneofKind: "string",
                        string: StringRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).string)
                    };
                    break;
                case /* buf.validate.BytesRules bytes */ 15:
                    message.type = {
                        oneofKind: "bytes",
                        bytes: BytesRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).bytes)
                    };
                    break;
                case /* buf.validate.EnumRules enum */ 16:
                    message.type = {
                        oneofKind: "enum",
                        enum: EnumRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).enum)
                    };
                    break;
                case /* buf.validate.RepeatedRules repeated */ 18:
                    message.type = {
                        oneofKind: "repeated",
                        repeated: RepeatedRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).repeated)
                    };
                    break;
                case /* buf.validate.MapRules map */ 19:
                    message.type = {
                        oneofKind: "map",
                        map: MapRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).map)
                    };
                    break;
                case /* buf.validate.AnyRules any */ 20:
                    message.type = {
                        oneofKind: "any",
                        any: AnyRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).any)
                    };
                    break;
                case /* buf.validate.DurationRules duration */ 21:
                    message.type = {
                        oneofKind: "duration",
                        duration: DurationRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).duration)
                    };
                    break;
                case /* buf.validate.TimestampRules timestamp */ 22:
                    message.type = {
                        oneofKind: "timestamp",
                        timestamp: TimestampRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).timestamp)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FieldConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated buf.validate.Constraint cel = 23; */
        for (let i = 0; i < message.cel.length; i++)
            Constraint.internalBinaryWrite(message.cel[i], writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* optional bool required = 25; */
        if (message.required !== undefined)
            writer.tag(25, WireType.Varint).bool(message.required);
        /* optional buf.validate.Ignore ignore = 27; */
        if (message.ignore !== undefined)
            writer.tag(27, WireType.Varint).int32(message.ignore);
        /* buf.validate.FloatRules float = 1; */
        if (message.type.oneofKind === "float")
            FloatRules.internalBinaryWrite(message.type.float, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.DoubleRules double = 2; */
        if (message.type.oneofKind === "double")
            DoubleRules.internalBinaryWrite(message.type.double, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.Int32Rules int32 = 3; */
        if (message.type.oneofKind === "int32")
            Int32Rules.internalBinaryWrite(message.type.int32, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.Int64Rules int64 = 4; */
        if (message.type.oneofKind === "int64")
            Int64Rules.internalBinaryWrite(message.type.int64, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.UInt32Rules uint32 = 5; */
        if (message.type.oneofKind === "uint32")
            UInt32Rules.internalBinaryWrite(message.type.uint32, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.UInt64Rules uint64 = 6; */
        if (message.type.oneofKind === "uint64")
            UInt64Rules.internalBinaryWrite(message.type.uint64, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.SInt32Rules sint32 = 7; */
        if (message.type.oneofKind === "sint32")
            SInt32Rules.internalBinaryWrite(message.type.sint32, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.SInt64Rules sint64 = 8; */
        if (message.type.oneofKind === "sint64")
            SInt64Rules.internalBinaryWrite(message.type.sint64, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.Fixed32Rules fixed32 = 9; */
        if (message.type.oneofKind === "fixed32")
            Fixed32Rules.internalBinaryWrite(message.type.fixed32, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.Fixed64Rules fixed64 = 10; */
        if (message.type.oneofKind === "fixed64")
            Fixed64Rules.internalBinaryWrite(message.type.fixed64, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.SFixed32Rules sfixed32 = 11; */
        if (message.type.oneofKind === "sfixed32")
            SFixed32Rules.internalBinaryWrite(message.type.sfixed32, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.SFixed64Rules sfixed64 = 12; */
        if (message.type.oneofKind === "sfixed64")
            SFixed64Rules.internalBinaryWrite(message.type.sfixed64, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.BoolRules bool = 13; */
        if (message.type.oneofKind === "bool")
            BoolRules.internalBinaryWrite(message.type.bool, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.StringRules string = 14; */
        if (message.type.oneofKind === "string")
            StringRules.internalBinaryWrite(message.type.string, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.BytesRules bytes = 15; */
        if (message.type.oneofKind === "bytes")
            BytesRules.internalBinaryWrite(message.type.bytes, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.EnumRules enum = 16; */
        if (message.type.oneofKind === "enum")
            EnumRules.internalBinaryWrite(message.type.enum, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.RepeatedRules repeated = 18; */
        if (message.type.oneofKind === "repeated")
            RepeatedRules.internalBinaryWrite(message.type.repeated, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.MapRules map = 19; */
        if (message.type.oneofKind === "map")
            MapRules.internalBinaryWrite(message.type.map, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.AnyRules any = 20; */
        if (message.type.oneofKind === "any")
            AnyRules.internalBinaryWrite(message.type.any, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.DurationRules duration = 21; */
        if (message.type.oneofKind === "duration")
            DurationRules.internalBinaryWrite(message.type.duration, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.TimestampRules timestamp = 22; */
        if (message.type.oneofKind === "timestamp")
            TimestampRules.internalBinaryWrite(message.type.timestamp, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.FieldConstraints
 */
export const FieldConstraints = new FieldConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PredefinedConstraints$Type extends MessageType<PredefinedConstraints> {
    constructor() {
        super("buf.validate.PredefinedConstraints", [
            { no: 1, name: "cel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Constraint }
        ]);
    }
    create(value?: PartialMessage<PredefinedConstraints>): PredefinedConstraints {
        const message = { cel: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PredefinedConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PredefinedConstraints): PredefinedConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated buf.validate.Constraint cel */ 1:
                    message.cel.push(Constraint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PredefinedConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated buf.validate.Constraint cel = 1; */
        for (let i = 0; i < message.cel.length; i++)
            Constraint.internalBinaryWrite(message.cel[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.PredefinedConstraints
 */
export const PredefinedConstraints = new PredefinedConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FloatRules$Type extends MessageType<FloatRules> {
    constructor() {
        super("buf.validate.FloatRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.predefined": { cel: [{ id: "float.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.predefined": { cel: [{ id: "float.lt", expression: "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.predefined": { cel: [{ id: "float.lte", expression: "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.predefined": { cel: [{ id: "float.gt", expression: "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "float.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "float.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "float.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "float.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.predefined": { cel: [{ id: "float.gte", expression: "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "float.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "float.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "float.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "float.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.predefined": { cel: [{ id: "float.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.predefined": { cel: [{ id: "float.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "finite", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "float.finite", expression: "rules.finite ? (this.isNan() || this.isInf() ? 'value must be finite' : '') : ''" }] } } },
            { no: 9, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.predefined": { cel: [{ id: "float.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<FloatRules>): FloatRules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FloatRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FloatRules): FloatRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float const */ 1:
                    message.const = reader.float();
                    break;
                case /* float lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.float()
                    };
                    break;
                case /* float lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.float()
                    };
                    break;
                case /* float gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.float()
                    };
                    break;
                case /* float gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.float()
                    };
                    break;
                case /* repeated float in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.float());
                    else
                        message.in.push(reader.float());
                    break;
                case /* repeated float not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.float());
                    else
                        message.notIn.push(reader.float());
                    break;
                case /* optional bool finite */ 8:
                    message.finite = reader.bool();
                    break;
                case /* repeated float example */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.float());
                    else
                        message.example.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FloatRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Bit32).float(message.const);
        /* float lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Bit32).float(message.lessThan.lt);
        /* float lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Bit32).float(message.lessThan.lte);
        /* float gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Bit32).float(message.greaterThan.gt);
        /* float gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Bit32).float(message.greaterThan.gte);
        /* repeated float in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Bit32).float(message.in[i]);
        /* repeated float not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Bit32).float(message.notIn[i]);
        /* optional bool finite = 8; */
        if (message.finite !== undefined)
            writer.tag(8, WireType.Varint).bool(message.finite);
        /* repeated float example = 9; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(9, WireType.Bit32).float(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.FloatRules
 */
export const FloatRules = new FloatRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleRules$Type extends MessageType<DoubleRules> {
    constructor() {
        super("buf.validate.DoubleRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.predefined": { cel: [{ id: "double.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.predefined": { cel: [{ id: "double.lt", expression: "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.predefined": { cel: [{ id: "double.lte", expression: "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.predefined": { cel: [{ id: "double.gt", expression: "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "double.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "double.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "double.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "double.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.predefined": { cel: [{ id: "double.gte", expression: "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "double.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "double.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "double.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "double.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.predefined": { cel: [{ id: "double.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.predefined": { cel: [{ id: "double.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "finite", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "double.finite", expression: "rules.finite ? (this.isNan() || this.isInf() ? 'value must be finite' : '') : ''" }] } } },
            { no: 9, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.predefined": { cel: [{ id: "double.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<DoubleRules>): DoubleRules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DoubleRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoubleRules): DoubleRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double const */ 1:
                    message.const = reader.double();
                    break;
                case /* double lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.double()
                    };
                    break;
                case /* double lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.double()
                    };
                    break;
                case /* double gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.double()
                    };
                    break;
                case /* double gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.double()
                    };
                    break;
                case /* repeated double in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.double());
                    else
                        message.in.push(reader.double());
                    break;
                case /* repeated double not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.double());
                    else
                        message.notIn.push(reader.double());
                    break;
                case /* optional bool finite */ 8:
                    message.finite = reader.bool();
                    break;
                case /* repeated double example */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.double());
                    else
                        message.example.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoubleRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Bit64).double(message.const);
        /* double lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Bit64).double(message.lessThan.lt);
        /* double lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Bit64).double(message.lessThan.lte);
        /* double gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Bit64).double(message.greaterThan.gt);
        /* double gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Bit64).double(message.greaterThan.gte);
        /* repeated double in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Bit64).double(message.in[i]);
        /* repeated double not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Bit64).double(message.notIn[i]);
        /* optional bool finite = 8; */
        if (message.finite !== undefined)
            writer.tag(8, WireType.Varint).bool(message.finite);
        /* repeated double example = 9; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(9, WireType.Bit64).double(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.DoubleRules
 */
export const DoubleRules = new DoubleRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int32Rules$Type extends MessageType<Int32Rules> {
    constructor() {
        super("buf.validate.Int32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "int32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "int32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "int32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "int32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "int32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "int32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "int32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "int32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "int32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "int32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "int32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "int32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "int32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "int32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "int32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "int32.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<Int32Rules>): Int32Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Int32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Int32Rules): Int32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 const */ 1:
                    message.const = reader.int32();
                    break;
                case /* int32 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.int32()
                    };
                    break;
                case /* int32 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.int32()
                    };
                    break;
                case /* int32 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.int32()
                    };
                    break;
                case /* int32 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.int32()
                    };
                    break;
                case /* repeated int32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int32());
                    else
                        message.in.push(reader.int32());
                    break;
                case /* repeated int32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.int32());
                    else
                        message.notIn.push(reader.int32());
                    break;
                case /* repeated int32 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.int32());
                    else
                        message.example.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Int32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int32(message.const);
        /* int32 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Varint).int32(message.lessThan.lt);
        /* int32 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Varint).int32(message.lessThan.lte);
        /* int32 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Varint).int32(message.greaterThan.gt);
        /* int32 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Varint).int32(message.greaterThan.gte);
        /* repeated int32 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Varint).int32(message.in[i]);
        /* repeated int32 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Varint).int32(message.notIn[i]);
        /* repeated int32 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Varint).int32(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Int32Rules
 */
export const Int32Rules = new Int32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int64Rules$Type extends MessageType<Int64Rules> {
    constructor() {
        super("buf.validate.Int64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, options: { "buf.validate.predefined": { cel: [{ id: "int64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 3 /*ScalarType.INT64*/, options: { "buf.validate.predefined": { cel: [{ id: "int64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 3 /*ScalarType.INT64*/, options: { "buf.validate.predefined": { cel: [{ id: "int64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 3 /*ScalarType.INT64*/, options: { "buf.validate.predefined": { cel: [{ id: "int64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "int64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "int64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "int64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "int64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 3 /*ScalarType.INT64*/, options: { "buf.validate.predefined": { cel: [{ id: "int64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "int64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "int64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "int64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "int64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, options: { "buf.validate.predefined": { cel: [{ id: "int64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, options: { "buf.validate.predefined": { cel: [{ id: "int64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 9, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, options: { "buf.validate.predefined": { cel: [{ id: "int64.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<Int64Rules>): Int64Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Int64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Int64Rules): Int64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 const */ 1:
                    message.const = reader.int64().toString();
                    break;
                case /* int64 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.int64().toString()
                    };
                    break;
                case /* int64 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.int64().toString()
                    };
                    break;
                case /* int64 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.int64().toString()
                    };
                    break;
                case /* int64 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.int64().toString()
                    };
                    break;
                case /* repeated int64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int64().toString());
                    else
                        message.in.push(reader.int64().toString());
                    break;
                case /* repeated int64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.int64().toString());
                    else
                        message.notIn.push(reader.int64().toString());
                    break;
                case /* repeated int64 example */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.int64().toString());
                    else
                        message.example.push(reader.int64().toString());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Int64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int64(message.const);
        /* int64 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Varint).int64(message.lessThan.lt);
        /* int64 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Varint).int64(message.lessThan.lte);
        /* int64 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Varint).int64(message.greaterThan.gt);
        /* int64 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Varint).int64(message.greaterThan.gte);
        /* repeated int64 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Varint).int64(message.in[i]);
        /* repeated int64 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Varint).int64(message.notIn[i]);
        /* repeated int64 example = 9; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(9, WireType.Varint).int64(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Int64Rules
 */
export const Int64Rules = new Int64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UInt32Rules$Type extends MessageType<UInt32Rules> {
    constructor() {
        super("buf.validate.UInt32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "uint32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "uint32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "uint32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "uint32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "uint32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "uint32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "uint32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "uint32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "uint32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "uint32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "uint32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "uint32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "uint32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "uint32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "uint32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "uint32.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<UInt32Rules>): UInt32Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UInt32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UInt32Rules): UInt32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 const */ 1:
                    message.const = reader.uint32();
                    break;
                case /* uint32 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.uint32()
                    };
                    break;
                case /* uint32 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.uint32()
                    };
                    break;
                case /* uint32 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.uint32()
                    };
                    break;
                case /* uint32 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.uint32()
                    };
                    break;
                case /* repeated uint32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.uint32());
                    else
                        message.in.push(reader.uint32());
                    break;
                case /* repeated uint32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.uint32());
                    else
                        message.notIn.push(reader.uint32());
                    break;
                case /* repeated uint32 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.uint32());
                    else
                        message.example.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UInt32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.const);
        /* uint32 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Varint).uint32(message.lessThan.lt);
        /* uint32 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Varint).uint32(message.lessThan.lte);
        /* uint32 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Varint).uint32(message.greaterThan.gt);
        /* uint32 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Varint).uint32(message.greaterThan.gte);
        /* repeated uint32 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Varint).uint32(message.in[i]);
        /* repeated uint32 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Varint).uint32(message.notIn[i]);
        /* repeated uint32 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Varint).uint32(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.UInt32Rules
 */
export const UInt32Rules = new UInt32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UInt64Rules$Type extends MessageType<UInt64Rules> {
    constructor() {
        super("buf.validate.UInt64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "uint64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "uint64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "uint64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "uint64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "uint64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "uint64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "uint64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "uint64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "uint64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "uint64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "uint64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "uint64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "uint64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "uint64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "uint64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "uint64.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<UInt64Rules>): UInt64Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UInt64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UInt64Rules): UInt64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 const */ 1:
                    message.const = reader.uint64().toString();
                    break;
                case /* uint64 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.uint64().toString()
                    };
                    break;
                case /* uint64 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.uint64().toString()
                    };
                    break;
                case /* uint64 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.uint64().toString()
                    };
                    break;
                case /* uint64 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.uint64().toString()
                    };
                    break;
                case /* repeated uint64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.uint64().toString());
                    else
                        message.in.push(reader.uint64().toString());
                    break;
                case /* repeated uint64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.uint64().toString());
                    else
                        message.notIn.push(reader.uint64().toString());
                    break;
                case /* repeated uint64 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.uint64().toString());
                    else
                        message.example.push(reader.uint64().toString());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UInt64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.const);
        /* uint64 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Varint).uint64(message.lessThan.lt);
        /* uint64 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Varint).uint64(message.lessThan.lte);
        /* uint64 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Varint).uint64(message.greaterThan.gt);
        /* uint64 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Varint).uint64(message.greaterThan.gte);
        /* repeated uint64 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Varint).uint64(message.in[i]);
        /* repeated uint64 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Varint).uint64(message.notIn[i]);
        /* repeated uint64 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Varint).uint64(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.UInt64Rules
 */
export const UInt64Rules = new UInt64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SInt32Rules$Type extends MessageType<SInt32Rules> {
    constructor() {
        super("buf.validate.SInt32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "sint32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "sint32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "sint32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "sint32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "sint32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sint32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sint32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "sint32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "sint32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "sint32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sint32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sint32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "sint32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "sint32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "sint32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.predefined": { cel: [{ id: "sint32.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<SInt32Rules>): SInt32Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SInt32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SInt32Rules): SInt32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint32 const */ 1:
                    message.const = reader.sint32();
                    break;
                case /* sint32 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.sint32()
                    };
                    break;
                case /* sint32 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.sint32()
                    };
                    break;
                case /* sint32 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.sint32()
                    };
                    break;
                case /* sint32 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.sint32()
                    };
                    break;
                case /* repeated sint32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.sint32());
                    else
                        message.in.push(reader.sint32());
                    break;
                case /* repeated sint32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.sint32());
                    else
                        message.notIn.push(reader.sint32());
                    break;
                case /* repeated sint32 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.sint32());
                    else
                        message.example.push(reader.sint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SInt32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).sint32(message.const);
        /* sint32 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Varint).sint32(message.lessThan.lt);
        /* sint32 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Varint).sint32(message.lessThan.lte);
        /* sint32 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Varint).sint32(message.greaterThan.gt);
        /* sint32 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Varint).sint32(message.greaterThan.gte);
        /* repeated sint32 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Varint).sint32(message.in[i]);
        /* repeated sint32 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Varint).sint32(message.notIn[i]);
        /* repeated sint32 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Varint).sint32(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.SInt32Rules
 */
export const SInt32Rules = new SInt32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SInt64Rules$Type extends MessageType<SInt64Rules> {
    constructor() {
        super("buf.validate.SInt64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "sint64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 18 /*ScalarType.SINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "sint64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 18 /*ScalarType.SINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "sint64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 18 /*ScalarType.SINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "sint64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "sint64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sint64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sint64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "sint64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 18 /*ScalarType.SINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "sint64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "sint64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sint64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sint64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "sint64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 18 /*ScalarType.SINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "sint64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 18 /*ScalarType.SINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "sint64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 18 /*ScalarType.SINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "sint64.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<SInt64Rules>): SInt64Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SInt64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SInt64Rules): SInt64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint64 const */ 1:
                    message.const = reader.sint64().toString();
                    break;
                case /* sint64 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.sint64().toString()
                    };
                    break;
                case /* sint64 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.sint64().toString()
                    };
                    break;
                case /* sint64 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.sint64().toString()
                    };
                    break;
                case /* sint64 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.sint64().toString()
                    };
                    break;
                case /* repeated sint64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.sint64().toString());
                    else
                        message.in.push(reader.sint64().toString());
                    break;
                case /* repeated sint64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.sint64().toString());
                    else
                        message.notIn.push(reader.sint64().toString());
                    break;
                case /* repeated sint64 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.sint64().toString());
                    else
                        message.example.push(reader.sint64().toString());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SInt64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).sint64(message.const);
        /* sint64 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Varint).sint64(message.lessThan.lt);
        /* sint64 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Varint).sint64(message.lessThan.lte);
        /* sint64 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Varint).sint64(message.greaterThan.gt);
        /* sint64 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Varint).sint64(message.greaterThan.gte);
        /* repeated sint64 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Varint).sint64(message.in[i]);
        /* repeated sint64 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Varint).sint64(message.notIn[i]);
        /* repeated sint64 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Varint).sint64(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.SInt64Rules
 */
export const SInt64Rules = new SInt64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Fixed32Rules$Type extends MessageType<Fixed32Rules> {
    constructor() {
        super("buf.validate.Fixed32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "fixed32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "fixed32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "fixed32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "fixed32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "fixed32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "fixed32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "fixed32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "fixed32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed32.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<Fixed32Rules>): Fixed32Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Fixed32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Fixed32Rules): Fixed32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 const */ 1:
                    message.const = reader.fixed32();
                    break;
                case /* fixed32 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.fixed32()
                    };
                    break;
                case /* fixed32 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.fixed32()
                    };
                    break;
                case /* fixed32 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.fixed32()
                    };
                    break;
                case /* fixed32 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.fixed32()
                    };
                    break;
                case /* repeated fixed32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.fixed32());
                    else
                        message.in.push(reader.fixed32());
                    break;
                case /* repeated fixed32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.fixed32());
                    else
                        message.notIn.push(reader.fixed32());
                    break;
                case /* repeated fixed32 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.fixed32());
                    else
                        message.example.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Fixed32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.const);
        /* fixed32 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Bit32).fixed32(message.lessThan.lt);
        /* fixed32 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Bit32).fixed32(message.lessThan.lte);
        /* fixed32 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Bit32).fixed32(message.greaterThan.gt);
        /* fixed32 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Bit32).fixed32(message.greaterThan.gte);
        /* repeated fixed32 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Bit32).fixed32(message.in[i]);
        /* repeated fixed32 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Bit32).fixed32(message.notIn[i]);
        /* repeated fixed32 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Bit32).fixed32(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Fixed32Rules
 */
export const Fixed32Rules = new Fixed32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Fixed64Rules$Type extends MessageType<Fixed64Rules> {
    constructor() {
        super("buf.validate.Fixed64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 6 /*ScalarType.FIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 6 /*ScalarType.FIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 6 /*ScalarType.FIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "fixed64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "fixed64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "fixed64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "fixed64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 6 /*ScalarType.FIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "fixed64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "fixed64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "fixed64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "fixed64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "fixed64.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<Fixed64Rules>): Fixed64Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Fixed64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Fixed64Rules): Fixed64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 const */ 1:
                    message.const = reader.fixed64().toString();
                    break;
                case /* fixed64 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.fixed64().toString()
                    };
                    break;
                case /* fixed64 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.fixed64().toString()
                    };
                    break;
                case /* fixed64 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.fixed64().toString()
                    };
                    break;
                case /* fixed64 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.fixed64().toString()
                    };
                    break;
                case /* repeated fixed64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.fixed64().toString());
                    else
                        message.in.push(reader.fixed64().toString());
                    break;
                case /* repeated fixed64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.fixed64().toString());
                    else
                        message.notIn.push(reader.fixed64().toString());
                    break;
                case /* repeated fixed64 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.fixed64().toString());
                    else
                        message.example.push(reader.fixed64().toString());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Fixed64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.const);
        /* fixed64 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Bit64).fixed64(message.lessThan.lt);
        /* fixed64 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Bit64).fixed64(message.lessThan.lte);
        /* fixed64 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Bit64).fixed64(message.greaterThan.gt);
        /* fixed64 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Bit64).fixed64(message.greaterThan.gte);
        /* repeated fixed64 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Bit64).fixed64(message.in[i]);
        /* repeated fixed64 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Bit64).fixed64(message.notIn[i]);
        /* repeated fixed64 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Bit64).fixed64(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Fixed64Rules
 */
export const Fixed64Rules = new Fixed64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFixed32Rules$Type extends MessageType<SFixed32Rules> {
    constructor() {
        super("buf.validate.SFixed32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "sfixed32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sfixed32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sfixed32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "sfixed32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "sfixed32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sfixed32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sfixed32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "sfixed32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed32.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<SFixed32Rules>): SFixed32Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SFixed32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SFixed32Rules): SFixed32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sfixed32 const */ 1:
                    message.const = reader.sfixed32();
                    break;
                case /* sfixed32 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.sfixed32()
                    };
                    break;
                case /* sfixed32 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.sfixed32()
                    };
                    break;
                case /* sfixed32 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.sfixed32()
                    };
                    break;
                case /* sfixed32 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.sfixed32()
                    };
                    break;
                case /* repeated sfixed32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.sfixed32());
                    else
                        message.in.push(reader.sfixed32());
                    break;
                case /* repeated sfixed32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.sfixed32());
                    else
                        message.notIn.push(reader.sfixed32());
                    break;
                case /* repeated sfixed32 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.sfixed32());
                    else
                        message.example.push(reader.sfixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SFixed32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sfixed32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Bit32).sfixed32(message.const);
        /* sfixed32 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Bit32).sfixed32(message.lessThan.lt);
        /* sfixed32 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Bit32).sfixed32(message.lessThan.lte);
        /* sfixed32 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Bit32).sfixed32(message.greaterThan.gt);
        /* sfixed32 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Bit32).sfixed32(message.greaterThan.gte);
        /* repeated sfixed32 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Bit32).sfixed32(message.in[i]);
        /* repeated sfixed32 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Bit32).sfixed32(message.notIn[i]);
        /* repeated sfixed32 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Bit32).sfixed32(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.SFixed32Rules
 */
export const SFixed32Rules = new SFixed32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFixed64Rules$Type extends MessageType<SFixed64Rules> {
    constructor() {
        super("buf.validate.SFixed64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 16 /*ScalarType.SFIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "lessThan", T: 16 /*ScalarType.SFIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "lessThan", T: 16 /*ScalarType.SFIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greaterThan", T: 16 /*ScalarType.SFIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "sfixed64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sfixed64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sfixed64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "sfixed64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greaterThan", T: 16 /*ScalarType.SFIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "sfixed64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sfixed64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sfixed64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "sfixed64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 16 /*ScalarType.SFIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 16 /*ScalarType.SFIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 16 /*ScalarType.SFIXED64*/, options: { "buf.validate.predefined": { cel: [{ id: "sfixed64.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<SFixed64Rules>): SFixed64Rules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SFixed64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SFixed64Rules): SFixed64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sfixed64 const */ 1:
                    message.const = reader.sfixed64().toString();
                    break;
                case /* sfixed64 lt */ 2:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: reader.sfixed64().toString()
                    };
                    break;
                case /* sfixed64 lte */ 3:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: reader.sfixed64().toString()
                    };
                    break;
                case /* sfixed64 gt */ 4:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: reader.sfixed64().toString()
                    };
                    break;
                case /* sfixed64 gte */ 5:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: reader.sfixed64().toString()
                    };
                    break;
                case /* repeated sfixed64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.sfixed64().toString());
                    else
                        message.in.push(reader.sfixed64().toString());
                    break;
                case /* repeated sfixed64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.sfixed64().toString());
                    else
                        message.notIn.push(reader.sfixed64().toString());
                    break;
                case /* repeated sfixed64 example */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.sfixed64().toString());
                    else
                        message.example.push(reader.sfixed64().toString());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SFixed64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sfixed64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Bit64).sfixed64(message.const);
        /* sfixed64 lt = 2; */
        if (message.lessThan.oneofKind === "lt")
            writer.tag(2, WireType.Bit64).sfixed64(message.lessThan.lt);
        /* sfixed64 lte = 3; */
        if (message.lessThan.oneofKind === "lte")
            writer.tag(3, WireType.Bit64).sfixed64(message.lessThan.lte);
        /* sfixed64 gt = 4; */
        if (message.greaterThan.oneofKind === "gt")
            writer.tag(4, WireType.Bit64).sfixed64(message.greaterThan.gt);
        /* sfixed64 gte = 5; */
        if (message.greaterThan.oneofKind === "gte")
            writer.tag(5, WireType.Bit64).sfixed64(message.greaterThan.gte);
        /* repeated sfixed64 in = 6; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(6, WireType.Bit64).sfixed64(message.in[i]);
        /* repeated sfixed64 not_in = 7; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(7, WireType.Bit64).sfixed64(message.notIn[i]);
        /* repeated sfixed64 example = 8; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(8, WireType.Bit64).sfixed64(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.SFixed64Rules
 */
export const SFixed64Rules = new SFixed64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoolRules$Type extends MessageType<BoolRules> {
    constructor() {
        super("buf.validate.BoolRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "bool.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "bool.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<BoolRules>): BoolRules {
        const message = { example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BoolRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoolRules): BoolRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool const */ 1:
                    message.const = reader.bool();
                    break;
                case /* repeated bool example */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.bool());
                    else
                        message.example.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoolRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).bool(message.const);
        /* repeated bool example = 2; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(2, WireType.Varint).bool(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.BoolRules
 */
export const BoolRules = new BoolRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringRules$Type extends MessageType<StringRules> {
    constructor() {
        super("buf.validate.StringRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.const", expression: "this != rules.const ? 'value must equal `%s`'.format([rules.const]) : ''" }] } } },
            { no: 19, name: "len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "string.len", expression: "uint(this.size()) != rules.len ? 'value length must be %s characters'.format([rules.len]) : ''" }] } } },
            { no: 2, name: "min_len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "string.min_len", expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s characters'.format([rules.min_len]) : ''" }] } } },
            { no: 3, name: "max_len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "string.max_len", expression: "uint(this.size()) > rules.max_len ? 'value length must be at most %s characters'.format([rules.max_len]) : ''" }] } } },
            { no: 20, name: "len_bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "string.len_bytes", expression: "uint(bytes(this).size()) != rules.len_bytes ? 'value length must be %s bytes'.format([rules.len_bytes]) : ''" }] } } },
            { no: 4, name: "min_bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "string.min_bytes", expression: "uint(bytes(this).size()) < rules.min_bytes ? 'value length must be at least %s bytes'.format([rules.min_bytes]) : ''" }] } } },
            { no: 5, name: "max_bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "string.max_bytes", expression: "uint(bytes(this).size()) > rules.max_bytes ? 'value length must be at most %s bytes'.format([rules.max_bytes]) : ''" }] } } },
            { no: 6, name: "pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.pattern", expression: "!this.matches(rules.pattern) ? 'value does not match regex pattern `%s`'.format([rules.pattern]) : ''" }] } } },
            { no: 7, name: "prefix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.prefix", expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix `%s`'.format([rules.prefix]) : ''" }] } } },
            { no: 8, name: "suffix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.suffix", expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix `%s`'.format([rules.suffix]) : ''" }] } } },
            { no: 9, name: "contains", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.contains", expression: "!this.contains(rules.contains) ? 'value does not contain substring `%s`'.format([rules.contains]) : ''" }] } } },
            { no: 23, name: "not_contains", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.not_contains", expression: "this.contains(rules.not_contains) ? 'value contains substring `%s`'.format([rules.not_contains]) : ''" }] } } },
            { no: 10, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 11, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 12, name: "email", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.email", message: "value must be a valid email address", expression: "!rules.email || this == '' || this.isEmail()" }, { id: "string.email_empty", message: "value is empty, which is not a valid email address", expression: "!rules.email || this != ''" }] } } },
            { no: 13, name: "hostname", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.hostname", message: "value must be a valid hostname", expression: "!rules.hostname || this == '' || this.isHostname()" }, { id: "string.hostname_empty", message: "value is empty, which is not a valid hostname", expression: "!rules.hostname || this != ''" }] } } },
            { no: 14, name: "ip", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ip", message: "value must be a valid IP address", expression: "!rules.ip || this == '' || this.isIp()" }, { id: "string.ip_empty", message: "value is empty, which is not a valid IP address", expression: "!rules.ip || this != ''" }] } } },
            { no: 15, name: "ipv4", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ipv4", message: "value must be a valid IPv4 address", expression: "!rules.ipv4 || this == '' || this.isIp(4)" }, { id: "string.ipv4_empty", message: "value is empty, which is not a valid IPv4 address", expression: "!rules.ipv4 || this != ''" }] } } },
            { no: 16, name: "ipv6", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ipv6", message: "value must be a valid IPv6 address", expression: "!rules.ipv6 || this == '' || this.isIp(6)" }, { id: "string.ipv6_empty", message: "value is empty, which is not a valid IPv6 address", expression: "!rules.ipv6 || this != ''" }] } } },
            { no: 17, name: "uri", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.uri", message: "value must be a valid URI", expression: "!rules.uri || this == '' || this.isUri()" }, { id: "string.uri_empty", message: "value is empty, which is not a valid URI", expression: "!rules.uri || this != ''" }] } } },
            { no: 18, name: "uri_ref", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.uri_ref", message: "value must be a valid URI Reference", expression: "!rules.uri_ref || this.isUriRef()" }] } } },
            { no: 21, name: "address", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.address", message: "value must be a valid hostname, or ip address", expression: "!rules.address || this == '' || this.isHostname() || this.isIp()" }, { id: "string.address_empty", message: "value is empty, which is not a valid hostname, or ip address", expression: "!rules.address || this != ''" }] } } },
            { no: 22, name: "uuid", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.uuid", message: "value must be a valid UUID", expression: "!rules.uuid || this == '' || this.matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')" }, { id: "string.uuid_empty", message: "value is empty, which is not a valid UUID", expression: "!rules.uuid || this != ''" }] } } },
            { no: 33, name: "tuuid", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.tuuid", message: "value must be a valid trimmed UUID", expression: "!rules.tuuid || this == '' || this.matches('^[0-9a-fA-F]{32}$')" }, { id: "string.tuuid_empty", message: "value is empty, which is not a valid trimmed UUID", expression: "!rules.tuuid || this != ''" }] } } },
            { no: 26, name: "ip_with_prefixlen", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ip_with_prefixlen", message: "value must be a valid IP prefix", expression: "!rules.ip_with_prefixlen || this == '' || this.isIpPrefix()" }, { id: "string.ip_with_prefixlen_empty", message: "value is empty, which is not a valid IP prefix", expression: "!rules.ip_with_prefixlen || this != ''" }] } } },
            { no: 27, name: "ipv4_with_prefixlen", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ipv4_with_prefixlen", message: "value must be a valid IPv4 address with prefix length", expression: "!rules.ipv4_with_prefixlen || this == '' || this.isIpPrefix(4)" }, { id: "string.ipv4_with_prefixlen_empty", message: "value is empty, which is not a valid IPv4 address with prefix length", expression: "!rules.ipv4_with_prefixlen || this != ''" }] } } },
            { no: 28, name: "ipv6_with_prefixlen", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ipv6_with_prefixlen", message: "value must be a valid IPv6 address with prefix length", expression: "!rules.ipv6_with_prefixlen || this == '' || this.isIpPrefix(6)" }, { id: "string.ipv6_with_prefixlen_empty", message: "value is empty, which is not a valid IPv6 address with prefix length", expression: "!rules.ipv6_with_prefixlen || this != ''" }] } } },
            { no: 29, name: "ip_prefix", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ip_prefix", message: "value must be a valid IP prefix", expression: "!rules.ip_prefix || this == '' || this.isIpPrefix(true)" }, { id: "string.ip_prefix_empty", message: "value is empty, which is not a valid IP prefix", expression: "!rules.ip_prefix || this != ''" }] } } },
            { no: 30, name: "ipv4_prefix", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ipv4_prefix", message: "value must be a valid IPv4 prefix", expression: "!rules.ipv4_prefix || this == '' || this.isIpPrefix(4, true)" }, { id: "string.ipv4_prefix_empty", message: "value is empty, which is not a valid IPv4 prefix", expression: "!rules.ipv4_prefix || this != ''" }] } } },
            { no: 31, name: "ipv6_prefix", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.ipv6_prefix", message: "value must be a valid IPv6 prefix", expression: "!rules.ipv6_prefix || this == '' || this.isIpPrefix(6, true)" }, { id: "string.ipv6_prefix_empty", message: "value is empty, which is not a valid IPv6 prefix", expression: "!rules.ipv6_prefix || this != ''" }] } } },
            { no: 32, name: "host_and_port", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "string.host_and_port", message: "value must be a valid host (hostname or IP address) and port pair", expression: "!rules.host_and_port || this == '' || this.isHostAndPort(true)" }, { id: "string.host_and_port_empty", message: "value is empty, which is not a valid host and port pair", expression: "!rules.host_and_port || this != ''" }] } } },
            { no: 24, name: "well_known_regex", kind: "enum", oneof: "wellKnown", T: () => ["buf.validate.KnownRegex", KnownRegex, "KNOWN_REGEX_"], options: { "buf.validate.predefined": { cel: [{ id: "string.well_known_regex.header_name", message: "value must be a valid HTTP header name", expression: "rules.well_known_regex != 1 || this == '' || this.matches(!has(rules.strict) || rules.strict ?'^:?[0-9a-zA-Z!#$%&\\'*+-.^_|~\\x60]+$' :'^[^\\u0000\\u000A\\u000D]+$')" }, { id: "string.well_known_regex.header_name_empty", message: "value is empty, which is not a valid HTTP header name", expression: "rules.well_known_regex != 1 || this != ''" }, { id: "string.well_known_regex.header_value", message: "value must be a valid HTTP header value", expression: "rules.well_known_regex != 2 || this.matches(!has(rules.strict) || rules.strict ?'^[^\\u0000-\\u0008\\u000A-\\u001F\\u007F]*$' :'^[^\\u0000\\u000A\\u000D]*$')" }] } } },
            { no: 25, name: "strict", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 34, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "string.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<StringRules>): StringRules {
        const message = { in: [], notIn: [], wellKnown: { oneofKind: undefined }, example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StringRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringRules): StringRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string const */ 1:
                    message.const = reader.string();
                    break;
                case /* optional uint64 len */ 19:
                    message.len = reader.uint64().toString();
                    break;
                case /* optional uint64 min_len */ 2:
                    message.minLen = reader.uint64().toString();
                    break;
                case /* optional uint64 max_len */ 3:
                    message.maxLen = reader.uint64().toString();
                    break;
                case /* optional uint64 len_bytes */ 20:
                    message.lenBytes = reader.uint64().toString();
                    break;
                case /* optional uint64 min_bytes */ 4:
                    message.minBytes = reader.uint64().toString();
                    break;
                case /* optional uint64 max_bytes */ 5:
                    message.maxBytes = reader.uint64().toString();
                    break;
                case /* optional string pattern */ 6:
                    message.pattern = reader.string();
                    break;
                case /* optional string prefix */ 7:
                    message.prefix = reader.string();
                    break;
                case /* optional string suffix */ 8:
                    message.suffix = reader.string();
                    break;
                case /* optional string contains */ 9:
                    message.contains = reader.string();
                    break;
                case /* optional string not_contains */ 23:
                    message.notContains = reader.string();
                    break;
                case /* repeated string in */ 10:
                    message.in.push(reader.string());
                    break;
                case /* repeated string not_in */ 11:
                    message.notIn.push(reader.string());
                    break;
                case /* bool email */ 12:
                    message.wellKnown = {
                        oneofKind: "email",
                        email: reader.bool()
                    };
                    break;
                case /* bool hostname */ 13:
                    message.wellKnown = {
                        oneofKind: "hostname",
                        hostname: reader.bool()
                    };
                    break;
                case /* bool ip */ 14:
                    message.wellKnown = {
                        oneofKind: "ip",
                        ip: reader.bool()
                    };
                    break;
                case /* bool ipv4 */ 15:
                    message.wellKnown = {
                        oneofKind: "ipv4",
                        ipv4: reader.bool()
                    };
                    break;
                case /* bool ipv6 */ 16:
                    message.wellKnown = {
                        oneofKind: "ipv6",
                        ipv6: reader.bool()
                    };
                    break;
                case /* bool uri */ 17:
                    message.wellKnown = {
                        oneofKind: "uri",
                        uri: reader.bool()
                    };
                    break;
                case /* bool uri_ref */ 18:
                    message.wellKnown = {
                        oneofKind: "uriRef",
                        uriRef: reader.bool()
                    };
                    break;
                case /* bool address */ 21:
                    message.wellKnown = {
                        oneofKind: "address",
                        address: reader.bool()
                    };
                    break;
                case /* bool uuid */ 22:
                    message.wellKnown = {
                        oneofKind: "uuid",
                        uuid: reader.bool()
                    };
                    break;
                case /* bool tuuid */ 33:
                    message.wellKnown = {
                        oneofKind: "tuuid",
                        tuuid: reader.bool()
                    };
                    break;
                case /* bool ip_with_prefixlen */ 26:
                    message.wellKnown = {
                        oneofKind: "ipWithPrefixlen",
                        ipWithPrefixlen: reader.bool()
                    };
                    break;
                case /* bool ipv4_with_prefixlen */ 27:
                    message.wellKnown = {
                        oneofKind: "ipv4WithPrefixlen",
                        ipv4WithPrefixlen: reader.bool()
                    };
                    break;
                case /* bool ipv6_with_prefixlen */ 28:
                    message.wellKnown = {
                        oneofKind: "ipv6WithPrefixlen",
                        ipv6WithPrefixlen: reader.bool()
                    };
                    break;
                case /* bool ip_prefix */ 29:
                    message.wellKnown = {
                        oneofKind: "ipPrefix",
                        ipPrefix: reader.bool()
                    };
                    break;
                case /* bool ipv4_prefix */ 30:
                    message.wellKnown = {
                        oneofKind: "ipv4Prefix",
                        ipv4Prefix: reader.bool()
                    };
                    break;
                case /* bool ipv6_prefix */ 31:
                    message.wellKnown = {
                        oneofKind: "ipv6Prefix",
                        ipv6Prefix: reader.bool()
                    };
                    break;
                case /* bool host_and_port */ 32:
                    message.wellKnown = {
                        oneofKind: "hostAndPort",
                        hostAndPort: reader.bool()
                    };
                    break;
                case /* buf.validate.KnownRegex well_known_regex */ 24:
                    message.wellKnown = {
                        oneofKind: "wellKnownRegex",
                        wellKnownRegex: reader.int32()
                    };
                    break;
                case /* optional bool strict */ 25:
                    message.strict = reader.bool();
                    break;
                case /* repeated string example */ 34:
                    message.example.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StringRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.const);
        /* optional uint64 len = 19; */
        if (message.len !== undefined)
            writer.tag(19, WireType.Varint).uint64(message.len);
        /* optional uint64 min_len = 2; */
        if (message.minLen !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.minLen);
        /* optional uint64 max_len = 3; */
        if (message.maxLen !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.maxLen);
        /* optional uint64 len_bytes = 20; */
        if (message.lenBytes !== undefined)
            writer.tag(20, WireType.Varint).uint64(message.lenBytes);
        /* optional uint64 min_bytes = 4; */
        if (message.minBytes !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.minBytes);
        /* optional uint64 max_bytes = 5; */
        if (message.maxBytes !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.maxBytes);
        /* optional string pattern = 6; */
        if (message.pattern !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.pattern);
        /* optional string prefix = 7; */
        if (message.prefix !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.prefix);
        /* optional string suffix = 8; */
        if (message.suffix !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.suffix);
        /* optional string contains = 9; */
        if (message.contains !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.contains);
        /* optional string not_contains = 23; */
        if (message.notContains !== undefined)
            writer.tag(23, WireType.LengthDelimited).string(message.notContains);
        /* repeated string in = 10; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.in[i]);
        /* repeated string not_in = 11; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.notIn[i]);
        /* bool email = 12; */
        if (message.wellKnown.oneofKind === "email")
            writer.tag(12, WireType.Varint).bool(message.wellKnown.email);
        /* bool hostname = 13; */
        if (message.wellKnown.oneofKind === "hostname")
            writer.tag(13, WireType.Varint).bool(message.wellKnown.hostname);
        /* bool ip = 14; */
        if (message.wellKnown.oneofKind === "ip")
            writer.tag(14, WireType.Varint).bool(message.wellKnown.ip);
        /* bool ipv4 = 15; */
        if (message.wellKnown.oneofKind === "ipv4")
            writer.tag(15, WireType.Varint).bool(message.wellKnown.ipv4);
        /* bool ipv6 = 16; */
        if (message.wellKnown.oneofKind === "ipv6")
            writer.tag(16, WireType.Varint).bool(message.wellKnown.ipv6);
        /* bool uri = 17; */
        if (message.wellKnown.oneofKind === "uri")
            writer.tag(17, WireType.Varint).bool(message.wellKnown.uri);
        /* bool uri_ref = 18; */
        if (message.wellKnown.oneofKind === "uriRef")
            writer.tag(18, WireType.Varint).bool(message.wellKnown.uriRef);
        /* bool address = 21; */
        if (message.wellKnown.oneofKind === "address")
            writer.tag(21, WireType.Varint).bool(message.wellKnown.address);
        /* bool uuid = 22; */
        if (message.wellKnown.oneofKind === "uuid")
            writer.tag(22, WireType.Varint).bool(message.wellKnown.uuid);
        /* bool tuuid = 33; */
        if (message.wellKnown.oneofKind === "tuuid")
            writer.tag(33, WireType.Varint).bool(message.wellKnown.tuuid);
        /* bool ip_with_prefixlen = 26; */
        if (message.wellKnown.oneofKind === "ipWithPrefixlen")
            writer.tag(26, WireType.Varint).bool(message.wellKnown.ipWithPrefixlen);
        /* bool ipv4_with_prefixlen = 27; */
        if (message.wellKnown.oneofKind === "ipv4WithPrefixlen")
            writer.tag(27, WireType.Varint).bool(message.wellKnown.ipv4WithPrefixlen);
        /* bool ipv6_with_prefixlen = 28; */
        if (message.wellKnown.oneofKind === "ipv6WithPrefixlen")
            writer.tag(28, WireType.Varint).bool(message.wellKnown.ipv6WithPrefixlen);
        /* bool ip_prefix = 29; */
        if (message.wellKnown.oneofKind === "ipPrefix")
            writer.tag(29, WireType.Varint).bool(message.wellKnown.ipPrefix);
        /* bool ipv4_prefix = 30; */
        if (message.wellKnown.oneofKind === "ipv4Prefix")
            writer.tag(30, WireType.Varint).bool(message.wellKnown.ipv4Prefix);
        /* bool ipv6_prefix = 31; */
        if (message.wellKnown.oneofKind === "ipv6Prefix")
            writer.tag(31, WireType.Varint).bool(message.wellKnown.ipv6Prefix);
        /* bool host_and_port = 32; */
        if (message.wellKnown.oneofKind === "hostAndPort")
            writer.tag(32, WireType.Varint).bool(message.wellKnown.hostAndPort);
        /* buf.validate.KnownRegex well_known_regex = 24; */
        if (message.wellKnown.oneofKind === "wellKnownRegex")
            writer.tag(24, WireType.Varint).int32(message.wellKnown.wellKnownRegex);
        /* optional bool strict = 25; */
        if (message.strict !== undefined)
            writer.tag(25, WireType.Varint).bool(message.strict);
        /* repeated string example = 34; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(34, WireType.LengthDelimited).string(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.StringRules
 */
export const StringRules = new StringRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BytesRules$Type extends MessageType<BytesRules> {
    constructor() {
        super("buf.validate.BytesRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.const", expression: "this != rules.const ? 'value must be %x'.format([rules.const]) : ''" }] } } },
            { no: 13, name: "len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.len", expression: "uint(this.size()) != rules.len ? 'value length must be %s bytes'.format([rules.len]) : ''" }] } } },
            { no: 2, name: "min_len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.min_len", expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s bytes'.format([rules.min_len]) : ''" }] } } },
            { no: 3, name: "max_len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.max_len", expression: "uint(this.size()) > rules.max_len ? 'value must be at most %s bytes'.format([rules.max_len]) : ''" }] } } },
            { no: 4, name: "pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.pattern", expression: "!string(this).matches(rules.pattern) ? 'value must match regex pattern `%s`'.format([rules.pattern]) : ''" }] } } },
            { no: 5, name: "prefix", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.prefix", expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix %x'.format([rules.prefix]) : ''" }] } } },
            { no: 6, name: "suffix", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.suffix", expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix %x'.format([rules.suffix]) : ''" }] } } },
            { no: 7, name: "contains", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.contains", expression: "!this.contains(rules.contains) ? 'value does not contain %x'.format([rules.contains]) : ''" }] } } },
            { no: 8, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.in", expression: "dyn(rules)['in'].size() > 0 && !(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 9, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 10, name: "ip", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.ip", message: "value must be a valid IP address", expression: "!rules.ip || this.size() == 0 || this.size() == 4 || this.size() == 16" }, { id: "bytes.ip_empty", message: "value is empty, which is not a valid IP address", expression: "!rules.ip || this.size() != 0" }] } } },
            { no: 11, name: "ipv4", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.ipv4", message: "value must be a valid IPv4 address", expression: "!rules.ipv4 || this.size() == 0 || this.size() == 4" }, { id: "bytes.ipv4_empty", message: "value is empty, which is not a valid IPv4 address", expression: "!rules.ipv4 || this.size() != 0" }] } } },
            { no: 12, name: "ipv6", kind: "scalar", oneof: "wellKnown", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.ipv6", message: "value must be a valid IPv6 address", expression: "!rules.ipv6 || this.size() == 0 || this.size() == 16" }, { id: "bytes.ipv6_empty", message: "value is empty, which is not a valid IPv6 address", expression: "!rules.ipv6 || this.size() != 0" }] } } },
            { no: 14, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.predefined": { cel: [{ id: "bytes.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<BytesRules>): BytesRules {
        const message = { in: [], notIn: [], wellKnown: { oneofKind: undefined }, example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BytesRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BytesRules): BytesRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes const */ 1:
                    message.const = reader.bytes();
                    break;
                case /* optional uint64 len */ 13:
                    message.len = reader.uint64().toString();
                    break;
                case /* optional uint64 min_len */ 2:
                    message.minLen = reader.uint64().toString();
                    break;
                case /* optional uint64 max_len */ 3:
                    message.maxLen = reader.uint64().toString();
                    break;
                case /* optional string pattern */ 4:
                    message.pattern = reader.string();
                    break;
                case /* optional bytes prefix */ 5:
                    message.prefix = reader.bytes();
                    break;
                case /* optional bytes suffix */ 6:
                    message.suffix = reader.bytes();
                    break;
                case /* optional bytes contains */ 7:
                    message.contains = reader.bytes();
                    break;
                case /* repeated bytes in */ 8:
                    message.in.push(reader.bytes());
                    break;
                case /* repeated bytes not_in */ 9:
                    message.notIn.push(reader.bytes());
                    break;
                case /* bool ip */ 10:
                    message.wellKnown = {
                        oneofKind: "ip",
                        ip: reader.bool()
                    };
                    break;
                case /* bool ipv4 */ 11:
                    message.wellKnown = {
                        oneofKind: "ipv4",
                        ipv4: reader.bool()
                    };
                    break;
                case /* bool ipv6 */ 12:
                    message.wellKnown = {
                        oneofKind: "ipv6",
                        ipv6: reader.bool()
                    };
                    break;
                case /* repeated bytes example */ 14:
                    message.example.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BytesRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.const);
        /* optional uint64 len = 13; */
        if (message.len !== undefined)
            writer.tag(13, WireType.Varint).uint64(message.len);
        /* optional uint64 min_len = 2; */
        if (message.minLen !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.minLen);
        /* optional uint64 max_len = 3; */
        if (message.maxLen !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.maxLen);
        /* optional string pattern = 4; */
        if (message.pattern !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.pattern);
        /* optional bytes prefix = 5; */
        if (message.prefix !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.prefix);
        /* optional bytes suffix = 6; */
        if (message.suffix !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.suffix);
        /* optional bytes contains = 7; */
        if (message.contains !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.contains);
        /* repeated bytes in = 8; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(8, WireType.LengthDelimited).bytes(message.in[i]);
        /* repeated bytes not_in = 9; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(9, WireType.LengthDelimited).bytes(message.notIn[i]);
        /* bool ip = 10; */
        if (message.wellKnown.oneofKind === "ip")
            writer.tag(10, WireType.Varint).bool(message.wellKnown.ip);
        /* bool ipv4 = 11; */
        if (message.wellKnown.oneofKind === "ipv4")
            writer.tag(11, WireType.Varint).bool(message.wellKnown.ipv4);
        /* bool ipv6 = 12; */
        if (message.wellKnown.oneofKind === "ipv6")
            writer.tag(12, WireType.Varint).bool(message.wellKnown.ipv6);
        /* repeated bytes example = 14; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(14, WireType.LengthDelimited).bytes(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.BytesRules
 */
export const BytesRules = new BytesRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnumRules$Type extends MessageType<EnumRules> {
    constructor() {
        super("buf.validate.EnumRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "enum.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "defined_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "enum.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 4, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "enum.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 5, name: "example", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.predefined": { cel: [{ id: "enum.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<EnumRules>): EnumRules {
        const message = { in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnumRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnumRules): EnumRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 const */ 1:
                    message.const = reader.int32();
                    break;
                case /* optional bool defined_only */ 2:
                    message.definedOnly = reader.bool();
                    break;
                case /* repeated int32 in */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int32());
                    else
                        message.in.push(reader.int32());
                    break;
                case /* repeated int32 not_in */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notIn.push(reader.int32());
                    else
                        message.notIn.push(reader.int32());
                    break;
                case /* repeated int32 example */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.example.push(reader.int32());
                    else
                        message.example.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnumRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int32(message.const);
        /* optional bool defined_only = 2; */
        if (message.definedOnly !== undefined)
            writer.tag(2, WireType.Varint).bool(message.definedOnly);
        /* repeated int32 in = 3; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(3, WireType.Varint).int32(message.in[i]);
        /* repeated int32 not_in = 4; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(4, WireType.Varint).int32(message.notIn[i]);
        /* repeated int32 example = 5; */
        for (let i = 0; i < message.example.length; i++)
            writer.tag(5, WireType.Varint).int32(message.example[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.EnumRules
 */
export const EnumRules = new EnumRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RepeatedRules$Type extends MessageType<RepeatedRules> {
    constructor() {
        super("buf.validate.RepeatedRules", [
            { no: 1, name: "min_items", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "repeated.min_items", expression: "uint(this.size()) < rules.min_items ? 'value must contain at least %d item(s)'.format([rules.min_items]) : ''" }] } } },
            { no: 2, name: "max_items", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "repeated.max_items", expression: "uint(this.size()) > rules.max_items ? 'value must contain no more than %s item(s)'.format([rules.max_items]) : ''" }] } } },
            { no: 3, name: "unique", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "repeated.unique", message: "repeated value must contain unique items", expression: "!rules.unique || this.unique()" }] } } },
            { no: 4, name: "items", kind: "message", T: () => FieldConstraints }
        ]);
    }
    create(value?: PartialMessage<RepeatedRules>): RepeatedRules {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RepeatedRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RepeatedRules): RepeatedRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 min_items */ 1:
                    message.minItems = reader.uint64().toString();
                    break;
                case /* optional uint64 max_items */ 2:
                    message.maxItems = reader.uint64().toString();
                    break;
                case /* optional bool unique */ 3:
                    message.unique = reader.bool();
                    break;
                case /* optional buf.validate.FieldConstraints items */ 4:
                    message.items = FieldConstraints.internalBinaryRead(reader, reader.uint32(), options, message.items);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RepeatedRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 min_items = 1; */
        if (message.minItems !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.minItems);
        /* optional uint64 max_items = 2; */
        if (message.maxItems !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.maxItems);
        /* optional bool unique = 3; */
        if (message.unique !== undefined)
            writer.tag(3, WireType.Varint).bool(message.unique);
        /* optional buf.validate.FieldConstraints items = 4; */
        if (message.items)
            FieldConstraints.internalBinaryWrite(message.items, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.RepeatedRules
 */
export const RepeatedRules = new RepeatedRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapRules$Type extends MessageType<MapRules> {
    constructor() {
        super("buf.validate.MapRules", [
            { no: 1, name: "min_pairs", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "map.min_pairs", expression: "uint(this.size()) < rules.min_pairs ? 'map must be at least %d entries'.format([rules.min_pairs]) : ''" }] } } },
            { no: 2, name: "max_pairs", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, options: { "buf.validate.predefined": { cel: [{ id: "map.max_pairs", expression: "uint(this.size()) > rules.max_pairs ? 'map must be at most %d entries'.format([rules.max_pairs]) : ''" }] } } },
            { no: 4, name: "keys", kind: "message", T: () => FieldConstraints },
            { no: 5, name: "values", kind: "message", T: () => FieldConstraints }
        ]);
    }
    create(value?: PartialMessage<MapRules>): MapRules {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MapRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapRules): MapRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 min_pairs */ 1:
                    message.minPairs = reader.uint64().toString();
                    break;
                case /* optional uint64 max_pairs */ 2:
                    message.maxPairs = reader.uint64().toString();
                    break;
                case /* optional buf.validate.FieldConstraints keys */ 4:
                    message.keys = FieldConstraints.internalBinaryRead(reader, reader.uint32(), options, message.keys);
                    break;
                case /* optional buf.validate.FieldConstraints values */ 5:
                    message.values = FieldConstraints.internalBinaryRead(reader, reader.uint32(), options, message.values);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 min_pairs = 1; */
        if (message.minPairs !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.minPairs);
        /* optional uint64 max_pairs = 2; */
        if (message.maxPairs !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.maxPairs);
        /* optional buf.validate.FieldConstraints keys = 4; */
        if (message.keys)
            FieldConstraints.internalBinaryWrite(message.keys, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional buf.validate.FieldConstraints values = 5; */
        if (message.values)
            FieldConstraints.internalBinaryWrite(message.values, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.MapRules
 */
export const MapRules = new MapRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnyRules$Type extends MessageType<AnyRules> {
    constructor() {
        super("buf.validate.AnyRules", [
            { no: 2, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "not_in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AnyRules>): AnyRules {
        const message = { in: [], notIn: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnyRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnyRules): AnyRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string in */ 2:
                    message.in.push(reader.string());
                    break;
                case /* repeated string not_in */ 3:
                    message.notIn.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnyRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string in = 2; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.in[i]);
        /* repeated string not_in = 3; */
        for (let i = 0; i < message.notIn.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.notIn[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.AnyRules
 */
export const AnyRules = new AnyRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DurationRules$Type extends MessageType<DurationRules> {
    constructor() {
        super("buf.validate.DurationRules", [
            { no: 2, name: "const", kind: "message", T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "duration.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 3, name: "lt", kind: "message", oneof: "lessThan", T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "duration.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 4, name: "lte", kind: "message", oneof: "lessThan", T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "duration.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 5, name: "gt", kind: "message", oneof: "greaterThan", T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "duration.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "duration.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "duration.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "duration.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "duration.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 6, name: "gte", kind: "message", oneof: "greaterThan", T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "duration.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "duration.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "duration.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "duration.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "duration.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 7, name: "in", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "duration.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 8, name: "not_in", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "duration.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 9, name: "example", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "duration.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<DurationRules>): DurationRules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, in: [], notIn: [], example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DurationRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DurationRules): DurationRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Duration const */ 2:
                    message.const = Duration.internalBinaryRead(reader, reader.uint32(), options, message.const);
                    break;
                case /* google.protobuf.Duration lt */ 3:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: Duration.internalBinaryRead(reader, reader.uint32(), options, (message.lessThan as any).lt)
                    };
                    break;
                case /* google.protobuf.Duration lte */ 4:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: Duration.internalBinaryRead(reader, reader.uint32(), options, (message.lessThan as any).lte)
                    };
                    break;
                case /* google.protobuf.Duration gt */ 5:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: Duration.internalBinaryRead(reader, reader.uint32(), options, (message.greaterThan as any).gt)
                    };
                    break;
                case /* google.protobuf.Duration gte */ 6:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: Duration.internalBinaryRead(reader, reader.uint32(), options, (message.greaterThan as any).gte)
                    };
                    break;
                case /* repeated google.protobuf.Duration in */ 7:
                    message.in.push(Duration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.Duration not_in */ 8:
                    message.notIn.push(Duration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.Duration example */ 9:
                    message.example.push(Duration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DurationRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Duration const = 2; */
        if (message.const)
            Duration.internalBinaryWrite(message.const, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration lt = 3; */
        if (message.lessThan.oneofKind === "lt")
            Duration.internalBinaryWrite(message.lessThan.lt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration lte = 4; */
        if (message.lessThan.oneofKind === "lte")
            Duration.internalBinaryWrite(message.lessThan.lte, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration gt = 5; */
        if (message.greaterThan.oneofKind === "gt")
            Duration.internalBinaryWrite(message.greaterThan.gt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration gte = 6; */
        if (message.greaterThan.oneofKind === "gte")
            Duration.internalBinaryWrite(message.greaterThan.gte, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Duration in = 7; */
        for (let i = 0; i < message.in.length; i++)
            Duration.internalBinaryWrite(message.in[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Duration not_in = 8; */
        for (let i = 0; i < message.notIn.length; i++)
            Duration.internalBinaryWrite(message.notIn[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Duration example = 9; */
        for (let i = 0; i < message.example.length; i++)
            Duration.internalBinaryWrite(message.example[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.DurationRules
 */
export const DurationRules = new DurationRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimestampRules$Type extends MessageType<TimestampRules> {
    constructor() {
        super("buf.validate.TimestampRules", [
            { no: 2, name: "const", kind: "message", T: () => Timestamp, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 3, name: "lt", kind: "message", oneof: "lessThan", T: () => Timestamp, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 4, name: "lte", kind: "message", oneof: "lessThan", T: () => Timestamp, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 7, name: "lt_now", kind: "scalar", oneof: "lessThan", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.lt_now", expression: "(rules.lt_now && this > now) ? 'value must be less than now' : ''" }] } } },
            { no: 5, name: "gt", kind: "message", oneof: "greaterThan", T: () => Timestamp, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "timestamp.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "timestamp.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "timestamp.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "timestamp.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 6, name: "gte", kind: "message", oneof: "greaterThan", T: () => Timestamp, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "timestamp.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "timestamp.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "timestamp.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "timestamp.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 8, name: "gt_now", kind: "scalar", oneof: "greaterThan", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.gt_now", expression: "(rules.gt_now && this < now) ? 'value must be greater than now' : ''" }] } } },
            { no: 9, name: "within", kind: "message", T: () => Duration, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.within", expression: "this < now-rules.within || this > now+rules.within ? 'value must be within %s of now'.format([rules.within]) : ''" }] } } },
            { no: 10, name: "example", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Timestamp, options: { "buf.validate.predefined": { cel: [{ id: "timestamp.example", expression: "true" }] } } }
        ]);
    }
    create(value?: PartialMessage<TimestampRules>): TimestampRules {
        const message = { lessThan: { oneofKind: undefined }, greaterThan: { oneofKind: undefined }, example: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimestampRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimestampRules): TimestampRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp const */ 2:
                    message.const = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.const);
                    break;
                case /* google.protobuf.Timestamp lt */ 3:
                    message.lessThan = {
                        oneofKind: "lt",
                        lt: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.lessThan as any).lt)
                    };
                    break;
                case /* google.protobuf.Timestamp lte */ 4:
                    message.lessThan = {
                        oneofKind: "lte",
                        lte: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.lessThan as any).lte)
                    };
                    break;
                case /* bool lt_now */ 7:
                    message.lessThan = {
                        oneofKind: "ltNow",
                        ltNow: reader.bool()
                    };
                    break;
                case /* google.protobuf.Timestamp gt */ 5:
                    message.greaterThan = {
                        oneofKind: "gt",
                        gt: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.greaterThan as any).gt)
                    };
                    break;
                case /* google.protobuf.Timestamp gte */ 6:
                    message.greaterThan = {
                        oneofKind: "gte",
                        gte: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.greaterThan as any).gte)
                    };
                    break;
                case /* bool gt_now */ 8:
                    message.greaterThan = {
                        oneofKind: "gtNow",
                        gtNow: reader.bool()
                    };
                    break;
                case /* optional google.protobuf.Duration within */ 9:
                    message.within = Duration.internalBinaryRead(reader, reader.uint32(), options, message.within);
                    break;
                case /* repeated google.protobuf.Timestamp example */ 10:
                    message.example.push(Timestamp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimestampRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp const = 2; */
        if (message.const)
            Timestamp.internalBinaryWrite(message.const, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp lt = 3; */
        if (message.lessThan.oneofKind === "lt")
            Timestamp.internalBinaryWrite(message.lessThan.lt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp lte = 4; */
        if (message.lessThan.oneofKind === "lte")
            Timestamp.internalBinaryWrite(message.lessThan.lte, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool lt_now = 7; */
        if (message.lessThan.oneofKind === "ltNow")
            writer.tag(7, WireType.Varint).bool(message.lessThan.ltNow);
        /* google.protobuf.Timestamp gt = 5; */
        if (message.greaterThan.oneofKind === "gt")
            Timestamp.internalBinaryWrite(message.greaterThan.gt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp gte = 6; */
        if (message.greaterThan.oneofKind === "gte")
            Timestamp.internalBinaryWrite(message.greaterThan.gte, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool gt_now = 8; */
        if (message.greaterThan.oneofKind === "gtNow")
            writer.tag(8, WireType.Varint).bool(message.greaterThan.gtNow);
        /* optional google.protobuf.Duration within = 9; */
        if (message.within)
            Duration.internalBinaryWrite(message.within, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Timestamp example = 10; */
        for (let i = 0; i < message.example.length; i++)
            Timestamp.internalBinaryWrite(message.example[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.TimestampRules
 */
export const TimestampRules = new TimestampRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Violations$Type extends MessageType<Violations> {
    constructor() {
        super("buf.validate.Violations", [
            { no: 1, name: "violations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Violation }
        ]);
    }
    create(value?: PartialMessage<Violations>): Violations {
        const message = { violations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Violations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Violations): Violations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated buf.validate.Violation violations */ 1:
                    message.violations.push(Violation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Violations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated buf.validate.Violation violations = 1; */
        for (let i = 0; i < message.violations.length; i++)
            Violation.internalBinaryWrite(message.violations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Violations
 */
export const Violations = new Violations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Violation$Type extends MessageType<Violation> {
    constructor() {
        super("buf.validate.Violation", [
            { no: 5, name: "field", kind: "message", T: () => FieldPath },
            { no: 6, name: "rule", kind: "message", T: () => FieldPath },
            { no: 2, name: "constraint_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "for_key", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Violation>): Violation {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Violation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Violation): Violation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional buf.validate.FieldPath field */ 5:
                    message.field = FieldPath.internalBinaryRead(reader, reader.uint32(), options, message.field);
                    break;
                case /* optional buf.validate.FieldPath rule */ 6:
                    message.rule = FieldPath.internalBinaryRead(reader, reader.uint32(), options, message.rule);
                    break;
                case /* optional string constraint_id */ 2:
                    message.constraintId = reader.string();
                    break;
                case /* optional string message */ 3:
                    message.message = reader.string();
                    break;
                case /* optional bool for_key */ 4:
                    message.forKey = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Violation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional buf.validate.FieldPath field = 5; */
        if (message.field)
            FieldPath.internalBinaryWrite(message.field, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional buf.validate.FieldPath rule = 6; */
        if (message.rule)
            FieldPath.internalBinaryWrite(message.rule, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional string constraint_id = 2; */
        if (message.constraintId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.constraintId);
        /* optional string message = 3; */
        if (message.message !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* optional bool for_key = 4; */
        if (message.forKey !== undefined)
            writer.tag(4, WireType.Varint).bool(message.forKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Violation
 */
export const Violation = new Violation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldPath$Type extends MessageType<FieldPath> {
    constructor() {
        super("buf.validate.FieldPath", [
            { no: 1, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FieldPathElement }
        ]);
    }
    create(value?: PartialMessage<FieldPath>): FieldPath {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FieldPath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FieldPath): FieldPath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated buf.validate.FieldPathElement elements */ 1:
                    message.elements.push(FieldPathElement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FieldPath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated buf.validate.FieldPathElement elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            FieldPathElement.internalBinaryWrite(message.elements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.FieldPath
 */
export const FieldPath = new FieldPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldPathElement$Type extends MessageType<FieldPathElement> {
    constructor() {
        super("buf.validate.FieldPathElement", [
            { no: 1, name: "field_number", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "field_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "field_type", kind: "enum", opt: true, T: () => ["google.protobuf.FieldDescriptorProto.Type", FieldDescriptorProto_Type, "TYPE_"] },
            { no: 4, name: "key_type", kind: "enum", opt: true, T: () => ["google.protobuf.FieldDescriptorProto.Type", FieldDescriptorProto_Type, "TYPE_"] },
            { no: 5, name: "value_type", kind: "enum", opt: true, T: () => ["google.protobuf.FieldDescriptorProto.Type", FieldDescriptorProto_Type, "TYPE_"] },
            { no: 6, name: "index", kind: "scalar", oneof: "subscript", T: 4 /*ScalarType.UINT64*/ },
            { no: 7, name: "bool_key", kind: "scalar", oneof: "subscript", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "int_key", kind: "scalar", oneof: "subscript", T: 3 /*ScalarType.INT64*/ },
            { no: 9, name: "uint_key", kind: "scalar", oneof: "subscript", T: 4 /*ScalarType.UINT64*/ },
            { no: 10, name: "string_key", kind: "scalar", oneof: "subscript", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FieldPathElement>): FieldPathElement {
        const message = { subscript: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FieldPathElement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FieldPathElement): FieldPathElement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 field_number */ 1:
                    message.fieldNumber = reader.int32();
                    break;
                case /* optional string field_name */ 2:
                    message.fieldName = reader.string();
                    break;
                case /* optional google.protobuf.FieldDescriptorProto.Type field_type */ 3:
                    message.fieldType = reader.int32();
                    break;
                case /* optional google.protobuf.FieldDescriptorProto.Type key_type */ 4:
                    message.keyType = reader.int32();
                    break;
                case /* optional google.protobuf.FieldDescriptorProto.Type value_type */ 5:
                    message.valueType = reader.int32();
                    break;
                case /* uint64 index */ 6:
                    message.subscript = {
                        oneofKind: "index",
                        index: reader.uint64().toString()
                    };
                    break;
                case /* bool bool_key */ 7:
                    message.subscript = {
                        oneofKind: "boolKey",
                        boolKey: reader.bool()
                    };
                    break;
                case /* int64 int_key */ 8:
                    message.subscript = {
                        oneofKind: "intKey",
                        intKey: reader.int64().toString()
                    };
                    break;
                case /* uint64 uint_key */ 9:
                    message.subscript = {
                        oneofKind: "uintKey",
                        uintKey: reader.uint64().toString()
                    };
                    break;
                case /* string string_key */ 10:
                    message.subscript = {
                        oneofKind: "stringKey",
                        stringKey: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FieldPathElement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 field_number = 1; */
        if (message.fieldNumber !== undefined)
            writer.tag(1, WireType.Varint).int32(message.fieldNumber);
        /* optional string field_name = 2; */
        if (message.fieldName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fieldName);
        /* optional google.protobuf.FieldDescriptorProto.Type field_type = 3; */
        if (message.fieldType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.fieldType);
        /* optional google.protobuf.FieldDescriptorProto.Type key_type = 4; */
        if (message.keyType !== undefined)
            writer.tag(4, WireType.Varint).int32(message.keyType);
        /* optional google.protobuf.FieldDescriptorProto.Type value_type = 5; */
        if (message.valueType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.valueType);
        /* uint64 index = 6; */
        if (message.subscript.oneofKind === "index")
            writer.tag(6, WireType.Varint).uint64(message.subscript.index);
        /* bool bool_key = 7; */
        if (message.subscript.oneofKind === "boolKey")
            writer.tag(7, WireType.Varint).bool(message.subscript.boolKey);
        /* int64 int_key = 8; */
        if (message.subscript.oneofKind === "intKey")
            writer.tag(8, WireType.Varint).int64(message.subscript.intKey);
        /* uint64 uint_key = 9; */
        if (message.subscript.oneofKind === "uintKey")
            writer.tag(9, WireType.Varint).uint64(message.subscript.uintKey);
        /* string string_key = 10; */
        if (message.subscript.oneofKind === "stringKey")
            writer.tag(10, WireType.LengthDelimited).string(message.subscript.stringKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.FieldPathElement
 */
export const FieldPathElement = new FieldPathElement$Type();
