// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "protoc-gen-openapiv2/options/openapiv2.proto" (package "grpc.gateway.protoc_gen_openapiv2.options", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Value } from "../../google/protobuf/struct";
/**
 * `Swagger` is a representation of OpenAPI v2 specification's Swagger object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#swaggerObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      title: "Echo API";
 *      version: "1.0";
 *      description: "";
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *    };
 *    schemes: HTTPS;
 *    consumes: "application/json";
 *    produces: "application/json";
 *  };
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Swagger
 */
export interface Swagger {
    /**
     * Specifies the OpenAPI Specification version being used. It can be
     * used by the OpenAPI UI and other clients to interpret the API listing. The
     * value MUST be "2.0".
     *
     * @generated from protobuf field: string swagger = 1;
     */
    swagger: string;
    /**
     * Provides metadata about the API. The metadata can be used by the
     * clients if needed.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.Info info = 2;
     */
    info?: Info;
    /**
     * The host (name or ip) serving the API. This MUST be the host only and does
     * not include the scheme nor sub-paths. It MAY include a port. If the host is
     * not included, the host serving the documentation is to be used (including
     * the port). The host does not support path templating.
     *
     * @generated from protobuf field: string host = 3;
     */
    host: string;
    /**
     * The base path on which the API is served, which is relative to the host. If
     * it is not included, the API is served directly under the host. The value
     * MUST start with a leading slash (/). The basePath does not support path
     * templating.
     * Note that using `base_path` does not change the endpoint paths that are
     * generated in the resulting OpenAPI file. If you wish to use `base_path`
     * with relatively generated OpenAPI paths, the `base_path` prefix must be
     * manually removed from your `google.api.http` paths and your code changed to
     * serve the API from the `base_path`.
     *
     * @generated from protobuf field: string base_path = 4;
     */
    basePath: string;
    /**
     * The transfer protocol of the API. Values MUST be from the list: "http",
     * "https", "ws", "wss". If the schemes is not included, the default scheme to
     * be used is the one used to access the OpenAPI definition itself.
     *
     * @generated from protobuf field: repeated grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes = 5;
     */
    schemes: Scheme[];
    /**
     * A list of MIME types the APIs can consume. This is global to all APIs but
     * can be overridden on specific API calls. Value MUST be as described under
     * Mime Types.
     *
     * @generated from protobuf field: repeated string consumes = 6;
     */
    consumes: string[];
    /**
     * A list of MIME types the APIs can produce. This is global to all APIs but
     * can be overridden on specific API calls. Value MUST be as described under
     * Mime Types.
     *
     * @generated from protobuf field: repeated string produces = 7;
     */
    produces: string[];
    /**
     * An object to hold responses that can be used across operations. This
     * property does not define global responses for all operations.
     *
     * @generated from protobuf field: map<string, grpc.gateway.protoc_gen_openapiv2.options.Response> responses = 10;
     */
    responses: {
        [key: string]: Response;
    };
    /**
     * Security scheme definitions that can be used across the specification.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions security_definitions = 11;
     */
    securityDefinitions?: SecurityDefinitions;
    /**
     * A declaration of which security schemes are applied for the API as a whole.
     * The list of values describes alternative security schemes that can be used
     * (that is, there is a logical OR between the security requirements).
     * Individual operations can override this definition.
     *
     * @generated from protobuf field: repeated grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security = 12;
     */
    security: SecurityRequirement[];
    /**
     * Additional external documentation.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 14;
     */
    externalDocs?: ExternalDocumentation;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> extensions = 15;
     */
    extensions: {
        [key: string]: Value;
    };
}
/**
 * `Operation` is a representation of OpenAPI v2 specification's Operation object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#operationObject
 *
 * Example:
 *
 *  service EchoService {
 *    rpc Echo(SimpleMessage) returns (SimpleMessage) {
 *      option (google.api.http) = {
 *        get: "/v1/example/echo/{id}"
 *      };
 *
 *      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
 *        summary: "Get a message.";
 *        operation_id: "getMessage";
 *        tags: "echo";
 *        responses: {
 *          key: "200"
 *            value: {
 *            description: "OK";
 *          }
 *        }
 *      };
 *    }
 *  }
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Operation
 */
export interface Operation {
    /**
     * A list of tags for API documentation control. Tags can be used for logical
     * grouping of operations by resources or any other qualifier.
     *
     * @generated from protobuf field: repeated string tags = 1;
     */
    tags: string[];
    /**
     * A short summary of what the operation does. For maximum readability in the
     * swagger-ui, this field SHOULD be less than 120 characters.
     *
     * @generated from protobuf field: string summary = 2;
     */
    summary: string;
    /**
     * A verbose explanation of the operation behavior. GFM syntax can be used for
     * rich text representation.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * Additional external documentation for this operation.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 4;
     */
    externalDocs?: ExternalDocumentation;
    /**
     * Unique string used to identify the operation. The id MUST be unique among
     * all operations described in the API. Tools and libraries MAY use the
     * operationId to uniquely identify an operation, therefore, it is recommended
     * to follow common programming naming conventions.
     *
     * @generated from protobuf field: string operation_id = 5;
     */
    operationId: string;
    /**
     * A list of MIME types the operation can consume. This overrides the consumes
     * definition at the OpenAPI Object. An empty value MAY be used to clear the
     * global definition. Value MUST be as described under Mime Types.
     *
     * @generated from protobuf field: repeated string consumes = 6;
     */
    consumes: string[];
    /**
     * A list of MIME types the operation can produce. This overrides the produces
     * definition at the OpenAPI Object. An empty value MAY be used to clear the
     * global definition. Value MUST be as described under Mime Types.
     *
     * @generated from protobuf field: repeated string produces = 7;
     */
    produces: string[];
    /**
     * The list of possible responses as they are returned from executing this
     * operation.
     *
     * @generated from protobuf field: map<string, grpc.gateway.protoc_gen_openapiv2.options.Response> responses = 9;
     */
    responses: {
        [key: string]: Response;
    };
    /**
     * The transfer protocol for the operation. Values MUST be from the list:
     * "http", "https", "ws", "wss". The value overrides the OpenAPI Object
     * schemes definition.
     *
     * @generated from protobuf field: repeated grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes = 10;
     */
    schemes: Scheme[];
    /**
     * Declares this operation to be deprecated. Usage of the declared operation
     * should be refrained. Default value is false.
     *
     * @generated from protobuf field: bool deprecated = 11;
     */
    deprecated: boolean;
    /**
     * A declaration of which security schemes are applied for this operation. The
     * list of values describes alternative security schemes that can be used
     * (that is, there is a logical OR between the security requirements). This
     * definition overrides any declared top-level security. To remove a top-level
     * security declaration, an empty array can be used.
     *
     * @generated from protobuf field: repeated grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security = 12;
     */
    security: SecurityRequirement[];
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> extensions = 13;
     */
    extensions: {
        [key: string]: Value;
    };
}
/**
 * `Header` is a representation of OpenAPI v2 specification's Header object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#headerObject
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Header
 */
export interface Header {
    /**
     * `Description` is a short description of the header.
     *
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
     *
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * `Format` The extending format for the previously mentioned type.
     *
     * @generated from protobuf field: string format = 3;
     */
    format: string;
    /**
     * `Default` Declares the value of the header that the server will use if none is provided.
     * See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
     * Unlike JSON Schema this value MUST conform to the defined type for the header.
     *
     * @generated from protobuf field: string default = 6;
     */
    default: string;
    /**
     * 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
     *
     * @generated from protobuf field: string pattern = 13;
     */
    pattern: string;
}
/**
 * `Response` is a representation of OpenAPI v2 specification's Response object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#responseObject
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Response
 */
export interface Response {
    /**
     * `Description` is a short description of the response.
     * GFM syntax can be used for rich text representation.
     *
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * `Schema` optionally defines the structure of the response.
     * If `Schema` is not provided, it means there is no content to the response.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.Schema schema = 2;
     */
    schema?: Schema;
    /**
     * `Headers` A list of headers that are sent with the response.
     * `Header` name is expected to be a string in the canonical format of the MIME header key
     * See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
     *
     * @generated from protobuf field: map<string, grpc.gateway.protoc_gen_openapiv2.options.Header> headers = 3;
     */
    headers: {
        [key: string]: Header;
    };
    /**
     * `Examples` gives per-mimetype response examples.
     * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
     *
     * @generated from protobuf field: map<string, string> examples = 4;
     */
    examples: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> extensions = 5;
     */
    extensions: {
        [key: string]: Value;
    };
}
/**
 * `Info` is a representation of OpenAPI v2 specification's Info object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#infoObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      title: "Echo API";
 *      version: "1.0";
 *      description: "";
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *    };
 *    ...
 *  };
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Info
 */
export interface Info {
    /**
     * The title of the application.
     *
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * A short description of the application. GFM syntax can be used for rich
     * text representation.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * The Terms of Service for the API.
     *
     * @generated from protobuf field: string terms_of_service = 3;
     */
    termsOfService: string;
    /**
     * The contact information for the exposed API.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.Contact contact = 4;
     */
    contact?: Contact;
    /**
     * The license information for the exposed API.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.License license = 5;
     */
    license?: License;
    /**
     * Provides the version of the application API (not to be confused
     * with the specification version).
     *
     * @generated from protobuf field: string version = 6;
     */
    version: string;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> extensions = 7;
     */
    extensions: {
        [key: string]: Value;
    };
}
/**
 * `Contact` is a representation of OpenAPI v2 specification's Contact object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#contactObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      ...
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      ...
 *    };
 *    ...
 *  };
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Contact
 */
export interface Contact {
    /**
     * The identifying name of the contact person/organization.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The URL pointing to the contact information. MUST be in the format of a
     * URL.
     *
     * @generated from protobuf field: string url = 2;
     */
    url: string;
    /**
     * The email address of the contact person/organization. MUST be in the format
     * of an email address.
     *
     * @generated from protobuf field: string email = 3;
     */
    email: string;
}
/**
 * `License` is a representation of OpenAPI v2 specification's License object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#licenseObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      ...
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *      ...
 *    };
 *    ...
 *  };
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.License
 */
export interface License {
    /**
     * The license name used for the API.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * A URL to the license used for the API. MUST be in the format of a URL.
     *
     * @generated from protobuf field: string url = 2;
     */
    url: string;
}
/**
 * `ExternalDocumentation` is a representation of OpenAPI v2 specification's
 * ExternalDocumentation object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#externalDocumentationObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    ...
 *    external_docs: {
 *      description: "More about gRPC-Gateway";
 *      url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *    }
 *    ...
 *  };
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
 */
export interface ExternalDocumentation {
    /**
     * A short description of the target documentation. GFM syntax can be used for
     * rich text representation.
     *
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * The URL for the target documentation. Value MUST be in the format
     * of a URL.
     *
     * @generated from protobuf field: string url = 2;
     */
    url: string;
}
/**
 * `Schema` is a representation of OpenAPI v2 specification's Schema object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Schema
 */
export interface Schema {
    /**
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema json_schema = 1;
     */
    jsonSchema?: JSONSchema;
    /**
     * Adds support for polymorphism. The discriminator is the schema property
     * name that is used to differentiate between other schema that inherit this
     * schema. The property name used MUST be defined at this schema and it MUST
     * be in the required property list. When used, the value MUST be the name of
     * this schema or any schema that inherits it.
     *
     * @generated from protobuf field: string discriminator = 2;
     */
    discriminator: string;
    /**
     * Relevant only for Schema "properties" definitions. Declares the property as
     * "read only". This means that it MAY be sent as part of a response but MUST
     * NOT be sent as part of the request. Properties marked as readOnly being
     * true SHOULD NOT be in the required list of the defined schema. Default
     * value is false.
     *
     * @generated from protobuf field: bool read_only = 3;
     */
    readOnly: boolean;
    /**
     * Additional external documentation for this schema.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 5;
     */
    externalDocs?: ExternalDocumentation;
    /**
     * A free-form property to include an example of an instance for this schema in JSON.
     * This is copied verbatim to the output.
     *
     * @generated from protobuf field: string example = 6;
     */
    example: string;
}
/**
 * `JSONSchema` represents properties from JSON Schema taken, and as used, in
 * the OpenAPI v2 spec.
 *
 * This includes changes made by OpenAPI v2.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
 *
 * See also: https://cswr.github.io/JsonSchema/spec/basic_types/,
 * https://github.com/json-schema-org/json-schema-spec/blob/master/schema.json
 *
 * Example:
 *
 *  message SimpleMessage {
 *    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *      json_schema: {
 *        title: "SimpleMessage"
 *        description: "A simple message."
 *        required: ["id"]
 *      }
 *    };
 *
 *    // Id represents the message identifier.
 *    string id = 1; [
 *        (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
 *          description: "The unique identifier of the simple message."
 *        }];
 *  }
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
 */
export interface JSONSchema {
    /**
     * Ref is used to define an external reference to include in the message.
     * This could be a fully qualified proto message reference, and that type must
     * be imported into the protofile. If no message is identified, the Ref will
     * be used verbatim in the output.
     * For example:
     *  `ref: ".google.protobuf.Timestamp"`.
     *
     * @generated from protobuf field: string ref = 3;
     */
    ref: string;
    /**
     * The title of the schema.
     *
     * @generated from protobuf field: string title = 5;
     */
    title: string;
    /**
     * A short description of the schema.
     *
     * @generated from protobuf field: string description = 6;
     */
    description: string;
    /**
     * @generated from protobuf field: string default = 7;
     */
    default: string;
    /**
     * @generated from protobuf field: bool read_only = 8;
     */
    readOnly: boolean;
    /**
     * A free-form property to include a JSON example of this field. This is copied
     * verbatim to the output swagger.json. Quotes must be escaped.
     * This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
     *
     * @generated from protobuf field: string example = 9;
     */
    example: string;
    /**
     * @generated from protobuf field: double multiple_of = 10;
     */
    multipleOf: number;
    /**
     * Maximum represents an inclusive upper limit for a numeric instance. The
     * value of MUST be a number,
     *
     * @generated from protobuf field: double maximum = 11;
     */
    maximum: number;
    /**
     * @generated from protobuf field: bool exclusive_maximum = 12;
     */
    exclusiveMaximum: boolean;
    /**
     * minimum represents an inclusive lower limit for a numeric instance. The
     * value of MUST be a number,
     *
     * @generated from protobuf field: double minimum = 13;
     */
    minimum: number;
    /**
     * @generated from protobuf field: bool exclusive_minimum = 14;
     */
    exclusiveMinimum: boolean;
    /**
     * @generated from protobuf field: uint64 max_length = 15;
     */
    maxLength: string;
    /**
     * @generated from protobuf field: uint64 min_length = 16;
     */
    minLength: string;
    /**
     * @generated from protobuf field: string pattern = 17;
     */
    pattern: string;
    /**
     * @generated from protobuf field: uint64 max_items = 20;
     */
    maxItems: string;
    /**
     * @generated from protobuf field: uint64 min_items = 21;
     */
    minItems: string;
    /**
     * @generated from protobuf field: bool unique_items = 22;
     */
    uniqueItems: boolean;
    /**
     * @generated from protobuf field: uint64 max_properties = 24;
     */
    maxProperties: string;
    /**
     * @generated from protobuf field: uint64 min_properties = 25;
     */
    minProperties: string;
    /**
     * @generated from protobuf field: repeated string required = 26;
     */
    required: string[];
    /**
     * Items in 'array' must be unique.
     *
     * @generated from protobuf field: repeated string array = 34;
     */
    array: string[];
    /**
     * @generated from protobuf field: repeated grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes type = 35;
     */
    type: JSONSchema_JSONSchemaSimpleTypes[];
    /**
     * `Format`
     *
     * @generated from protobuf field: string format = 36;
     */
    format: string;
    /**
     * Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
     *
     * @generated from protobuf field: repeated string enum = 46;
     */
    enum: string[];
    /**
     * Additional field level properties used when generating the OpenAPI v2 file.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration field_configuration = 1001;
     */
    fieldConfiguration?: JSONSchema_FieldConfiguration;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> extensions = 48;
     */
    extensions: {
        [key: string]: Value;
    };
}
/**
 * 'FieldConfiguration' provides additional field level properties used when generating the OpenAPI v2 file.
 * These properties are not defined by OpenAPIv2, but they are used to control the generation.
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration
 */
export interface JSONSchema_FieldConfiguration {
    /**
     * Alternative parameter name when used as path parameter. If set, this will
     * be used as the complete parameter name when this field is used as a path
     * parameter. Use this to avoid having auto generated path parameter names
     * for overlapping paths.
     *
     * @generated from protobuf field: string path_param_name = 47;
     */
    pathParamName: string;
}
/**
 * @generated from protobuf enum grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes
 */
export enum JSONSchema_JSONSchemaSimpleTypes {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: ARRAY = 1;
     */
    ARRAY = 1,
    /**
     * @generated from protobuf enum value: BOOLEAN = 2;
     */
    BOOLEAN = 2,
    /**
     * @generated from protobuf enum value: INTEGER = 3;
     */
    INTEGER = 3,
    /**
     * @generated from protobuf enum value: NULL = 4;
     */
    NULL = 4,
    /**
     * @generated from protobuf enum value: NUMBER = 5;
     */
    NUMBER = 5,
    /**
     * @generated from protobuf enum value: OBJECT = 6;
     */
    OBJECT = 6,
    /**
     * @generated from protobuf enum value: STRING = 7;
     */
    STRING = 7
}
/**
 * `Tag` is a representation of OpenAPI v2 specification's Tag object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#tagObject
 *
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Tag
 */
export interface Tag {
    /**
     * A short description for the tag. GFM syntax can be used for rich text
     * representation.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * Additional external documentation for this tag.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 3;
     */
    externalDocs?: ExternalDocumentation;
}
/**
 * `SecurityDefinitions` is a representation of OpenAPI v2 specification's
 * Security Definitions object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
 *
 * A declaration of the security schemes available to be used in the
 * specification. This does not enforce the security schemes on the operations
 * and only serves to provide the relevant details for each scheme.
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions
 */
export interface SecurityDefinitions {
    /**
     * A single security scheme definition, mapping a "name" to the scheme it
     * defines.
     *
     * @generated from protobuf field: map<string, grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme> security = 1;
     */
    security: {
        [key: string]: SecurityScheme;
    };
}
/**
 * `SecurityScheme` is a representation of OpenAPI v2 specification's
 * Security Scheme object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securitySchemeObject
 *
 * Allows the definition of a security scheme that can be used by the
 * operations. Supported schemes are basic authentication, an API key (either as
 * a header or as a query parameter) and OAuth2's common flows (implicit,
 * password, application and access code).
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme
 */
export interface SecurityScheme {
    /**
     * The type of the security scheme. Valid values are "basic",
     * "apiKey" or "oauth2".
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type type = 1;
     */
    type: SecurityScheme_Type;
    /**
     * A short description for security scheme.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * The name of the header or query parameter to be used.
     * Valid for apiKey.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * The location of the API key. Valid values are "query" or
     * "header".
     * Valid for apiKey.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In in = 4;
     */
    in: SecurityScheme_In;
    /**
     * The flow used by the OAuth2 security scheme. Valid values are
     * "implicit", "password", "application" or "accessCode".
     * Valid for oauth2.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow flow = 5;
     */
    flow: SecurityScheme_Flow;
    /**
     * The authorization URL to be used for this flow. This SHOULD be in
     * the form of a URL.
     * Valid for oauth2/implicit and oauth2/accessCode.
     *
     * @generated from protobuf field: string authorization_url = 6;
     */
    authorizationUrl: string;
    /**
     * The token URL to be used for this flow. This SHOULD be in the
     * form of a URL.
     * Valid for oauth2/password, oauth2/application and oauth2/accessCode.
     *
     * @generated from protobuf field: string token_url = 7;
     */
    tokenUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme.
     * Valid for oauth2.
     *
     * @generated from protobuf field: grpc.gateway.protoc_gen_openapiv2.options.Scopes scopes = 8;
     */
    scopes?: Scopes;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> extensions = 9;
     */
    extensions: {
        [key: string]: Value;
    };
}
/**
 * The type of the security scheme. Valid values are "basic",
 * "apiKey" or "oauth2".
 *
 * @generated from protobuf enum grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type
 */
export enum SecurityScheme_Type {
    /**
     * @generated from protobuf enum value: TYPE_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: TYPE_BASIC = 1;
     */
    BASIC = 1,
    /**
     * @generated from protobuf enum value: TYPE_API_KEY = 2;
     */
    API_KEY = 2,
    /**
     * @generated from protobuf enum value: TYPE_OAUTH2 = 3;
     */
    OAUTH2 = 3
}
/**
 * The location of the API key. Valid values are "query" or "header".
 *
 * @generated from protobuf enum grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In
 */
export enum SecurityScheme_In {
    /**
     * @generated from protobuf enum value: IN_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: IN_QUERY = 1;
     */
    QUERY = 1,
    /**
     * @generated from protobuf enum value: IN_HEADER = 2;
     */
    HEADER = 2
}
/**
 * The flow used by the OAuth2 security scheme. Valid values are
 * "implicit", "password", "application" or "accessCode".
 *
 * @generated from protobuf enum grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow
 */
export enum SecurityScheme_Flow {
    /**
     * @generated from protobuf enum value: FLOW_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: FLOW_IMPLICIT = 1;
     */
    IMPLICIT = 1,
    /**
     * @generated from protobuf enum value: FLOW_PASSWORD = 2;
     */
    PASSWORD = 2,
    /**
     * @generated from protobuf enum value: FLOW_APPLICATION = 3;
     */
    APPLICATION = 3,
    /**
     * @generated from protobuf enum value: FLOW_ACCESS_CODE = 4;
     */
    ACCESS_CODE = 4
}
/**
 * `SecurityRequirement` is a representation of OpenAPI v2 specification's
 * Security Requirement object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityRequirementObject
 *
 * Lists the required security schemes to execute this operation. The object can
 * have multiple security schemes declared in it which are all required (that
 * is, there is a logical AND between the schemes).
 *
 * The name used for each property MUST correspond to a security scheme
 * declared in the Security Definitions.
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
 */
export interface SecurityRequirement {
    /**
     * Each name must correspond to a security scheme which is declared in
     * the Security Definitions. If the security scheme is of type "oauth2",
     * then the value is a list of scope names required for the execution.
     * For other security scheme types, the array MUST be empty.
     *
     * @generated from protobuf field: map<string, grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue> security_requirement = 1;
     */
    securityRequirement: {
        [key: string]: SecurityRequirement_SecurityRequirementValue;
    };
}
/**
 * If the security scheme is of type "oauth2", then the value is a list of
 * scope names required for the execution. For other security scheme types,
 * the array MUST be empty.
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue
 */
export interface SecurityRequirement_SecurityRequirementValue {
    /**
     * @generated from protobuf field: repeated string scope = 1;
     */
    scope: string[];
}
/**
 * `Scopes` is a representation of OpenAPI v2 specification's Scopes object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#scopesObject
 *
 * Lists the available scopes for an OAuth2 security scheme.
 *
 * @generated from protobuf message grpc.gateway.protoc_gen_openapiv2.options.Scopes
 */
export interface Scopes {
    /**
     * Maps between a name of a scope to a short description of it (as the value
     * of the property).
     *
     * @generated from protobuf field: map<string, string> scope = 1;
     */
    scope: {
        [key: string]: string;
    };
}
/**
 * Scheme describes the schemes supported by the OpenAPI Swagger
 * and Operation objects.
 *
 * @generated from protobuf enum grpc.gateway.protoc_gen_openapiv2.options.Scheme
 */
export enum Scheme {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: HTTP = 1;
     */
    HTTP = 1,
    /**
     * @generated from protobuf enum value: HTTPS = 2;
     */
    HTTPS = 2,
    /**
     * @generated from protobuf enum value: WS = 3;
     */
    WS = 3,
    /**
     * @generated from protobuf enum value: WSS = 4;
     */
    WSS = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class Swagger$Type extends MessageType<Swagger> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Swagger", [
            { no: 1, name: "swagger", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "info", kind: "message", T: () => Info },
            { no: 3, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "schemes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["grpc.gateway.protoc_gen_openapiv2.options.Scheme", Scheme] },
            { no: 6, name: "consumes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "produces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "responses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Response } },
            { no: 11, name: "security_definitions", kind: "message", T: () => SecurityDefinitions },
            { no: 12, name: "security", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecurityRequirement },
            { no: 14, name: "external_docs", kind: "message", T: () => ExternalDocumentation },
            { no: 15, name: "extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<Swagger>): Swagger {
        const message = { swagger: "", host: "", basePath: "", schemes: [], consumes: [], produces: [], responses: {}, security: [], extensions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Swagger>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Swagger): Swagger {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string swagger */ 1:
                    message.swagger = reader.string();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.Info info */ 2:
                    message.info = Info.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* string host */ 3:
                    message.host = reader.string();
                    break;
                case /* string base_path */ 4:
                    message.basePath = reader.string();
                    break;
                case /* repeated grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.schemes.push(reader.int32());
                    else
                        message.schemes.push(reader.int32());
                    break;
                case /* repeated string consumes */ 6:
                    message.consumes.push(reader.string());
                    break;
                case /* repeated string produces */ 7:
                    message.produces.push(reader.string());
                    break;
                case /* map<string, grpc.gateway.protoc_gen_openapiv2.options.Response> responses */ 10:
                    this.binaryReadMap10(message.responses, reader, options);
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions security_definitions */ 11:
                    message.securityDefinitions = SecurityDefinitions.internalBinaryRead(reader, reader.uint32(), options, message.securityDefinitions);
                    break;
                case /* repeated grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security */ 12:
                    message.security.push(SecurityRequirement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs */ 14:
                    message.externalDocs = ExternalDocumentation.internalBinaryRead(reader, reader.uint32(), options, message.externalDocs);
                    break;
                case /* map<string, google.protobuf.Value> extensions */ 15:
                    this.binaryReadMap15(message.extensions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: Swagger["responses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Swagger["responses"] | undefined, val: Swagger["responses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Response.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Swagger.responses");
            }
        }
        map[key ?? ""] = val ?? Response.create();
    }
    private binaryReadMap15(map: Swagger["extensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Swagger["extensions"] | undefined, val: Swagger["extensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Swagger.extensions");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: Swagger, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string swagger = 1; */
        if (message.swagger !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.swagger);
        /* grpc.gateway.protoc_gen_openapiv2.options.Info info = 2; */
        if (message.info)
            Info.internalBinaryWrite(message.info, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string host = 3; */
        if (message.host !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.host);
        /* string base_path = 4; */
        if (message.basePath !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.basePath);
        /* repeated grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes = 5; */
        if (message.schemes.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.schemes.length; i++)
                writer.int32(message.schemes[i]);
            writer.join();
        }
        /* repeated string consumes = 6; */
        for (let i = 0; i < message.consumes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.consumes[i]);
        /* repeated string produces = 7; */
        for (let i = 0; i < message.produces.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.produces[i]);
        /* map<string, grpc.gateway.protoc_gen_openapiv2.options.Response> responses = 10; */
        for (let k of Object.keys(message.responses)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Response.internalBinaryWrite(message.responses[k], writer, options);
            writer.join().join();
        }
        /* grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions security_definitions = 11; */
        if (message.securityDefinitions)
            SecurityDefinitions.internalBinaryWrite(message.securityDefinitions, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security = 12; */
        for (let i = 0; i < message.security.length; i++)
            SecurityRequirement.internalBinaryWrite(message.security[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 14; */
        if (message.externalDocs)
            ExternalDocumentation.internalBinaryWrite(message.externalDocs, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Value> extensions = 15; */
        for (let k of Object.keys(message.extensions)) {
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.extensions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Swagger
 */
export const Swagger = new Swagger$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operation$Type extends MessageType<Operation> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Operation", [
            { no: 1, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "external_docs", kind: "message", T: () => ExternalDocumentation },
            { no: 5, name: "operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "consumes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "produces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "responses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Response } },
            { no: 10, name: "schemes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["grpc.gateway.protoc_gen_openapiv2.options.Scheme", Scheme] },
            { no: 11, name: "deprecated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "security", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecurityRequirement },
            { no: 13, name: "extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<Operation>): Operation {
        const message = { tags: [], summary: "", description: "", operationId: "", consumes: [], produces: [], responses: {}, schemes: [], deprecated: false, security: [], extensions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Operation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operation): Operation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string tags */ 1:
                    message.tags.push(reader.string());
                    break;
                case /* string summary */ 2:
                    message.summary = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs */ 4:
                    message.externalDocs = ExternalDocumentation.internalBinaryRead(reader, reader.uint32(), options, message.externalDocs);
                    break;
                case /* string operation_id */ 5:
                    message.operationId = reader.string();
                    break;
                case /* repeated string consumes */ 6:
                    message.consumes.push(reader.string());
                    break;
                case /* repeated string produces */ 7:
                    message.produces.push(reader.string());
                    break;
                case /* map<string, grpc.gateway.protoc_gen_openapiv2.options.Response> responses */ 9:
                    this.binaryReadMap9(message.responses, reader, options);
                    break;
                case /* repeated grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.schemes.push(reader.int32());
                    else
                        message.schemes.push(reader.int32());
                    break;
                case /* bool deprecated */ 11:
                    message.deprecated = reader.bool();
                    break;
                case /* repeated grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security */ 12:
                    message.security.push(SecurityRequirement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, google.protobuf.Value> extensions */ 13:
                    this.binaryReadMap13(message.extensions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: Operation["responses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Operation["responses"] | undefined, val: Operation["responses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Response.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Operation.responses");
            }
        }
        map[key ?? ""] = val ?? Response.create();
    }
    private binaryReadMap13(map: Operation["extensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Operation["extensions"] | undefined, val: Operation["extensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Operation.extensions");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: Operation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string tags = 1; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tags[i]);
        /* string summary = 2; */
        if (message.summary !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.summary);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 4; */
        if (message.externalDocs)
            ExternalDocumentation.internalBinaryWrite(message.externalDocs, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string operation_id = 5; */
        if (message.operationId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.operationId);
        /* repeated string consumes = 6; */
        for (let i = 0; i < message.consumes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.consumes[i]);
        /* repeated string produces = 7; */
        for (let i = 0; i < message.produces.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.produces[i]);
        /* map<string, grpc.gateway.protoc_gen_openapiv2.options.Response> responses = 9; */
        for (let k of Object.keys(message.responses)) {
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Response.internalBinaryWrite(message.responses[k], writer, options);
            writer.join().join();
        }
        /* repeated grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes = 10; */
        if (message.schemes.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.schemes.length; i++)
                writer.int32(message.schemes[i]);
            writer.join();
        }
        /* bool deprecated = 11; */
        if (message.deprecated !== false)
            writer.tag(11, WireType.Varint).bool(message.deprecated);
        /* repeated grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security = 12; */
        for (let i = 0; i < message.security.length; i++)
            SecurityRequirement.internalBinaryWrite(message.security[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Value> extensions = 13; */
        for (let k of Object.keys(message.extensions)) {
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.extensions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Operation
 */
export const Operation = new Operation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Header$Type extends MessageType<Header> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Header", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "pattern", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Header>): Header {
        const message = { description: "", type: "", format: "", default: "", pattern: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Header): Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string format */ 3:
                    message.format = reader.string();
                    break;
                case /* string default */ 6:
                    message.default = reader.string();
                    break;
                case /* string pattern */ 13:
                    message.pattern = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string format = 3; */
        if (message.format !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.format);
        /* string default = 6; */
        if (message.default !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.default);
        /* string pattern = 13; */
        if (message.pattern !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.pattern);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Header
 */
export const Header = new Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Response", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "schema", kind: "message", T: () => Schema },
            { no: 3, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Header } },
            { no: 4, name: "examples", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 5, name: "extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = { description: "", headers: {}, examples: {}, extensions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.Schema schema */ 2:
                    message.schema = Schema.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                case /* map<string, grpc.gateway.protoc_gen_openapiv2.options.Header> headers */ 3:
                    this.binaryReadMap3(message.headers, reader, options);
                    break;
                case /* map<string, string> examples */ 4:
                    this.binaryReadMap4(message.examples, reader, options);
                    break;
                case /* map<string, google.protobuf.Value> extensions */ 5:
                    this.binaryReadMap5(message.extensions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Response["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Response["headers"] | undefined, val: Response["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Header.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Response.headers");
            }
        }
        map[key ?? ""] = val ?? Header.create();
    }
    private binaryReadMap4(map: Response["examples"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Response["examples"] | undefined, val: Response["examples"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Response.examples");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap5(map: Response["extensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Response["extensions"] | undefined, val: Response["extensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Response.extensions");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* grpc.gateway.protoc_gen_openapiv2.options.Schema schema = 2; */
        if (message.schema)
            Schema.internalBinaryWrite(message.schema, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, grpc.gateway.protoc_gen_openapiv2.options.Header> headers = 3; */
        for (let k of Object.keys(message.headers)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Header.internalBinaryWrite(message.headers[k], writer, options);
            writer.join().join();
        }
        /* map<string, string> examples = 4; */
        for (let k of Object.keys(message.examples))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.examples[k]).join();
        /* map<string, google.protobuf.Value> extensions = 5; */
        for (let k of Object.keys(message.extensions)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.extensions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info$Type extends MessageType<Info> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Info", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "terms_of_service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "contact", kind: "message", T: () => Contact },
            { no: 5, name: "license", kind: "message", T: () => License },
            { no: 6, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<Info>): Info {
        const message = { title: "", description: "", termsOfService: "", version: "", extensions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info): Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string terms_of_service */ 3:
                    message.termsOfService = reader.string();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.Contact contact */ 4:
                    message.contact = Contact.internalBinaryRead(reader, reader.uint32(), options, message.contact);
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.License license */ 5:
                    message.license = License.internalBinaryRead(reader, reader.uint32(), options, message.license);
                    break;
                case /* string version */ 6:
                    message.version = reader.string();
                    break;
                case /* map<string, google.protobuf.Value> extensions */ 7:
                    this.binaryReadMap7(message.extensions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: Info["extensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Info["extensions"] | undefined, val: Info["extensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Info.extensions");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string terms_of_service = 3; */
        if (message.termsOfService !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.termsOfService);
        /* grpc.gateway.protoc_gen_openapiv2.options.Contact contact = 4; */
        if (message.contact)
            Contact.internalBinaryWrite(message.contact, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* grpc.gateway.protoc_gen_openapiv2.options.License license = 5; */
        if (message.license)
            License.internalBinaryWrite(message.license, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string version = 6; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        /* map<string, google.protobuf.Value> extensions = 7; */
        for (let k of Object.keys(message.extensions)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.extensions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Info
 */
export const Info = new Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contact$Type extends MessageType<Contact> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Contact", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Contact>): Contact {
        const message = { name: "", url: "", email: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Contact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contact): Contact {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Contact
 */
export const Contact = new Contact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class License$Type extends MessageType<License> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.License", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<License>): License {
        const message = { name: "", url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<License>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: License): License {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: License, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.License
 */
export const License = new License$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalDocumentation$Type extends MessageType<ExternalDocumentation> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExternalDocumentation>): ExternalDocumentation {
        const message = { description: "", url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExternalDocumentation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalDocumentation): ExternalDocumentation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalDocumentation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
 */
export const ExternalDocumentation = new ExternalDocumentation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Schema$Type extends MessageType<Schema> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Schema", [
            { no: 1, name: "json_schema", kind: "message", T: () => JSONSchema },
            { no: 2, name: "discriminator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "read_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "external_docs", kind: "message", T: () => ExternalDocumentation },
            { no: 6, name: "example", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Schema>): Schema {
        const message = { discriminator: "", readOnly: false, example: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Schema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema): Schema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* grpc.gateway.protoc_gen_openapiv2.options.JSONSchema json_schema */ 1:
                    message.jsonSchema = JSONSchema.internalBinaryRead(reader, reader.uint32(), options, message.jsonSchema);
                    break;
                case /* string discriminator */ 2:
                    message.discriminator = reader.string();
                    break;
                case /* bool read_only */ 3:
                    message.readOnly = reader.bool();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs */ 5:
                    message.externalDocs = ExternalDocumentation.internalBinaryRead(reader, reader.uint32(), options, message.externalDocs);
                    break;
                case /* string example */ 6:
                    message.example = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Schema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* grpc.gateway.protoc_gen_openapiv2.options.JSONSchema json_schema = 1; */
        if (message.jsonSchema)
            JSONSchema.internalBinaryWrite(message.jsonSchema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string discriminator = 2; */
        if (message.discriminator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.discriminator);
        /* bool read_only = 3; */
        if (message.readOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.readOnly);
        /* grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 5; */
        if (message.externalDocs)
            ExternalDocumentation.internalBinaryWrite(message.externalDocs, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string example = 6; */
        if (message.example !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.example);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Schema
 */
export const Schema = new Schema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JSONSchema$Type extends MessageType<JSONSchema> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.JSONSchema", [
            { no: 3, name: "ref", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "read_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "example", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "multiple_of", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "maximum", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "exclusive_maximum", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "minimum", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "exclusive_minimum", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "max_length", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 16, name: "min_length", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 17, name: "pattern", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "max_items", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 21, name: "min_items", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 22, name: "unique_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "max_properties", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 25, name: "min_properties", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 26, name: "required", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "type", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes", JSONSchema_JSONSchemaSimpleTypes] },
            { no: 36, name: "format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 46, name: "enum", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 1001, name: "field_configuration", kind: "message", T: () => JSONSchema_FieldConfiguration },
            { no: 48, name: "extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<JSONSchema>): JSONSchema {
        const message = { ref: "", title: "", description: "", default: "", readOnly: false, example: "", multipleOf: 0, maximum: 0, exclusiveMaximum: false, minimum: 0, exclusiveMinimum: false, maxLength: "0", minLength: "0", pattern: "", maxItems: "0", minItems: "0", uniqueItems: false, maxProperties: "0", minProperties: "0", required: [], array: [], type: [], format: "", enum: [], extensions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JSONSchema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JSONSchema): JSONSchema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ref */ 3:
                    message.ref = reader.string();
                    break;
                case /* string title */ 5:
                    message.title = reader.string();
                    break;
                case /* string description */ 6:
                    message.description = reader.string();
                    break;
                case /* string default */ 7:
                    message.default = reader.string();
                    break;
                case /* bool read_only */ 8:
                    message.readOnly = reader.bool();
                    break;
                case /* string example */ 9:
                    message.example = reader.string();
                    break;
                case /* double multiple_of */ 10:
                    message.multipleOf = reader.double();
                    break;
                case /* double maximum */ 11:
                    message.maximum = reader.double();
                    break;
                case /* bool exclusive_maximum */ 12:
                    message.exclusiveMaximum = reader.bool();
                    break;
                case /* double minimum */ 13:
                    message.minimum = reader.double();
                    break;
                case /* bool exclusive_minimum */ 14:
                    message.exclusiveMinimum = reader.bool();
                    break;
                case /* uint64 max_length */ 15:
                    message.maxLength = reader.uint64().toString();
                    break;
                case /* uint64 min_length */ 16:
                    message.minLength = reader.uint64().toString();
                    break;
                case /* string pattern */ 17:
                    message.pattern = reader.string();
                    break;
                case /* uint64 max_items */ 20:
                    message.maxItems = reader.uint64().toString();
                    break;
                case /* uint64 min_items */ 21:
                    message.minItems = reader.uint64().toString();
                    break;
                case /* bool unique_items */ 22:
                    message.uniqueItems = reader.bool();
                    break;
                case /* uint64 max_properties */ 24:
                    message.maxProperties = reader.uint64().toString();
                    break;
                case /* uint64 min_properties */ 25:
                    message.minProperties = reader.uint64().toString();
                    break;
                case /* repeated string required */ 26:
                    message.required.push(reader.string());
                    break;
                case /* repeated string array */ 34:
                    message.array.push(reader.string());
                    break;
                case /* repeated grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes type */ 35:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.type.push(reader.int32());
                    else
                        message.type.push(reader.int32());
                    break;
                case /* string format */ 36:
                    message.format = reader.string();
                    break;
                case /* repeated string enum */ 46:
                    message.enum.push(reader.string());
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration field_configuration */ 1001:
                    message.fieldConfiguration = JSONSchema_FieldConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.fieldConfiguration);
                    break;
                case /* map<string, google.protobuf.Value> extensions */ 48:
                    this.binaryReadMap48(message.extensions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap48(map: JSONSchema["extensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof JSONSchema["extensions"] | undefined, val: JSONSchema["extensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.extensions");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: JSONSchema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ref = 3; */
        if (message.ref !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ref);
        /* string title = 5; */
        if (message.title !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.title);
        /* string description = 6; */
        if (message.description !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        /* string default = 7; */
        if (message.default !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.default);
        /* bool read_only = 8; */
        if (message.readOnly !== false)
            writer.tag(8, WireType.Varint).bool(message.readOnly);
        /* string example = 9; */
        if (message.example !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.example);
        /* double multiple_of = 10; */
        if (message.multipleOf !== 0)
            writer.tag(10, WireType.Bit64).double(message.multipleOf);
        /* double maximum = 11; */
        if (message.maximum !== 0)
            writer.tag(11, WireType.Bit64).double(message.maximum);
        /* bool exclusive_maximum = 12; */
        if (message.exclusiveMaximum !== false)
            writer.tag(12, WireType.Varint).bool(message.exclusiveMaximum);
        /* double minimum = 13; */
        if (message.minimum !== 0)
            writer.tag(13, WireType.Bit64).double(message.minimum);
        /* bool exclusive_minimum = 14; */
        if (message.exclusiveMinimum !== false)
            writer.tag(14, WireType.Varint).bool(message.exclusiveMinimum);
        /* uint64 max_length = 15; */
        if (message.maxLength !== "0")
            writer.tag(15, WireType.Varint).uint64(message.maxLength);
        /* uint64 min_length = 16; */
        if (message.minLength !== "0")
            writer.tag(16, WireType.Varint).uint64(message.minLength);
        /* string pattern = 17; */
        if (message.pattern !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.pattern);
        /* uint64 max_items = 20; */
        if (message.maxItems !== "0")
            writer.tag(20, WireType.Varint).uint64(message.maxItems);
        /* uint64 min_items = 21; */
        if (message.minItems !== "0")
            writer.tag(21, WireType.Varint).uint64(message.minItems);
        /* bool unique_items = 22; */
        if (message.uniqueItems !== false)
            writer.tag(22, WireType.Varint).bool(message.uniqueItems);
        /* uint64 max_properties = 24; */
        if (message.maxProperties !== "0")
            writer.tag(24, WireType.Varint).uint64(message.maxProperties);
        /* uint64 min_properties = 25; */
        if (message.minProperties !== "0")
            writer.tag(25, WireType.Varint).uint64(message.minProperties);
        /* repeated string required = 26; */
        for (let i = 0; i < message.required.length; i++)
            writer.tag(26, WireType.LengthDelimited).string(message.required[i]);
        /* repeated string array = 34; */
        for (let i = 0; i < message.array.length; i++)
            writer.tag(34, WireType.LengthDelimited).string(message.array[i]);
        /* repeated grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes type = 35; */
        if (message.type.length) {
            writer.tag(35, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.type.length; i++)
                writer.int32(message.type[i]);
            writer.join();
        }
        /* string format = 36; */
        if (message.format !== "")
            writer.tag(36, WireType.LengthDelimited).string(message.format);
        /* repeated string enum = 46; */
        for (let i = 0; i < message.enum.length; i++)
            writer.tag(46, WireType.LengthDelimited).string(message.enum[i]);
        /* grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration field_configuration = 1001; */
        if (message.fieldConfiguration)
            JSONSchema_FieldConfiguration.internalBinaryWrite(message.fieldConfiguration, writer.tag(1001, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Value> extensions = 48; */
        for (let k of Object.keys(message.extensions)) {
            writer.tag(48, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.extensions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
 */
export const JSONSchema = new JSONSchema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JSONSchema_FieldConfiguration$Type extends MessageType<JSONSchema_FieldConfiguration> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration", [
            { no: 47, name: "path_param_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JSONSchema_FieldConfiguration>): JSONSchema_FieldConfiguration {
        const message = { pathParamName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JSONSchema_FieldConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JSONSchema_FieldConfiguration): JSONSchema_FieldConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path_param_name */ 47:
                    message.pathParamName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JSONSchema_FieldConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path_param_name = 47; */
        if (message.pathParamName !== "")
            writer.tag(47, WireType.LengthDelimited).string(message.pathParamName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration
 */
export const JSONSchema_FieldConfiguration = new JSONSchema_FieldConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tag$Type extends MessageType<Tag> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Tag", [
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "external_docs", kind: "message", T: () => ExternalDocumentation }
        ]);
    }
    create(value?: PartialMessage<Tag>): Tag {
        const message = { description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tag): Tag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs */ 3:
                    message.externalDocs = ExternalDocumentation.internalBinaryRead(reader, reader.uint32(), options, message.externalDocs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 3; */
        if (message.externalDocs)
            ExternalDocumentation.internalBinaryWrite(message.externalDocs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Tag
 */
export const Tag = new Tag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityDefinitions$Type extends MessageType<SecurityDefinitions> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions", [
            { no: 1, name: "security", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SecurityScheme } }
        ]);
    }
    create(value?: PartialMessage<SecurityDefinitions>): SecurityDefinitions {
        const message = { security: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SecurityDefinitions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityDefinitions): SecurityDefinitions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme> security */ 1:
                    this.binaryReadMap1(message.security, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SecurityDefinitions["security"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SecurityDefinitions["security"] | undefined, val: SecurityDefinitions["security"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SecurityScheme.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.security");
            }
        }
        map[key ?? ""] = val ?? SecurityScheme.create();
    }
    internalBinaryWrite(message: SecurityDefinitions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme> security = 1; */
        for (let k of Object.keys(message.security)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SecurityScheme.internalBinaryWrite(message.security[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions
 */
export const SecurityDefinitions = new SecurityDefinitions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityScheme$Type extends MessageType<SecurityScheme> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme", [
            { no: 1, name: "type", kind: "enum", T: () => ["grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type", SecurityScheme_Type, "TYPE_"] },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "in", kind: "enum", T: () => ["grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In", SecurityScheme_In, "IN_"] },
            { no: 5, name: "flow", kind: "enum", T: () => ["grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow", SecurityScheme_Flow, "FLOW_"] },
            { no: 6, name: "authorization_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "scopes", kind: "message", T: () => Scopes },
            { no: 9, name: "extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<SecurityScheme>): SecurityScheme {
        const message = { type: 0, description: "", name: "", in: 0, flow: 0, authorizationUrl: "", tokenUrl: "", extensions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityScheme): SecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In in */ 4:
                    message.in = reader.int32();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow flow */ 5:
                    message.flow = reader.int32();
                    break;
                case /* string authorization_url */ 6:
                    message.authorizationUrl = reader.string();
                    break;
                case /* string token_url */ 7:
                    message.tokenUrl = reader.string();
                    break;
                case /* grpc.gateway.protoc_gen_openapiv2.options.Scopes scopes */ 8:
                    message.scopes = Scopes.internalBinaryRead(reader, reader.uint32(), options, message.scopes);
                    break;
                case /* map<string, google.protobuf.Value> extensions */ 9:
                    this.binaryReadMap9(message.extensions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: SecurityScheme["extensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SecurityScheme["extensions"] | undefined, val: SecurityScheme["extensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.extensions");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: SecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In in = 4; */
        if (message.in !== 0)
            writer.tag(4, WireType.Varint).int32(message.in);
        /* grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow flow = 5; */
        if (message.flow !== 0)
            writer.tag(5, WireType.Varint).int32(message.flow);
        /* string authorization_url = 6; */
        if (message.authorizationUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.authorizationUrl);
        /* string token_url = 7; */
        if (message.tokenUrl !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.tokenUrl);
        /* grpc.gateway.protoc_gen_openapiv2.options.Scopes scopes = 8; */
        if (message.scopes)
            Scopes.internalBinaryWrite(message.scopes, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Value> extensions = 9; */
        for (let k of Object.keys(message.extensions)) {
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.extensions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme
 */
export const SecurityScheme = new SecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityRequirement$Type extends MessageType<SecurityRequirement> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement", [
            { no: 1, name: "security_requirement", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SecurityRequirement_SecurityRequirementValue } }
        ]);
    }
    create(value?: PartialMessage<SecurityRequirement>): SecurityRequirement {
        const message = { securityRequirement: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SecurityRequirement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityRequirement): SecurityRequirement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue> security_requirement */ 1:
                    this.binaryReadMap1(message.securityRequirement, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SecurityRequirement["securityRequirement"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SecurityRequirement["securityRequirement"] | undefined, val: SecurityRequirement["securityRequirement"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SecurityRequirement_SecurityRequirementValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.security_requirement");
            }
        }
        map[key ?? ""] = val ?? SecurityRequirement_SecurityRequirementValue.create();
    }
    internalBinaryWrite(message: SecurityRequirement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue> security_requirement = 1; */
        for (let k of Object.keys(message.securityRequirement)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SecurityRequirement_SecurityRequirementValue.internalBinaryWrite(message.securityRequirement[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
 */
export const SecurityRequirement = new SecurityRequirement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityRequirement_SecurityRequirementValue$Type extends MessageType<SecurityRequirement_SecurityRequirementValue> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue", [
            { no: 1, name: "scope", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SecurityRequirement_SecurityRequirementValue>): SecurityRequirement_SecurityRequirementValue {
        const message = { scope: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SecurityRequirement_SecurityRequirementValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityRequirement_SecurityRequirementValue): SecurityRequirement_SecurityRequirementValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string scope */ 1:
                    message.scope.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecurityRequirement_SecurityRequirementValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string scope = 1; */
        for (let i = 0; i < message.scope.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.scope[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue
 */
export const SecurityRequirement_SecurityRequirementValue = new SecurityRequirement_SecurityRequirementValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Scopes$Type extends MessageType<Scopes> {
    constructor() {
        super("grpc.gateway.protoc_gen_openapiv2.options.Scopes", [
            { no: 1, name: "scope", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Scopes>): Scopes {
        const message = { scope: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Scopes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Scopes): Scopes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> scope */ 1:
                    this.binaryReadMap1(message.scope, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Scopes["scope"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Scopes["scope"] | undefined, val: Scopes["scope"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field grpc.gateway.protoc_gen_openapiv2.options.Scopes.scope");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Scopes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> scope = 1; */
        for (let k of Object.keys(message.scope))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scope[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message grpc.gateway.protoc_gen_openapiv2.options.Scopes
 */
export const Scopes = new Scopes$Type();
