// @generated by protobuf-ts 2.8.3 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "authzed/api/v1/schema_service.proto" (package "authzed.api.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ZedToken } from "./core";
/**
 * ReadSchemaRequest returns the schema from the database.
 *
 * @generated from protobuf message authzed.api.v1.ReadSchemaRequest
 */
export interface ReadSchemaRequest {
}
/**
 * ReadSchemaResponse is the resulting data after having read the Object
 * Definitions from a Schema.
 *
 * @generated from protobuf message authzed.api.v1.ReadSchemaResponse
 */
export interface ReadSchemaResponse {
    /**
     * schema_text is the textual form of the current schema in the system
     *
     * @generated from protobuf field: string schema_text = 1;
     */
    schemaText: string;
    /**
     * read_at is the ZedToken at which the schema was read.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken read_at = 2;
     */
    readAt?: ZedToken;
}
/**
 * WriteSchemaRequest is the required data used to "upsert" the Schema of a
 * Permissions System.
 *
 * @generated from protobuf message authzed.api.v1.WriteSchemaRequest
 */
export interface WriteSchemaRequest {
    /**
     * The Schema containing one or more Object Definitions that will be written
     * to the Permissions System.
     *
     * @generated from protobuf field: string schema = 1;
     */
    schema: string; // 4MiB
}
/**
 * WriteSchemaResponse is the resulting data after having written a Schema to
 * a Permissions System.
 *
 * @generated from protobuf message authzed.api.v1.WriteSchemaResponse
 */
export interface WriteSchemaResponse {
    /**
     * written_at is the ZedToken at which the schema was written.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken written_at = 1;
     */
    writtenAt?: ZedToken;
}
// @generated message type with reflection information, may provide speed optimized methods
class ReadSchemaRequest$Type extends MessageType<ReadSchemaRequest> {
    constructor() {
        super("authzed.api.v1.ReadSchemaRequest", []);
    }
    create(value?: PartialMessage<ReadSchemaRequest>): ReadSchemaRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadSchemaRequest): ReadSchemaRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ReadSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadSchemaRequest
 */
export const ReadSchemaRequest = new ReadSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadSchemaResponse$Type extends MessageType<ReadSchemaResponse> {
    constructor() {
        super("authzed.api.v1.ReadSchemaResponse", [
            { no: 1, name: "schema_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "read_at", kind: "message", T: () => ZedToken, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<ReadSchemaResponse>): ReadSchemaResponse {
        const message = { schemaText: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadSchemaResponse): ReadSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_text */ 1:
                    message.schemaText = reader.string();
                    break;
                case /* authzed.api.v1.ZedToken read_at */ 2:
                    message.readAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_text = 1; */
        if (message.schemaText !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaText);
        /* authzed.api.v1.ZedToken read_at = 2; */
        if (message.readAt)
            ZedToken.internalBinaryWrite(message.readAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadSchemaResponse
 */
export const ReadSchemaResponse = new ReadSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteSchemaRequest$Type extends MessageType<WriteSchemaRequest> {
    constructor() {
        super("authzed.api.v1.WriteSchemaRequest", [
            { no: 1, name: "schema", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "4194304" } } } }
        ]);
    }
    create(value?: PartialMessage<WriteSchemaRequest>): WriteSchemaRequest {
        const message = { schema: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteSchemaRequest): WriteSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema */ 1:
                    message.schema = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema = 1; */
        if (message.schema !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.WriteSchemaRequest
 */
export const WriteSchemaRequest = new WriteSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteSchemaResponse$Type extends MessageType<WriteSchemaResponse> {
    constructor() {
        super("authzed.api.v1.WriteSchemaResponse", [
            { no: 1, name: "written_at", kind: "message", T: () => ZedToken, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<WriteSchemaResponse>): WriteSchemaResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteSchemaResponse): WriteSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken written_at */ 1:
                    message.writtenAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.writtenAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken written_at = 1; */
        if (message.writtenAt)
            ZedToken.internalBinaryWrite(message.writtenAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.WriteSchemaResponse
 */
export const WriteSchemaResponse = new WriteSchemaResponse$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.v1.SchemaService
 */
export const SchemaService = new ServiceType("authzed.api.v1.SchemaService", [
    { name: "ReadSchema", options: { "google.api.http": { post: "/v1/schema/read", body: "*" } }, I: ReadSchemaRequest, O: ReadSchemaResponse },
    { name: "WriteSchema", options: { "google.api.http": { post: "/v1/schema/write", body: "*" } }, I: WriteSchemaRequest, O: WriteSchemaResponse }
]);
