// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "authzed/api/v1/experimental_service.proto" (package "authzed.api.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Cursor } from "./core";
import { Relationship } from "./core";
import { PartialCaveatInfo } from "./core";
import { CheckPermissionResponse_Permissionship } from "./permission_service";
import { Status } from "../../../google/rpc/status";
import { Struct } from "../../../google/protobuf/struct";
import { SubjectReference } from "./core";
import { ObjectReference } from "./core";
import { Consistency } from "./permission_service";
import { ZedToken } from "./core";
import { RelationshipFilter } from "./permission_service";
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalRegisterRelationshipCounterRequest
 */
export interface ExperimentalRegisterRelationshipCounterRequest {
    /**
     * name is the name of the counter being registered.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * relationship_filter defines the filter to be applied to the relationships
     * to be counted.
     *
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter relationship_filter = 2;
     */
    relationshipFilter?: RelationshipFilter;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalRegisterRelationshipCounterResponse
 */
export interface ExperimentalRegisterRelationshipCounterResponse {
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalCountRelationshipsRequest
 */
export interface ExperimentalCountRelationshipsRequest {
    /**
     * name is the name of the counter whose count is being requested.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalCountRelationshipsResponse
 */
export interface ExperimentalCountRelationshipsResponse {
    /**
     * @generated from protobuf oneof: counter_result
     */
    counterResult: {
        oneofKind: "counterStillCalculating";
        /**
         * counter_still_calculating is true if the counter is still calculating the count.
         *
         * @generated from protobuf field: bool counter_still_calculating = 1;
         */
        counterStillCalculating: boolean;
    } | {
        oneofKind: "readCounterValue";
        /**
         * read_counter_value is the value of the counter at the time of the read.
         *
         * @generated from protobuf field: authzed.api.v1.ReadCounterValue read_counter_value = 2;
         */
        readCounterValue: ReadCounterValue;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message authzed.api.v1.ReadCounterValue
 */
export interface ReadCounterValue {
    /**
     * relationship_count is the count of relationships that match the filter.
     *
     * @generated from protobuf field: uint64 relationship_count = 1;
     */
    relationshipCount: string;
    /**
     * read_at is the ZedToken at which the relationship count applies.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken read_at = 2;
     */
    readAt?: ZedToken;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalUnregisterRelationshipCounterRequest
 */
export interface ExperimentalUnregisterRelationshipCounterRequest {
    /**
     * name is the name of the counter being unregistered.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalUnregisterRelationshipCounterResponse
 */
export interface ExperimentalUnregisterRelationshipCounterResponse {
}
/**
 * NOTE: Deprecated now that BulkCheckPermission has been promoted to the stable API as "CheckBulkPermission".
 *
 * @generated from protobuf message authzed.api.v1.BulkCheckPermissionRequest
 */
export interface BulkCheckPermissionRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * @deprecated
     * @generated from protobuf field: repeated authzed.api.v1.BulkCheckPermissionRequestItem items = 2 [deprecated = true];
     */
    items: BulkCheckPermissionRequestItem[];
}
/**
 * @generated from protobuf message authzed.api.v1.BulkCheckPermissionRequestItem
 */
export interface BulkCheckPermissionRequestItem {
    /**
     * @generated from protobuf field: authzed.api.v1.ObjectReference resource = 1;
     */
    resource?: ObjectReference;
    /**
     * @generated from protobuf field: string permission = 2;
     */
    permission: string;
    /**
     * @generated from protobuf field: authzed.api.v1.SubjectReference subject = 3;
     */
    subject?: SubjectReference;
    /**
     * @generated from protobuf field: google.protobuf.Struct context = 4;
     */
    context?: Struct;
}
/**
 * @generated from protobuf message authzed.api.v1.BulkCheckPermissionResponse
 */
export interface BulkCheckPermissionResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken checked_at = 1;
     */
    checkedAt?: ZedToken;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.BulkCheckPermissionPair pairs = 2;
     */
    pairs: BulkCheckPermissionPair[];
}
/**
 * @generated from protobuf message authzed.api.v1.BulkCheckPermissionPair
 */
export interface BulkCheckPermissionPair {
    /**
     * @generated from protobuf field: authzed.api.v1.BulkCheckPermissionRequestItem request = 1;
     */
    request?: BulkCheckPermissionRequestItem;
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "item";
        /**
         * @generated from protobuf field: authzed.api.v1.BulkCheckPermissionResponseItem item = 2;
         */
        item: BulkCheckPermissionResponseItem;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: google.rpc.Status error = 3;
         */
        error: Status;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message authzed.api.v1.BulkCheckPermissionResponseItem
 */
export interface BulkCheckPermissionResponseItem {
    /**
     * @generated from protobuf field: authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 1;
     */
    permissionship: CheckPermissionResponse_Permissionship;
    /**
     * @generated from protobuf field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 2;
     */
    partialCaveatInfo?: PartialCaveatInfo;
}
/**
 * BulkImportRelationshipsRequest represents one batch of the streaming
 * BulkImportRelationships API. The maximum size is only limited by the backing
 * datastore, and optimal size should be determined by the calling client
 * experimentally.
 *
 * @generated from protobuf message authzed.api.v1.BulkImportRelationshipsRequest
 */
export interface BulkImportRelationshipsRequest {
    /**
     * @generated from protobuf field: repeated authzed.api.v1.Relationship relationships = 1;
     */
    relationships: Relationship[];
}
/**
 * BulkImportRelationshipsResponse is returned on successful completion of the
 * bulk load stream, and contains the total number of relationships loaded.
 *
 * @generated from protobuf message authzed.api.v1.BulkImportRelationshipsResponse
 */
export interface BulkImportRelationshipsResponse {
    /**
     * @generated from protobuf field: uint64 num_loaded = 1;
     */
    numLoaded: string;
}
/**
 * BulkExportRelationshipsRequest represents a resumable request for
 * all relationships from the server.
 *
 * @generated from protobuf message authzed.api.v1.BulkExportRelationshipsRequest
 */
export interface BulkExportRelationshipsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * optional_limit, if non-zero, specifies the limit on the number of
     * relationships the server can return in one page. By default, the server
     * will pick a page size, and the server is free to choose a smaller size
     * at will.
     *
     * @generated from protobuf field: uint32 optional_limit = 2;
     */
    optionalLimit: number;
    /**
     * optional_cursor, if specified, indicates the cursor after which results
     * should resume being returned. The cursor can be found on the
     * BulkExportRelationshipsResponse object.
     *
     * @generated from protobuf field: authzed.api.v1.Cursor optional_cursor = 3;
     */
    optionalCursor?: Cursor;
    /**
     * optional_relationship_filter, if specified, indicates the
     * filter to apply to each relationship to be exported.
     *
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter optional_relationship_filter = 4;
     */
    optionalRelationshipFilter?: RelationshipFilter;
}
/**
 * BulkExportRelationshipsResponse is one page in a stream of relationship
 * groups that meet the criteria specified by the originating request. The
 * server will continue to stream back relationship groups as quickly as it can
 * until all relationships have been transmitted back.
 *
 * @generated from protobuf message authzed.api.v1.BulkExportRelationshipsResponse
 */
export interface BulkExportRelationshipsResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.Cursor after_result_cursor = 1;
     */
    afterResultCursor?: Cursor;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.Relationship relationships = 2;
     */
    relationships: Relationship[];
}
// Reflection types ////////////////////////////////////////////

/**
 * @generated from protobuf message authzed.api.v1.ExperimentalReflectSchemaRequest
 */
export interface ExperimentalReflectSchemaRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * optional_filters defines optional filters that are applied in
     * an OR fashion to the schema, before being returned
     *
     * @generated from protobuf field: repeated authzed.api.v1.ExpSchemaFilter optional_filters = 2;
     */
    optionalFilters: ExpSchemaFilter[];
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalReflectSchemaResponse
 */
export interface ExperimentalReflectSchemaResponse {
    /**
     * definitions are the definitions defined in the schema.
     *
     * @generated from protobuf field: repeated authzed.api.v1.ExpDefinition definitions = 1;
     */
    definitions: ExpDefinition[];
    /**
     * caveats are the caveats defined in the schema.
     *
     * @generated from protobuf field: repeated authzed.api.v1.ExpCaveat caveats = 2;
     */
    caveats: ExpCaveat[];
    /**
     * read_at is the ZedToken at which the schema was read.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken read_at = 3;
     */
    readAt?: ZedToken;
}
/**
 * ExpSchemaFilter is a filter that can be applied to the schema on reflection.
 *
 * @generated from protobuf message authzed.api.v1.ExpSchemaFilter
 */
export interface ExpSchemaFilter {
    /**
     * optional_definition_name_filter is a prefix that is matched against the definition name.
     *
     * @generated from protobuf field: string optional_definition_name_filter = 1;
     */
    optionalDefinitionNameFilter: string;
    /**
     * optional_caveat_name_filter is a prefix that is matched against the caveat name.
     *
     * @generated from protobuf field: string optional_caveat_name_filter = 2;
     */
    optionalCaveatNameFilter: string;
    /**
     * optional_relation_name_filter is a prefix that is matched against the relation name.
     *
     * @generated from protobuf field: string optional_relation_name_filter = 3;
     */
    optionalRelationNameFilter: string;
    /**
     * optional_permission_name_filter is a prefix that is matched against the permission name.
     *
     * @generated from protobuf field: string optional_permission_name_filter = 4;
     */
    optionalPermissionNameFilter: string;
}
/**
 * ExpDefinition is the representation of a definition in the schema.
 *
 * @generated from protobuf message authzed.api.v1.ExpDefinition
 */
export interface ExpDefinition {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * comment is a human-readable comments on the definition. Will include
     * delimiter characters.
     *
     * @generated from protobuf field: string comment = 2;
     */
    comment: string;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.ExpRelation relations = 3;
     */
    relations: ExpRelation[];
    /**
     * @generated from protobuf field: repeated authzed.api.v1.ExpPermission permissions = 4;
     */
    permissions: ExpPermission[];
}
/**
 * ExpCaveat is the representation of a caveat in the schema.
 *
 * @generated from protobuf message authzed.api.v1.ExpCaveat
 */
export interface ExpCaveat {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * comment is a human-readable comments on the caveat. Will include
     * delimiter characters.
     *
     * @generated from protobuf field: string comment = 2;
     */
    comment: string;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.ExpCaveatParameter parameters = 3;
     */
    parameters: ExpCaveatParameter[];
    /**
     * @generated from protobuf field: string expression = 4;
     */
    expression: string;
}
/**
 * ExpCaveatParameter is the representation of a parameter in a caveat.
 *
 * @generated from protobuf message authzed.api.v1.ExpCaveatParameter
 */
export interface ExpCaveatParameter {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * type is the type of the parameter. Will be a string representing the
     * type, e.g. `int` or `list<string>`
     *
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * @generated from protobuf field: string parent_caveat_name = 3;
     */
    parentCaveatName: string;
}
/**
 * ExpRelation is the representation of a relation in the schema.
 *
 * @generated from protobuf message authzed.api.v1.ExpRelation
 */
export interface ExpRelation {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string comment = 2;
     */
    comment: string;
    /**
     * @generated from protobuf field: string parent_definition_name = 3;
     */
    parentDefinitionName: string;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.ExpTypeReference subject_types = 4;
     */
    subjectTypes: ExpTypeReference[];
}
/**
 * ExpTypeReference is the representation of a type reference in the schema.
 *
 * @generated from protobuf message authzed.api.v1.ExpTypeReference
 */
export interface ExpTypeReference {
    /**
     * subject_definition_name is the name of the subject's definition.
     *
     * @generated from protobuf field: string subject_definition_name = 1;
     */
    subjectDefinitionName: string;
    /**
     * optional_caveat_name is the name of the caveat that is applied to the subject, if any.
     *
     * @generated from protobuf field: string optional_caveat_name = 2;
     */
    optionalCaveatName: string;
    /**
     * @generated from protobuf oneof: typeref
     */
    typeref: {
        oneofKind: "isTerminalSubject";
        /**
         * is_terminal_subject is true if the subject is terminal, meaning it is referenced directly vs a sub-relation.
         *
         * @generated from protobuf field: bool is_terminal_subject = 3;
         */
        isTerminalSubject: boolean;
    } | {
        oneofKind: "optionalRelationName";
        /**
         * optional_relation_name is the name of the relation that is applied to the subject, if any.
         *
         * @generated from protobuf field: string optional_relation_name = 4;
         */
        optionalRelationName: string;
    } | {
        oneofKind: "isPublicWildcard";
        /**
         * is_public_wildcard is true if the subject is a public wildcard.
         *
         * @generated from protobuf field: bool is_public_wildcard = 5;
         */
        isPublicWildcard: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * ExpPermission is the representation of a permission in the schema.
 *
 * @generated from protobuf message authzed.api.v1.ExpPermission
 */
export interface ExpPermission {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * comment is a human-readable comments on the permission. Will include
     * delimiter characters.
     *
     * @generated from protobuf field: string comment = 2;
     */
    comment: string;
    /**
     * @generated from protobuf field: string parent_definition_name = 3;
     */
    parentDefinitionName: string;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalComputablePermissionsRequest
 */
export interface ExperimentalComputablePermissionsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * @generated from protobuf field: string definition_name = 2;
     */
    definitionName: string;
    /**
     * @generated from protobuf field: string relation_name = 3;
     */
    relationName: string;
    /**
     * optional_definition_name_match is a prefix that is matched against the definition name(s)
     * for the permissions returned.
     * If not specified, will be ignored.
     *
     * @generated from protobuf field: string optional_definition_name_filter = 4;
     */
    optionalDefinitionNameFilter: string;
}
/**
 * ExpRelationReference is a reference to a relation or permission in the schema.
 *
 * @generated from protobuf message authzed.api.v1.ExpRelationReference
 */
export interface ExpRelationReference {
    /**
     * @generated from protobuf field: string definition_name = 1;
     */
    definitionName: string;
    /**
     * @generated from protobuf field: string relation_name = 2;
     */
    relationName: string;
    /**
     * @generated from protobuf field: bool is_permission = 3;
     */
    isPermission: boolean;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalComputablePermissionsResponse
 */
export interface ExperimentalComputablePermissionsResponse {
    /**
     * @generated from protobuf field: repeated authzed.api.v1.ExpRelationReference permissions = 1;
     */
    permissions: ExpRelationReference[];
    /**
     * read_at is the ZedToken at which the schema was read.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken read_at = 2;
     */
    readAt?: ZedToken;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalDependentRelationsRequest
 */
export interface ExperimentalDependentRelationsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * @generated from protobuf field: string definition_name = 2;
     */
    definitionName: string;
    /**
     * @generated from protobuf field: string permission_name = 3;
     */
    permissionName: string;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalDependentRelationsResponse
 */
export interface ExperimentalDependentRelationsResponse {
    /**
     * @generated from protobuf field: repeated authzed.api.v1.ExpRelationReference relations = 1;
     */
    relations: ExpRelationReference[];
    /**
     * read_at is the ZedToken at which the schema was read.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken read_at = 2;
     */
    readAt?: ZedToken;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalDiffSchemaRequest
 */
export interface ExperimentalDiffSchemaRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * @generated from protobuf field: string comparison_schema = 2;
     */
    comparisonSchema: string;
}
/**
 * @generated from protobuf message authzed.api.v1.ExperimentalDiffSchemaResponse
 */
export interface ExperimentalDiffSchemaResponse {
    /**
     * @generated from protobuf field: repeated authzed.api.v1.ExpSchemaDiff diffs = 1;
     */
    diffs: ExpSchemaDiff[];
    /**
     * read_at is the ZedToken at which the schema was read.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken read_at = 2;
     */
    readAt?: ZedToken;
}
/**
 * @generated from protobuf message authzed.api.v1.ExpRelationSubjectTypeChange
 */
export interface ExpRelationSubjectTypeChange {
    /**
     * @generated from protobuf field: authzed.api.v1.ExpRelation relation = 1;
     */
    relation?: ExpRelation;
    /**
     * @generated from protobuf field: authzed.api.v1.ExpTypeReference changed_subject_type = 2;
     */
    changedSubjectType?: ExpTypeReference;
}
/**
 * @generated from protobuf message authzed.api.v1.ExpCaveatParameterTypeChange
 */
export interface ExpCaveatParameterTypeChange {
    /**
     * @generated from protobuf field: authzed.api.v1.ExpCaveatParameter parameter = 1;
     */
    parameter?: ExpCaveatParameter;
    /**
     * @generated from protobuf field: string previous_type = 2;
     */
    previousType: string;
}
/**
 * ExpSchemaDiff is the representation of a diff between two schemas.
 *
 * @generated from protobuf message authzed.api.v1.ExpSchemaDiff
 */
export interface ExpSchemaDiff {
    /**
     * @generated from protobuf oneof: diff
     */
    diff: {
        oneofKind: "definitionAdded";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpDefinition definition_added = 1;
         */
        definitionAdded: ExpDefinition;
    } | {
        oneofKind: "definitionRemoved";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpDefinition definition_removed = 2;
         */
        definitionRemoved: ExpDefinition;
    } | {
        oneofKind: "definitionDocCommentChanged";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpDefinition definition_doc_comment_changed = 3;
         */
        definitionDocCommentChanged: ExpDefinition;
    } | {
        oneofKind: "relationAdded";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpRelation relation_added = 4;
         */
        relationAdded: ExpRelation;
    } | {
        oneofKind: "relationRemoved";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpRelation relation_removed = 5;
         */
        relationRemoved: ExpRelation;
    } | {
        oneofKind: "relationDocCommentChanged";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpRelation relation_doc_comment_changed = 6;
         */
        relationDocCommentChanged: ExpRelation;
    } | {
        oneofKind: "relationSubjectTypeAdded";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpRelationSubjectTypeChange relation_subject_type_added = 7;
         */
        relationSubjectTypeAdded: ExpRelationSubjectTypeChange;
    } | {
        oneofKind: "relationSubjectTypeRemoved";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpRelationSubjectTypeChange relation_subject_type_removed = 8;
         */
        relationSubjectTypeRemoved: ExpRelationSubjectTypeChange;
    } | {
        oneofKind: "permissionAdded";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpPermission permission_added = 9;
         */
        permissionAdded: ExpPermission;
    } | {
        oneofKind: "permissionRemoved";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpPermission permission_removed = 10;
         */
        permissionRemoved: ExpPermission;
    } | {
        oneofKind: "permissionDocCommentChanged";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpPermission permission_doc_comment_changed = 11;
         */
        permissionDocCommentChanged: ExpPermission;
    } | {
        oneofKind: "permissionExprChanged";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpPermission permission_expr_changed = 12;
         */
        permissionExprChanged: ExpPermission;
    } | {
        oneofKind: "caveatAdded";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpCaveat caveat_added = 13;
         */
        caveatAdded: ExpCaveat;
    } | {
        oneofKind: "caveatRemoved";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpCaveat caveat_removed = 14;
         */
        caveatRemoved: ExpCaveat;
    } | {
        oneofKind: "caveatDocCommentChanged";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpCaveat caveat_doc_comment_changed = 15;
         */
        caveatDocCommentChanged: ExpCaveat;
    } | {
        oneofKind: "caveatExprChanged";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpCaveat caveat_expr_changed = 16;
         */
        caveatExprChanged: ExpCaveat;
    } | {
        oneofKind: "caveatParameterAdded";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpCaveatParameter caveat_parameter_added = 17;
         */
        caveatParameterAdded: ExpCaveatParameter;
    } | {
        oneofKind: "caveatParameterRemoved";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpCaveatParameter caveat_parameter_removed = 18;
         */
        caveatParameterRemoved: ExpCaveatParameter;
    } | {
        oneofKind: "caveatParameterTypeChanged";
        /**
         * @generated from protobuf field: authzed.api.v1.ExpCaveatParameterTypeChange caveat_parameter_type_changed = 19;
         */
        caveatParameterTypeChanged: ExpCaveatParameterTypeChange;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalRegisterRelationshipCounterRequest$Type extends MessageType<ExperimentalRegisterRelationshipCounterRequest> {
    constructor() {
        super("authzed.api.v1.ExperimentalRegisterRelationshipCounterRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 2, name: "relationship_filter", kind: "message", T: () => RelationshipFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<ExperimentalRegisterRelationshipCounterRequest>): ExperimentalRegisterRelationshipCounterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ExperimentalRegisterRelationshipCounterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalRegisterRelationshipCounterRequest): ExperimentalRegisterRelationshipCounterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* authzed.api.v1.RelationshipFilter relationship_filter */ 2:
                    message.relationshipFilter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.relationshipFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalRegisterRelationshipCounterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* authzed.api.v1.RelationshipFilter relationship_filter = 2; */
        if (message.relationshipFilter)
            RelationshipFilter.internalBinaryWrite(message.relationshipFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalRegisterRelationshipCounterRequest
 */
export const ExperimentalRegisterRelationshipCounterRequest = new ExperimentalRegisterRelationshipCounterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalRegisterRelationshipCounterResponse$Type extends MessageType<ExperimentalRegisterRelationshipCounterResponse> {
    constructor() {
        super("authzed.api.v1.ExperimentalRegisterRelationshipCounterResponse", []);
    }
    create(value?: PartialMessage<ExperimentalRegisterRelationshipCounterResponse>): ExperimentalRegisterRelationshipCounterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExperimentalRegisterRelationshipCounterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalRegisterRelationshipCounterResponse): ExperimentalRegisterRelationshipCounterResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ExperimentalRegisterRelationshipCounterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalRegisterRelationshipCounterResponse
 */
export const ExperimentalRegisterRelationshipCounterResponse = new ExperimentalRegisterRelationshipCounterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalCountRelationshipsRequest$Type extends MessageType<ExperimentalCountRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.ExperimentalCountRelationshipsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value?: PartialMessage<ExperimentalCountRelationshipsRequest>): ExperimentalCountRelationshipsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ExperimentalCountRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalCountRelationshipsRequest): ExperimentalCountRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalCountRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalCountRelationshipsRequest
 */
export const ExperimentalCountRelationshipsRequest = new ExperimentalCountRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalCountRelationshipsResponse$Type extends MessageType<ExperimentalCountRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.ExperimentalCountRelationshipsResponse", [
            { no: 1, name: "counter_still_calculating", kind: "scalar", oneof: "counterResult", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "read_counter_value", kind: "message", oneof: "counterResult", T: () => ReadCounterValue }
        ]);
    }
    create(value?: PartialMessage<ExperimentalCountRelationshipsResponse>): ExperimentalCountRelationshipsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.counterResult = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ExperimentalCountRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalCountRelationshipsResponse): ExperimentalCountRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool counter_still_calculating */ 1:
                    message.counterResult = {
                        oneofKind: "counterStillCalculating",
                        counterStillCalculating: reader.bool()
                    };
                    break;
                case /* authzed.api.v1.ReadCounterValue read_counter_value */ 2:
                    message.counterResult = {
                        oneofKind: "readCounterValue",
                        readCounterValue: ReadCounterValue.internalBinaryRead(reader, reader.uint32(), options, (message.counterResult as any).readCounterValue)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalCountRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool counter_still_calculating = 1; */
        if (message.counterResult.oneofKind === "counterStillCalculating")
            writer.tag(1, WireType.Varint).bool(message.counterResult.counterStillCalculating);
        /* authzed.api.v1.ReadCounterValue read_counter_value = 2; */
        if (message.counterResult.oneofKind === "readCounterValue")
            ReadCounterValue.internalBinaryWrite(message.counterResult.readCounterValue, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalCountRelationshipsResponse
 */
export const ExperimentalCountRelationshipsResponse = new ExperimentalCountRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadCounterValue$Type extends MessageType<ReadCounterValue> {
    constructor() {
        super("authzed.api.v1.ReadCounterValue", [
            { no: 1, name: "relationship_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "read_at", kind: "message", T: () => ZedToken, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<ReadCounterValue>): ReadCounterValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relationshipCount = "0";
        if (value !== undefined)
            reflectionMergePartial<ReadCounterValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadCounterValue): ReadCounterValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 relationship_count */ 1:
                    message.relationshipCount = reader.uint64().toString();
                    break;
                case /* authzed.api.v1.ZedToken read_at */ 2:
                    message.readAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadCounterValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 relationship_count = 1; */
        if (message.relationshipCount !== "0")
            writer.tag(1, WireType.Varint).uint64(message.relationshipCount);
        /* authzed.api.v1.ZedToken read_at = 2; */
        if (message.readAt)
            ZedToken.internalBinaryWrite(message.readAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadCounterValue
 */
export const ReadCounterValue = new ReadCounterValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalUnregisterRelationshipCounterRequest$Type extends MessageType<ExperimentalUnregisterRelationshipCounterRequest> {
    constructor() {
        super("authzed.api.v1.ExperimentalUnregisterRelationshipCounterRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value?: PartialMessage<ExperimentalUnregisterRelationshipCounterRequest>): ExperimentalUnregisterRelationshipCounterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ExperimentalUnregisterRelationshipCounterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalUnregisterRelationshipCounterRequest): ExperimentalUnregisterRelationshipCounterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalUnregisterRelationshipCounterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalUnregisterRelationshipCounterRequest
 */
export const ExperimentalUnregisterRelationshipCounterRequest = new ExperimentalUnregisterRelationshipCounterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalUnregisterRelationshipCounterResponse$Type extends MessageType<ExperimentalUnregisterRelationshipCounterResponse> {
    constructor() {
        super("authzed.api.v1.ExperimentalUnregisterRelationshipCounterResponse", []);
    }
    create(value?: PartialMessage<ExperimentalUnregisterRelationshipCounterResponse>): ExperimentalUnregisterRelationshipCounterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExperimentalUnregisterRelationshipCounterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalUnregisterRelationshipCounterResponse): ExperimentalUnregisterRelationshipCounterResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ExperimentalUnregisterRelationshipCounterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalUnregisterRelationshipCounterResponse
 */
export const ExperimentalUnregisterRelationshipCounterResponse = new ExperimentalUnregisterRelationshipCounterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkCheckPermissionRequest$Type extends MessageType<BulkCheckPermissionRequest> {
    constructor() {
        super("authzed.api.v1.BulkCheckPermissionRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BulkCheckPermissionRequestItem, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<BulkCheckPermissionRequest>): BulkCheckPermissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<BulkCheckPermissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkCheckPermissionRequest): BulkCheckPermissionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* repeated authzed.api.v1.BulkCheckPermissionRequestItem items = 2 [deprecated = true];*/ 2:
                    message.items.push(BulkCheckPermissionRequestItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkCheckPermissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.BulkCheckPermissionRequestItem items = 2 [deprecated = true]; */
        for (let i = 0; i < message.items.length; i++)
            BulkCheckPermissionRequestItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkCheckPermissionRequest
 */
export const BulkCheckPermissionRequest = new BulkCheckPermissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkCheckPermissionRequestItem$Type extends MessageType<BulkCheckPermissionRequestItem> {
    constructor() {
        super("authzed.api.v1.BulkCheckPermissionRequestItem", [
            { no: 1, name: "resource", kind: "message", T: () => ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 3, name: "subject", kind: "message", T: () => SubjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "context", kind: "message", T: () => Struct, options: { "validate.rules": { message: { required: false } } } }
        ]);
    }
    create(value?: PartialMessage<BulkCheckPermissionRequestItem>): BulkCheckPermissionRequestItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permission = "";
        if (value !== undefined)
            reflectionMergePartial<BulkCheckPermissionRequestItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkCheckPermissionRequestItem): BulkCheckPermissionRequestItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ObjectReference resource */ 1:
                    message.resource = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 2:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 3:
                    message.subject = SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* google.protobuf.Struct context */ 4:
                    message.context = Struct.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkCheckPermissionRequestItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ObjectReference resource = 1; */
        if (message.resource)
            ObjectReference.internalBinaryWrite(message.resource, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 2; */
        if (message.permission !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 3; */
        if (message.subject)
            SubjectReference.internalBinaryWrite(message.subject, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct context = 4; */
        if (message.context)
            Struct.internalBinaryWrite(message.context, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkCheckPermissionRequestItem
 */
export const BulkCheckPermissionRequestItem = new BulkCheckPermissionRequestItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkCheckPermissionResponse$Type extends MessageType<BulkCheckPermissionResponse> {
    constructor() {
        super("authzed.api.v1.BulkCheckPermissionResponse", [
            { no: 1, name: "checked_at", kind: "message", T: () => ZedToken, options: { "validate.rules": { message: { required: false } } } },
            { no: 2, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BulkCheckPermissionPair, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<BulkCheckPermissionResponse>): BulkCheckPermissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pairs = [];
        if (value !== undefined)
            reflectionMergePartial<BulkCheckPermissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkCheckPermissionResponse): BulkCheckPermissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken checked_at */ 1:
                    message.checkedAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.checkedAt);
                    break;
                case /* repeated authzed.api.v1.BulkCheckPermissionPair pairs */ 2:
                    message.pairs.push(BulkCheckPermissionPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkCheckPermissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken checked_at = 1; */
        if (message.checkedAt)
            ZedToken.internalBinaryWrite(message.checkedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.BulkCheckPermissionPair pairs = 2; */
        for (let i = 0; i < message.pairs.length; i++)
            BulkCheckPermissionPair.internalBinaryWrite(message.pairs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkCheckPermissionResponse
 */
export const BulkCheckPermissionResponse = new BulkCheckPermissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkCheckPermissionPair$Type extends MessageType<BulkCheckPermissionPair> {
    constructor() {
        super("authzed.api.v1.BulkCheckPermissionPair", [
            { no: 1, name: "request", kind: "message", T: () => BulkCheckPermissionRequestItem },
            { no: 2, name: "item", kind: "message", oneof: "response", T: () => BulkCheckPermissionResponseItem },
            { no: 3, name: "error", kind: "message", oneof: "response", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<BulkCheckPermissionPair>): BulkCheckPermissionPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<BulkCheckPermissionPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkCheckPermissionPair): BulkCheckPermissionPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.BulkCheckPermissionRequestItem request */ 1:
                    message.request = BulkCheckPermissionRequestItem.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* authzed.api.v1.BulkCheckPermissionResponseItem item */ 2:
                    message.response = {
                        oneofKind: "item",
                        item: BulkCheckPermissionResponseItem.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).item)
                    };
                    break;
                case /* google.rpc.Status error */ 3:
                    message.response = {
                        oneofKind: "error",
                        error: Status.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkCheckPermissionPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.BulkCheckPermissionRequestItem request = 1; */
        if (message.request)
            BulkCheckPermissionRequestItem.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.BulkCheckPermissionResponseItem item = 2; */
        if (message.response.oneofKind === "item")
            BulkCheckPermissionResponseItem.internalBinaryWrite(message.response.item, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status error = 3; */
        if (message.response.oneofKind === "error")
            Status.internalBinaryWrite(message.response.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkCheckPermissionPair
 */
export const BulkCheckPermissionPair = new BulkCheckPermissionPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkCheckPermissionResponseItem$Type extends MessageType<BulkCheckPermissionResponseItem> {
    constructor() {
        super("authzed.api.v1.BulkCheckPermissionResponseItem", [
            { no: 1, name: "permissionship", kind: "enum", T: () => ["authzed.api.v1.CheckPermissionResponse.Permissionship", CheckPermissionResponse_Permissionship, "PERMISSIONSHIP_"], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 2, name: "partial_caveat_info", kind: "message", T: () => PartialCaveatInfo, options: { "validate.rules": { message: { required: false } } } }
        ]);
    }
    create(value?: PartialMessage<BulkCheckPermissionResponseItem>): BulkCheckPermissionResponseItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissionship = 0;
        if (value !== undefined)
            reflectionMergePartial<BulkCheckPermissionResponseItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkCheckPermissionResponseItem): BulkCheckPermissionResponseItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship */ 1:
                    message.permissionship = reader.int32();
                    break;
                case /* authzed.api.v1.PartialCaveatInfo partial_caveat_info */ 2:
                    message.partialCaveatInfo = PartialCaveatInfo.internalBinaryRead(reader, reader.uint32(), options, message.partialCaveatInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkCheckPermissionResponseItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 1; */
        if (message.permissionship !== 0)
            writer.tag(1, WireType.Varint).int32(message.permissionship);
        /* authzed.api.v1.PartialCaveatInfo partial_caveat_info = 2; */
        if (message.partialCaveatInfo)
            PartialCaveatInfo.internalBinaryWrite(message.partialCaveatInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkCheckPermissionResponseItem
 */
export const BulkCheckPermissionResponseItem = new BulkCheckPermissionResponseItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkImportRelationshipsRequest$Type extends MessageType<BulkImportRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.BulkImportRelationshipsRequest", [
            { no: 1, name: "relationships", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Relationship, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<BulkImportRelationshipsRequest>): BulkImportRelationshipsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relationships = [];
        if (value !== undefined)
            reflectionMergePartial<BulkImportRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkImportRelationshipsRequest): BulkImportRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.Relationship relationships */ 1:
                    message.relationships.push(Relationship.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkImportRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v1.Relationship relationships = 1; */
        for (let i = 0; i < message.relationships.length; i++)
            Relationship.internalBinaryWrite(message.relationships[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkImportRelationshipsRequest
 */
export const BulkImportRelationshipsRequest = new BulkImportRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkImportRelationshipsResponse$Type extends MessageType<BulkImportRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.BulkImportRelationshipsResponse", [
            { no: 1, name: "num_loaded", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<BulkImportRelationshipsResponse>): BulkImportRelationshipsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numLoaded = "0";
        if (value !== undefined)
            reflectionMergePartial<BulkImportRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkImportRelationshipsResponse): BulkImportRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 num_loaded */ 1:
                    message.numLoaded = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkImportRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 num_loaded = 1; */
        if (message.numLoaded !== "0")
            writer.tag(1, WireType.Varint).uint64(message.numLoaded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkImportRelationshipsResponse
 */
export const BulkImportRelationshipsResponse = new BulkImportRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkExportRelationshipsRequest$Type extends MessageType<BulkExportRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.BulkExportRelationshipsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "optional_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 3, name: "optional_cursor", kind: "message", T: () => Cursor },
            { no: 4, name: "optional_relationship_filter", kind: "message", T: () => RelationshipFilter }
        ]);
    }
    create(value?: PartialMessage<BulkExportRelationshipsRequest>): BulkExportRelationshipsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.optionalLimit = 0;
        if (value !== undefined)
            reflectionMergePartial<BulkExportRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkExportRelationshipsRequest): BulkExportRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* uint32 optional_limit */ 2:
                    message.optionalLimit = reader.uint32();
                    break;
                case /* authzed.api.v1.Cursor optional_cursor */ 3:
                    message.optionalCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.optionalCursor);
                    break;
                case /* authzed.api.v1.RelationshipFilter optional_relationship_filter */ 4:
                    message.optionalRelationshipFilter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.optionalRelationshipFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkExportRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 optional_limit = 2; */
        if (message.optionalLimit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.optionalLimit);
        /* authzed.api.v1.Cursor optional_cursor = 3; */
        if (message.optionalCursor)
            Cursor.internalBinaryWrite(message.optionalCursor, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.RelationshipFilter optional_relationship_filter = 4; */
        if (message.optionalRelationshipFilter)
            RelationshipFilter.internalBinaryWrite(message.optionalRelationshipFilter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkExportRelationshipsRequest
 */
export const BulkExportRelationshipsRequest = new BulkExportRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkExportRelationshipsResponse$Type extends MessageType<BulkExportRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.BulkExportRelationshipsResponse", [
            { no: 1, name: "after_result_cursor", kind: "message", T: () => Cursor },
            { no: 2, name: "relationships", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Relationship }
        ]);
    }
    create(value?: PartialMessage<BulkExportRelationshipsResponse>): BulkExportRelationshipsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relationships = [];
        if (value !== undefined)
            reflectionMergePartial<BulkExportRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkExportRelationshipsResponse): BulkExportRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Cursor after_result_cursor */ 1:
                    message.afterResultCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.afterResultCursor);
                    break;
                case /* repeated authzed.api.v1.Relationship relationships */ 2:
                    message.relationships.push(Relationship.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkExportRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Cursor after_result_cursor = 1; */
        if (message.afterResultCursor)
            Cursor.internalBinaryWrite(message.afterResultCursor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.Relationship relationships = 2; */
        for (let i = 0; i < message.relationships.length; i++)
            Relationship.internalBinaryWrite(message.relationships[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.BulkExportRelationshipsResponse
 */
export const BulkExportRelationshipsResponse = new BulkExportRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalReflectSchemaRequest$Type extends MessageType<ExperimentalReflectSchemaRequest> {
    constructor() {
        super("authzed.api.v1.ExperimentalReflectSchemaRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "optional_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpSchemaFilter }
        ]);
    }
    create(value?: PartialMessage<ExperimentalReflectSchemaRequest>): ExperimentalReflectSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.optionalFilters = [];
        if (value !== undefined)
            reflectionMergePartial<ExperimentalReflectSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalReflectSchemaRequest): ExperimentalReflectSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* repeated authzed.api.v1.ExpSchemaFilter optional_filters */ 2:
                    message.optionalFilters.push(ExpSchemaFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalReflectSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.ExpSchemaFilter optional_filters = 2; */
        for (let i = 0; i < message.optionalFilters.length; i++)
            ExpSchemaFilter.internalBinaryWrite(message.optionalFilters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalReflectSchemaRequest
 */
export const ExperimentalReflectSchemaRequest = new ExperimentalReflectSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalReflectSchemaResponse$Type extends MessageType<ExperimentalReflectSchemaResponse> {
    constructor() {
        super("authzed.api.v1.ExperimentalReflectSchemaResponse", [
            { no: 1, name: "definitions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpDefinition },
            { no: 2, name: "caveats", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpCaveat },
            { no: 3, name: "read_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<ExperimentalReflectSchemaResponse>): ExperimentalReflectSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.definitions = [];
        message.caveats = [];
        if (value !== undefined)
            reflectionMergePartial<ExperimentalReflectSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalReflectSchemaResponse): ExperimentalReflectSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.ExpDefinition definitions */ 1:
                    message.definitions.push(ExpDefinition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated authzed.api.v1.ExpCaveat caveats */ 2:
                    message.caveats.push(ExpCaveat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* authzed.api.v1.ZedToken read_at */ 3:
                    message.readAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalReflectSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v1.ExpDefinition definitions = 1; */
        for (let i = 0; i < message.definitions.length; i++)
            ExpDefinition.internalBinaryWrite(message.definitions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.ExpCaveat caveats = 2; */
        for (let i = 0; i < message.caveats.length; i++)
            ExpCaveat.internalBinaryWrite(message.caveats[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken read_at = 3; */
        if (message.readAt)
            ZedToken.internalBinaryWrite(message.readAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalReflectSchemaResponse
 */
export const ExperimentalReflectSchemaResponse = new ExperimentalReflectSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpSchemaFilter$Type extends MessageType<ExpSchemaFilter> {
    constructor() {
        super("authzed.api.v1.ExpSchemaFilter", [
            { no: 1, name: "optional_definition_name_filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "optional_caveat_name_filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "optional_relation_name_filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "optional_permission_name_filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpSchemaFilter>): ExpSchemaFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.optionalDefinitionNameFilter = "";
        message.optionalCaveatNameFilter = "";
        message.optionalRelationNameFilter = "";
        message.optionalPermissionNameFilter = "";
        if (value !== undefined)
            reflectionMergePartial<ExpSchemaFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpSchemaFilter): ExpSchemaFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string optional_definition_name_filter */ 1:
                    message.optionalDefinitionNameFilter = reader.string();
                    break;
                case /* string optional_caveat_name_filter */ 2:
                    message.optionalCaveatNameFilter = reader.string();
                    break;
                case /* string optional_relation_name_filter */ 3:
                    message.optionalRelationNameFilter = reader.string();
                    break;
                case /* string optional_permission_name_filter */ 4:
                    message.optionalPermissionNameFilter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpSchemaFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string optional_definition_name_filter = 1; */
        if (message.optionalDefinitionNameFilter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.optionalDefinitionNameFilter);
        /* string optional_caveat_name_filter = 2; */
        if (message.optionalCaveatNameFilter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.optionalCaveatNameFilter);
        /* string optional_relation_name_filter = 3; */
        if (message.optionalRelationNameFilter !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.optionalRelationNameFilter);
        /* string optional_permission_name_filter = 4; */
        if (message.optionalPermissionNameFilter !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.optionalPermissionNameFilter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpSchemaFilter
 */
export const ExpSchemaFilter = new ExpSchemaFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpDefinition$Type extends MessageType<ExpDefinition> {
    constructor() {
        super("authzed.api.v1.ExpDefinition", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "relations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpRelation },
            { no: 4, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpPermission }
        ]);
    }
    create(value?: PartialMessage<ExpDefinition>): ExpDefinition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.comment = "";
        message.relations = [];
        message.permissions = [];
        if (value !== undefined)
            reflectionMergePartial<ExpDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpDefinition): ExpDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string comment */ 2:
                    message.comment = reader.string();
                    break;
                case /* repeated authzed.api.v1.ExpRelation relations */ 3:
                    message.relations.push(ExpRelation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated authzed.api.v1.ExpPermission permissions */ 4:
                    message.permissions.push(ExpPermission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string comment = 2; */
        if (message.comment !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.comment);
        /* repeated authzed.api.v1.ExpRelation relations = 3; */
        for (let i = 0; i < message.relations.length; i++)
            ExpRelation.internalBinaryWrite(message.relations[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.ExpPermission permissions = 4; */
        for (let i = 0; i < message.permissions.length; i++)
            ExpPermission.internalBinaryWrite(message.permissions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpDefinition
 */
export const ExpDefinition = new ExpDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpCaveat$Type extends MessageType<ExpCaveat> {
    constructor() {
        super("authzed.api.v1.ExpCaveat", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpCaveatParameter },
            { no: 4, name: "expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpCaveat>): ExpCaveat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.comment = "";
        message.parameters = [];
        message.expression = "";
        if (value !== undefined)
            reflectionMergePartial<ExpCaveat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpCaveat): ExpCaveat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string comment */ 2:
                    message.comment = reader.string();
                    break;
                case /* repeated authzed.api.v1.ExpCaveatParameter parameters */ 3:
                    message.parameters.push(ExpCaveatParameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string expression */ 4:
                    message.expression = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpCaveat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string comment = 2; */
        if (message.comment !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.comment);
        /* repeated authzed.api.v1.ExpCaveatParameter parameters = 3; */
        for (let i = 0; i < message.parameters.length; i++)
            ExpCaveatParameter.internalBinaryWrite(message.parameters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string expression = 4; */
        if (message.expression !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.expression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpCaveat
 */
export const ExpCaveat = new ExpCaveat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpCaveatParameter$Type extends MessageType<ExpCaveatParameter> {
    constructor() {
        super("authzed.api.v1.ExpCaveatParameter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parent_caveat_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpCaveatParameter>): ExpCaveatParameter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.type = "";
        message.parentCaveatName = "";
        if (value !== undefined)
            reflectionMergePartial<ExpCaveatParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpCaveatParameter): ExpCaveatParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string parent_caveat_name */ 3:
                    message.parentCaveatName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpCaveatParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string parent_caveat_name = 3; */
        if (message.parentCaveatName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.parentCaveatName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpCaveatParameter
 */
export const ExpCaveatParameter = new ExpCaveatParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpRelation$Type extends MessageType<ExpRelation> {
    constructor() {
        super("authzed.api.v1.ExpRelation", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parent_definition_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subject_types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpTypeReference }
        ]);
    }
    create(value?: PartialMessage<ExpRelation>): ExpRelation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.comment = "";
        message.parentDefinitionName = "";
        message.subjectTypes = [];
        if (value !== undefined)
            reflectionMergePartial<ExpRelation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpRelation): ExpRelation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string comment */ 2:
                    message.comment = reader.string();
                    break;
                case /* string parent_definition_name */ 3:
                    message.parentDefinitionName = reader.string();
                    break;
                case /* repeated authzed.api.v1.ExpTypeReference subject_types */ 4:
                    message.subjectTypes.push(ExpTypeReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpRelation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string comment = 2; */
        if (message.comment !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.comment);
        /* string parent_definition_name = 3; */
        if (message.parentDefinitionName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.parentDefinitionName);
        /* repeated authzed.api.v1.ExpTypeReference subject_types = 4; */
        for (let i = 0; i < message.subjectTypes.length; i++)
            ExpTypeReference.internalBinaryWrite(message.subjectTypes[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpRelation
 */
export const ExpRelation = new ExpRelation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpTypeReference$Type extends MessageType<ExpTypeReference> {
    constructor() {
        super("authzed.api.v1.ExpTypeReference", [
            { no: 1, name: "subject_definition_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "optional_caveat_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_terminal_subject", kind: "scalar", oneof: "typeref", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "optional_relation_name", kind: "scalar", oneof: "typeref", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_public_wildcard", kind: "scalar", oneof: "typeref", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExpTypeReference>): ExpTypeReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subjectDefinitionName = "";
        message.optionalCaveatName = "";
        message.typeref = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ExpTypeReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpTypeReference): ExpTypeReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subject_definition_name */ 1:
                    message.subjectDefinitionName = reader.string();
                    break;
                case /* string optional_caveat_name */ 2:
                    message.optionalCaveatName = reader.string();
                    break;
                case /* bool is_terminal_subject */ 3:
                    message.typeref = {
                        oneofKind: "isTerminalSubject",
                        isTerminalSubject: reader.bool()
                    };
                    break;
                case /* string optional_relation_name */ 4:
                    message.typeref = {
                        oneofKind: "optionalRelationName",
                        optionalRelationName: reader.string()
                    };
                    break;
                case /* bool is_public_wildcard */ 5:
                    message.typeref = {
                        oneofKind: "isPublicWildcard",
                        isPublicWildcard: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpTypeReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subject_definition_name = 1; */
        if (message.subjectDefinitionName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subjectDefinitionName);
        /* string optional_caveat_name = 2; */
        if (message.optionalCaveatName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.optionalCaveatName);
        /* bool is_terminal_subject = 3; */
        if (message.typeref.oneofKind === "isTerminalSubject")
            writer.tag(3, WireType.Varint).bool(message.typeref.isTerminalSubject);
        /* string optional_relation_name = 4; */
        if (message.typeref.oneofKind === "optionalRelationName")
            writer.tag(4, WireType.LengthDelimited).string(message.typeref.optionalRelationName);
        /* bool is_public_wildcard = 5; */
        if (message.typeref.oneofKind === "isPublicWildcard")
            writer.tag(5, WireType.Varint).bool(message.typeref.isPublicWildcard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpTypeReference
 */
export const ExpTypeReference = new ExpTypeReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpPermission$Type extends MessageType<ExpPermission> {
    constructor() {
        super("authzed.api.v1.ExpPermission", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parent_definition_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpPermission>): ExpPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.comment = "";
        message.parentDefinitionName = "";
        if (value !== undefined)
            reflectionMergePartial<ExpPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpPermission): ExpPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string comment */ 2:
                    message.comment = reader.string();
                    break;
                case /* string parent_definition_name */ 3:
                    message.parentDefinitionName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string comment = 2; */
        if (message.comment !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.comment);
        /* string parent_definition_name = 3; */
        if (message.parentDefinitionName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.parentDefinitionName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpPermission
 */
export const ExpPermission = new ExpPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalComputablePermissionsRequest$Type extends MessageType<ExperimentalComputablePermissionsRequest> {
    constructor() {
        super("authzed.api.v1.ExperimentalComputablePermissionsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "definition_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "relation_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "optional_definition_name_filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExperimentalComputablePermissionsRequest>): ExperimentalComputablePermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.definitionName = "";
        message.relationName = "";
        message.optionalDefinitionNameFilter = "";
        if (value !== undefined)
            reflectionMergePartial<ExperimentalComputablePermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalComputablePermissionsRequest): ExperimentalComputablePermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* string definition_name */ 2:
                    message.definitionName = reader.string();
                    break;
                case /* string relation_name */ 3:
                    message.relationName = reader.string();
                    break;
                case /* string optional_definition_name_filter */ 4:
                    message.optionalDefinitionNameFilter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalComputablePermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string definition_name = 2; */
        if (message.definitionName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.definitionName);
        /* string relation_name = 3; */
        if (message.relationName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.relationName);
        /* string optional_definition_name_filter = 4; */
        if (message.optionalDefinitionNameFilter !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.optionalDefinitionNameFilter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalComputablePermissionsRequest
 */
export const ExperimentalComputablePermissionsRequest = new ExperimentalComputablePermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpRelationReference$Type extends MessageType<ExpRelationReference> {
    constructor() {
        super("authzed.api.v1.ExpRelationReference", [
            { no: 1, name: "definition_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_permission", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExpRelationReference>): ExpRelationReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.definitionName = "";
        message.relationName = "";
        message.isPermission = false;
        if (value !== undefined)
            reflectionMergePartial<ExpRelationReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpRelationReference): ExpRelationReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string definition_name */ 1:
                    message.definitionName = reader.string();
                    break;
                case /* string relation_name */ 2:
                    message.relationName = reader.string();
                    break;
                case /* bool is_permission */ 3:
                    message.isPermission = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpRelationReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string definition_name = 1; */
        if (message.definitionName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.definitionName);
        /* string relation_name = 2; */
        if (message.relationName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relationName);
        /* bool is_permission = 3; */
        if (message.isPermission !== false)
            writer.tag(3, WireType.Varint).bool(message.isPermission);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpRelationReference
 */
export const ExpRelationReference = new ExpRelationReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalComputablePermissionsResponse$Type extends MessageType<ExperimentalComputablePermissionsResponse> {
    constructor() {
        super("authzed.api.v1.ExperimentalComputablePermissionsResponse", [
            { no: 1, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpRelationReference },
            { no: 2, name: "read_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<ExperimentalComputablePermissionsResponse>): ExperimentalComputablePermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        if (value !== undefined)
            reflectionMergePartial<ExperimentalComputablePermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalComputablePermissionsResponse): ExperimentalComputablePermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.ExpRelationReference permissions */ 1:
                    message.permissions.push(ExpRelationReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* authzed.api.v1.ZedToken read_at */ 2:
                    message.readAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalComputablePermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v1.ExpRelationReference permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            ExpRelationReference.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken read_at = 2; */
        if (message.readAt)
            ZedToken.internalBinaryWrite(message.readAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalComputablePermissionsResponse
 */
export const ExperimentalComputablePermissionsResponse = new ExperimentalComputablePermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalDependentRelationsRequest$Type extends MessageType<ExperimentalDependentRelationsRequest> {
    constructor() {
        super("authzed.api.v1.ExperimentalDependentRelationsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "definition_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "permission_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExperimentalDependentRelationsRequest>): ExperimentalDependentRelationsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.definitionName = "";
        message.permissionName = "";
        if (value !== undefined)
            reflectionMergePartial<ExperimentalDependentRelationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalDependentRelationsRequest): ExperimentalDependentRelationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* string definition_name */ 2:
                    message.definitionName = reader.string();
                    break;
                case /* string permission_name */ 3:
                    message.permissionName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalDependentRelationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string definition_name = 2; */
        if (message.definitionName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.definitionName);
        /* string permission_name = 3; */
        if (message.permissionName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permissionName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalDependentRelationsRequest
 */
export const ExperimentalDependentRelationsRequest = new ExperimentalDependentRelationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalDependentRelationsResponse$Type extends MessageType<ExperimentalDependentRelationsResponse> {
    constructor() {
        super("authzed.api.v1.ExperimentalDependentRelationsResponse", [
            { no: 1, name: "relations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpRelationReference },
            { no: 2, name: "read_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<ExperimentalDependentRelationsResponse>): ExperimentalDependentRelationsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relations = [];
        if (value !== undefined)
            reflectionMergePartial<ExperimentalDependentRelationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalDependentRelationsResponse): ExperimentalDependentRelationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.ExpRelationReference relations */ 1:
                    message.relations.push(ExpRelationReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* authzed.api.v1.ZedToken read_at */ 2:
                    message.readAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalDependentRelationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v1.ExpRelationReference relations = 1; */
        for (let i = 0; i < message.relations.length; i++)
            ExpRelationReference.internalBinaryWrite(message.relations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken read_at = 2; */
        if (message.readAt)
            ZedToken.internalBinaryWrite(message.readAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalDependentRelationsResponse
 */
export const ExperimentalDependentRelationsResponse = new ExperimentalDependentRelationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalDiffSchemaRequest$Type extends MessageType<ExperimentalDiffSchemaRequest> {
    constructor() {
        super("authzed.api.v1.ExperimentalDiffSchemaRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "comparison_schema", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExperimentalDiffSchemaRequest>): ExperimentalDiffSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.comparisonSchema = "";
        if (value !== undefined)
            reflectionMergePartial<ExperimentalDiffSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalDiffSchemaRequest): ExperimentalDiffSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* string comparison_schema */ 2:
                    message.comparisonSchema = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalDiffSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string comparison_schema = 2; */
        if (message.comparisonSchema !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.comparisonSchema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalDiffSchemaRequest
 */
export const ExperimentalDiffSchemaRequest = new ExperimentalDiffSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentalDiffSchemaResponse$Type extends MessageType<ExperimentalDiffSchemaResponse> {
    constructor() {
        super("authzed.api.v1.ExperimentalDiffSchemaResponse", [
            { no: 1, name: "diffs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpSchemaDiff },
            { no: 2, name: "read_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<ExperimentalDiffSchemaResponse>): ExperimentalDiffSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.diffs = [];
        if (value !== undefined)
            reflectionMergePartial<ExperimentalDiffSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentalDiffSchemaResponse): ExperimentalDiffSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.ExpSchemaDiff diffs */ 1:
                    message.diffs.push(ExpSchemaDiff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* authzed.api.v1.ZedToken read_at */ 2:
                    message.readAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentalDiffSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v1.ExpSchemaDiff diffs = 1; */
        for (let i = 0; i < message.diffs.length; i++)
            ExpSchemaDiff.internalBinaryWrite(message.diffs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken read_at = 2; */
        if (message.readAt)
            ZedToken.internalBinaryWrite(message.readAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExperimentalDiffSchemaResponse
 */
export const ExperimentalDiffSchemaResponse = new ExperimentalDiffSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpRelationSubjectTypeChange$Type extends MessageType<ExpRelationSubjectTypeChange> {
    constructor() {
        super("authzed.api.v1.ExpRelationSubjectTypeChange", [
            { no: 1, name: "relation", kind: "message", T: () => ExpRelation },
            { no: 2, name: "changed_subject_type", kind: "message", T: () => ExpTypeReference }
        ]);
    }
    create(value?: PartialMessage<ExpRelationSubjectTypeChange>): ExpRelationSubjectTypeChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExpRelationSubjectTypeChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpRelationSubjectTypeChange): ExpRelationSubjectTypeChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ExpRelation relation */ 1:
                    message.relation = ExpRelation.internalBinaryRead(reader, reader.uint32(), options, message.relation);
                    break;
                case /* authzed.api.v1.ExpTypeReference changed_subject_type */ 2:
                    message.changedSubjectType = ExpTypeReference.internalBinaryRead(reader, reader.uint32(), options, message.changedSubjectType);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpRelationSubjectTypeChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ExpRelation relation = 1; */
        if (message.relation)
            ExpRelation.internalBinaryWrite(message.relation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpTypeReference changed_subject_type = 2; */
        if (message.changedSubjectType)
            ExpTypeReference.internalBinaryWrite(message.changedSubjectType, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpRelationSubjectTypeChange
 */
export const ExpRelationSubjectTypeChange = new ExpRelationSubjectTypeChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpCaveatParameterTypeChange$Type extends MessageType<ExpCaveatParameterTypeChange> {
    constructor() {
        super("authzed.api.v1.ExpCaveatParameterTypeChange", [
            { no: 1, name: "parameter", kind: "message", T: () => ExpCaveatParameter },
            { no: 2, name: "previous_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpCaveatParameterTypeChange>): ExpCaveatParameterTypeChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.previousType = "";
        if (value !== undefined)
            reflectionMergePartial<ExpCaveatParameterTypeChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpCaveatParameterTypeChange): ExpCaveatParameterTypeChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ExpCaveatParameter parameter */ 1:
                    message.parameter = ExpCaveatParameter.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                case /* string previous_type */ 2:
                    message.previousType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpCaveatParameterTypeChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ExpCaveatParameter parameter = 1; */
        if (message.parameter)
            ExpCaveatParameter.internalBinaryWrite(message.parameter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string previous_type = 2; */
        if (message.previousType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.previousType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpCaveatParameterTypeChange
 */
export const ExpCaveatParameterTypeChange = new ExpCaveatParameterTypeChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpSchemaDiff$Type extends MessageType<ExpSchemaDiff> {
    constructor() {
        super("authzed.api.v1.ExpSchemaDiff", [
            { no: 1, name: "definition_added", kind: "message", oneof: "diff", T: () => ExpDefinition },
            { no: 2, name: "definition_removed", kind: "message", oneof: "diff", T: () => ExpDefinition },
            { no: 3, name: "definition_doc_comment_changed", kind: "message", oneof: "diff", T: () => ExpDefinition },
            { no: 4, name: "relation_added", kind: "message", oneof: "diff", T: () => ExpRelation },
            { no: 5, name: "relation_removed", kind: "message", oneof: "diff", T: () => ExpRelation },
            { no: 6, name: "relation_doc_comment_changed", kind: "message", oneof: "diff", T: () => ExpRelation },
            { no: 7, name: "relation_subject_type_added", kind: "message", oneof: "diff", T: () => ExpRelationSubjectTypeChange },
            { no: 8, name: "relation_subject_type_removed", kind: "message", oneof: "diff", T: () => ExpRelationSubjectTypeChange },
            { no: 9, name: "permission_added", kind: "message", oneof: "diff", T: () => ExpPermission },
            { no: 10, name: "permission_removed", kind: "message", oneof: "diff", T: () => ExpPermission },
            { no: 11, name: "permission_doc_comment_changed", kind: "message", oneof: "diff", T: () => ExpPermission },
            { no: 12, name: "permission_expr_changed", kind: "message", oneof: "diff", T: () => ExpPermission },
            { no: 13, name: "caveat_added", kind: "message", oneof: "diff", T: () => ExpCaveat },
            { no: 14, name: "caveat_removed", kind: "message", oneof: "diff", T: () => ExpCaveat },
            { no: 15, name: "caveat_doc_comment_changed", kind: "message", oneof: "diff", T: () => ExpCaveat },
            { no: 16, name: "caveat_expr_changed", kind: "message", oneof: "diff", T: () => ExpCaveat },
            { no: 17, name: "caveat_parameter_added", kind: "message", oneof: "diff", T: () => ExpCaveatParameter },
            { no: 18, name: "caveat_parameter_removed", kind: "message", oneof: "diff", T: () => ExpCaveatParameter },
            { no: 19, name: "caveat_parameter_type_changed", kind: "message", oneof: "diff", T: () => ExpCaveatParameterTypeChange }
        ]);
    }
    create(value?: PartialMessage<ExpSchemaDiff>): ExpSchemaDiff {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.diff = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ExpSchemaDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpSchemaDiff): ExpSchemaDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ExpDefinition definition_added */ 1:
                    message.diff = {
                        oneofKind: "definitionAdded",
                        definitionAdded: ExpDefinition.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).definitionAdded)
                    };
                    break;
                case /* authzed.api.v1.ExpDefinition definition_removed */ 2:
                    message.diff = {
                        oneofKind: "definitionRemoved",
                        definitionRemoved: ExpDefinition.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).definitionRemoved)
                    };
                    break;
                case /* authzed.api.v1.ExpDefinition definition_doc_comment_changed */ 3:
                    message.diff = {
                        oneofKind: "definitionDocCommentChanged",
                        definitionDocCommentChanged: ExpDefinition.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).definitionDocCommentChanged)
                    };
                    break;
                case /* authzed.api.v1.ExpRelation relation_added */ 4:
                    message.diff = {
                        oneofKind: "relationAdded",
                        relationAdded: ExpRelation.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).relationAdded)
                    };
                    break;
                case /* authzed.api.v1.ExpRelation relation_removed */ 5:
                    message.diff = {
                        oneofKind: "relationRemoved",
                        relationRemoved: ExpRelation.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).relationRemoved)
                    };
                    break;
                case /* authzed.api.v1.ExpRelation relation_doc_comment_changed */ 6:
                    message.diff = {
                        oneofKind: "relationDocCommentChanged",
                        relationDocCommentChanged: ExpRelation.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).relationDocCommentChanged)
                    };
                    break;
                case /* authzed.api.v1.ExpRelationSubjectTypeChange relation_subject_type_added */ 7:
                    message.diff = {
                        oneofKind: "relationSubjectTypeAdded",
                        relationSubjectTypeAdded: ExpRelationSubjectTypeChange.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).relationSubjectTypeAdded)
                    };
                    break;
                case /* authzed.api.v1.ExpRelationSubjectTypeChange relation_subject_type_removed */ 8:
                    message.diff = {
                        oneofKind: "relationSubjectTypeRemoved",
                        relationSubjectTypeRemoved: ExpRelationSubjectTypeChange.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).relationSubjectTypeRemoved)
                    };
                    break;
                case /* authzed.api.v1.ExpPermission permission_added */ 9:
                    message.diff = {
                        oneofKind: "permissionAdded",
                        permissionAdded: ExpPermission.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).permissionAdded)
                    };
                    break;
                case /* authzed.api.v1.ExpPermission permission_removed */ 10:
                    message.diff = {
                        oneofKind: "permissionRemoved",
                        permissionRemoved: ExpPermission.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).permissionRemoved)
                    };
                    break;
                case /* authzed.api.v1.ExpPermission permission_doc_comment_changed */ 11:
                    message.diff = {
                        oneofKind: "permissionDocCommentChanged",
                        permissionDocCommentChanged: ExpPermission.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).permissionDocCommentChanged)
                    };
                    break;
                case /* authzed.api.v1.ExpPermission permission_expr_changed */ 12:
                    message.diff = {
                        oneofKind: "permissionExprChanged",
                        permissionExprChanged: ExpPermission.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).permissionExprChanged)
                    };
                    break;
                case /* authzed.api.v1.ExpCaveat caveat_added */ 13:
                    message.diff = {
                        oneofKind: "caveatAdded",
                        caveatAdded: ExpCaveat.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).caveatAdded)
                    };
                    break;
                case /* authzed.api.v1.ExpCaveat caveat_removed */ 14:
                    message.diff = {
                        oneofKind: "caveatRemoved",
                        caveatRemoved: ExpCaveat.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).caveatRemoved)
                    };
                    break;
                case /* authzed.api.v1.ExpCaveat caveat_doc_comment_changed */ 15:
                    message.diff = {
                        oneofKind: "caveatDocCommentChanged",
                        caveatDocCommentChanged: ExpCaveat.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).caveatDocCommentChanged)
                    };
                    break;
                case /* authzed.api.v1.ExpCaveat caveat_expr_changed */ 16:
                    message.diff = {
                        oneofKind: "caveatExprChanged",
                        caveatExprChanged: ExpCaveat.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).caveatExprChanged)
                    };
                    break;
                case /* authzed.api.v1.ExpCaveatParameter caveat_parameter_added */ 17:
                    message.diff = {
                        oneofKind: "caveatParameterAdded",
                        caveatParameterAdded: ExpCaveatParameter.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).caveatParameterAdded)
                    };
                    break;
                case /* authzed.api.v1.ExpCaveatParameter caveat_parameter_removed */ 18:
                    message.diff = {
                        oneofKind: "caveatParameterRemoved",
                        caveatParameterRemoved: ExpCaveatParameter.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).caveatParameterRemoved)
                    };
                    break;
                case /* authzed.api.v1.ExpCaveatParameterTypeChange caveat_parameter_type_changed */ 19:
                    message.diff = {
                        oneofKind: "caveatParameterTypeChanged",
                        caveatParameterTypeChanged: ExpCaveatParameterTypeChange.internalBinaryRead(reader, reader.uint32(), options, (message.diff as any).caveatParameterTypeChanged)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpSchemaDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ExpDefinition definition_added = 1; */
        if (message.diff.oneofKind === "definitionAdded")
            ExpDefinition.internalBinaryWrite(message.diff.definitionAdded, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpDefinition definition_removed = 2; */
        if (message.diff.oneofKind === "definitionRemoved")
            ExpDefinition.internalBinaryWrite(message.diff.definitionRemoved, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpDefinition definition_doc_comment_changed = 3; */
        if (message.diff.oneofKind === "definitionDocCommentChanged")
            ExpDefinition.internalBinaryWrite(message.diff.definitionDocCommentChanged, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpRelation relation_added = 4; */
        if (message.diff.oneofKind === "relationAdded")
            ExpRelation.internalBinaryWrite(message.diff.relationAdded, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpRelation relation_removed = 5; */
        if (message.diff.oneofKind === "relationRemoved")
            ExpRelation.internalBinaryWrite(message.diff.relationRemoved, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpRelation relation_doc_comment_changed = 6; */
        if (message.diff.oneofKind === "relationDocCommentChanged")
            ExpRelation.internalBinaryWrite(message.diff.relationDocCommentChanged, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpRelationSubjectTypeChange relation_subject_type_added = 7; */
        if (message.diff.oneofKind === "relationSubjectTypeAdded")
            ExpRelationSubjectTypeChange.internalBinaryWrite(message.diff.relationSubjectTypeAdded, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpRelationSubjectTypeChange relation_subject_type_removed = 8; */
        if (message.diff.oneofKind === "relationSubjectTypeRemoved")
            ExpRelationSubjectTypeChange.internalBinaryWrite(message.diff.relationSubjectTypeRemoved, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpPermission permission_added = 9; */
        if (message.diff.oneofKind === "permissionAdded")
            ExpPermission.internalBinaryWrite(message.diff.permissionAdded, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpPermission permission_removed = 10; */
        if (message.diff.oneofKind === "permissionRemoved")
            ExpPermission.internalBinaryWrite(message.diff.permissionRemoved, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpPermission permission_doc_comment_changed = 11; */
        if (message.diff.oneofKind === "permissionDocCommentChanged")
            ExpPermission.internalBinaryWrite(message.diff.permissionDocCommentChanged, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpPermission permission_expr_changed = 12; */
        if (message.diff.oneofKind === "permissionExprChanged")
            ExpPermission.internalBinaryWrite(message.diff.permissionExprChanged, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpCaveat caveat_added = 13; */
        if (message.diff.oneofKind === "caveatAdded")
            ExpCaveat.internalBinaryWrite(message.diff.caveatAdded, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpCaveat caveat_removed = 14; */
        if (message.diff.oneofKind === "caveatRemoved")
            ExpCaveat.internalBinaryWrite(message.diff.caveatRemoved, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpCaveat caveat_doc_comment_changed = 15; */
        if (message.diff.oneofKind === "caveatDocCommentChanged")
            ExpCaveat.internalBinaryWrite(message.diff.caveatDocCommentChanged, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpCaveat caveat_expr_changed = 16; */
        if (message.diff.oneofKind === "caveatExprChanged")
            ExpCaveat.internalBinaryWrite(message.diff.caveatExprChanged, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpCaveatParameter caveat_parameter_added = 17; */
        if (message.diff.oneofKind === "caveatParameterAdded")
            ExpCaveatParameter.internalBinaryWrite(message.diff.caveatParameterAdded, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpCaveatParameter caveat_parameter_removed = 18; */
        if (message.diff.oneofKind === "caveatParameterRemoved")
            ExpCaveatParameter.internalBinaryWrite(message.diff.caveatParameterRemoved, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ExpCaveatParameterTypeChange caveat_parameter_type_changed = 19; */
        if (message.diff.oneofKind === "caveatParameterTypeChanged")
            ExpCaveatParameterTypeChange.internalBinaryWrite(message.diff.caveatParameterTypeChanged, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpSchemaDiff
 */
export const ExpSchemaDiff = new ExpSchemaDiff$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.v1.ExperimentalService
 */
export const ExperimentalService = new ServiceType("authzed.api.v1.ExperimentalService", [
    { name: "BulkImportRelationships", clientStreaming: true, options: { "google.api.http": { post: "/v1/experimental/relationships/bulkimport", body: "*" } }, I: BulkImportRelationshipsRequest, O: BulkImportRelationshipsResponse },
    { name: "BulkExportRelationships", serverStreaming: true, options: { "google.api.http": { post: "/v1/experimental/relationships/bulkexport", body: "*" } }, I: BulkExportRelationshipsRequest, O: BulkExportRelationshipsResponse },
    { name: "BulkCheckPermission", options: { "google.api.http": { post: "/v1/experimental/permissions/bulkcheckpermission", body: "*" } }, I: BulkCheckPermissionRequest, O: BulkCheckPermissionResponse },
    { name: "ExperimentalReflectSchema", options: { "google.api.http": { post: "/v1/experimental/reflectschema", body: "*" } }, I: ExperimentalReflectSchemaRequest, O: ExperimentalReflectSchemaResponse },
    { name: "ExperimentalComputablePermissions", options: { "google.api.http": { post: "/v1/experimental/permissions/computable", body: "*" } }, I: ExperimentalComputablePermissionsRequest, O: ExperimentalComputablePermissionsResponse },
    { name: "ExperimentalDependentRelations", options: { "google.api.http": { post: "/v1/experimental/permissions/dependent", body: "*" } }, I: ExperimentalDependentRelationsRequest, O: ExperimentalDependentRelationsResponse },
    { name: "ExperimentalDiffSchema", options: { "google.api.http": { post: "/v1/experimental/diffschema", body: "*" } }, I: ExperimentalDiffSchemaRequest, O: ExperimentalDiffSchemaResponse },
    { name: "ExperimentalRegisterRelationshipCounter", options: { "google.api.http": { post: "/v1/experimental/registerrelationshipcounter", body: "*" } }, I: ExperimentalRegisterRelationshipCounterRequest, O: ExperimentalRegisterRelationshipCounterResponse },
    { name: "ExperimentalCountRelationships", options: { "google.api.http": { post: "/v1/experimental/countrelationships", body: "*" } }, I: ExperimentalCountRelationshipsRequest, O: ExperimentalCountRelationshipsResponse },
    { name: "ExperimentalUnregisterRelationshipCounter", options: { "google.api.http": { post: "/v1/experimental/unregisterrelationshipcounter", body: "*" } }, I: ExperimentalUnregisterRelationshipCounterRequest, O: ExperimentalUnregisterRelationshipCounterResponse }
]);
