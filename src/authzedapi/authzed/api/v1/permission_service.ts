// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "authzed/api/v1/permission_service.proto" (package "authzed.api.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PermissionRelationshipTree } from "./core.js";
import { Status } from "../../../google/rpc/status";
import { DebugInformation } from "./debug.js";
import { PartialCaveatInfo } from "./core.js";
import { SubjectReference } from "./core.js";
import { ObjectReference } from "./core.js";
import { Struct } from "../../../google/protobuf/struct";
import { RelationshipUpdate } from "./core.js";
import { Relationship } from "./core.js";
import { Cursor } from "./core.js";
import { ZedToken } from "./core.js";
/**
 * Consistency will define how a request is handled by the backend.
 * By defining a consistency requirement, and a token at which those
 * requirements should be applied, where applicable.
 *
 * @generated from protobuf message authzed.api.v1.Consistency
 */
export interface Consistency {
    /**
     * @generated from protobuf oneof: requirement
     */
    requirement: {
        oneofKind: "minimizeLatency";
        /**
         * minimize_latency indicates that the latency for the call should be
         * minimized by having the system select the fastest snapshot available.
         *
         * @generated from protobuf field: bool minimize_latency = 1;
         */
        minimizeLatency: boolean;
    } | {
        oneofKind: "atLeastAsFresh";
        /**
         * at_least_as_fresh indicates that all data used in the API call must be
         * *at least as fresh* as that found in the ZedToken; more recent data might
         * be used if available or faster.
         *
         * @generated from protobuf field: authzed.api.v1.ZedToken at_least_as_fresh = 2;
         */
        atLeastAsFresh: ZedToken;
    } | {
        oneofKind: "atExactSnapshot";
        /**
         * at_exact_snapshot indicates that all data used in the API call must be
         * *at the given* snapshot in time; if the snapshot is no longer available,
         * an error will be returned to the caller.
         *
         * @generated from protobuf field: authzed.api.v1.ZedToken at_exact_snapshot = 3;
         */
        atExactSnapshot: ZedToken;
    } | {
        oneofKind: "fullyConsistent";
        /**
         * fully_consistent indicates that all data used in the API call *must* be
         * at the most recent snapshot found.
         *
         * NOTE: using this method can be *quite slow*, so unless there is a need to
         * do so, it is recommended to use `at_least_as_fresh` with a stored
         * ZedToken.
         *
         * @generated from protobuf field: bool fully_consistent = 4;
         */
        fullyConsistent: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * RelationshipFilter is a collection of filters which when applied to a
 * relationship will return relationships that have exactly matching fields.
 *
 * All fields are optional and if left unspecified will not filter relationships,
 * but at least one field must be specified.
 *
 * NOTE: The performance of the API will be affected by the selection of fields
 * on which to filter. If a field is not indexed, the performance of the API
 * can be significantly slower.
 *
 * @generated from protobuf message authzed.api.v1.RelationshipFilter
 */
export interface RelationshipFilter {
    /**
     * resource_type is the *optional* resource type of the relationship.
     * NOTE: It is not prefixed with "optional_" for legacy compatibility.
     *
     * @generated from protobuf field: string resource_type = 1;
     */
    resourceType: string;
    /**
     * optional_resource_id is the *optional* resource ID of the relationship.
     * If specified, optional_resource_id_prefix cannot be specified.
     *
     * @generated from protobuf field: string optional_resource_id = 2;
     */
    optionalResourceId: string;
    /**
     * optional_resource_id_prefix is the *optional* prefix for the resource ID of the relationship.
     * If specified, optional_resource_id cannot be specified.
     *
     * @generated from protobuf field: string optional_resource_id_prefix = 5;
     */
    optionalResourceIdPrefix: string;
    /**
     * relation is the *optional* relation of the relationship.
     *
     * @generated from protobuf field: string optional_relation = 3;
     */
    optionalRelation: string;
    /**
     * optional_subject_filter is the optional filter for the subjects of the relationships.
     *
     * @generated from protobuf field: authzed.api.v1.SubjectFilter optional_subject_filter = 4;
     */
    optionalSubjectFilter?: SubjectFilter;
}
/**
 * SubjectFilter specifies a filter on the subject of a relationship.
 *
 * subject_type is required and all other fields are optional, and will not
 * impose any additional requirements if left unspecified.
 *
 * @generated from protobuf message authzed.api.v1.SubjectFilter
 */
export interface SubjectFilter {
    /**
     * @generated from protobuf field: string subject_type = 1;
     */
    subjectType: string;
    /**
     * @generated from protobuf field: string optional_subject_id = 2;
     */
    optionalSubjectId: string;
    /**
     * @generated from protobuf field: authzed.api.v1.SubjectFilter.RelationFilter optional_relation = 3;
     */
    optionalRelation?: SubjectFilter_RelationFilter;
}
/**
 * @generated from protobuf message authzed.api.v1.SubjectFilter.RelationFilter
 */
export interface SubjectFilter_RelationFilter {
    /**
     * @generated from protobuf field: string relation = 1;
     */
    relation: string;
}
/**
 * ReadRelationshipsRequest specifies one or more filters used to read matching
 * relationships within the system.
 *
 * @generated from protobuf message authzed.api.v1.ReadRelationshipsRequest
 */
export interface ReadRelationshipsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * relationship_filter defines the filter to be applied to the relationships
     * to be returned.
     *
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter relationship_filter = 2;
     */
    relationshipFilter?: RelationshipFilter;
    /**
     * optional_limit, if non-zero, specifies the limit on the number of relationships to return
     * before the stream is closed on the server side. By default, the stream will continue
     * resolving relationships until exhausted or the stream is closed due to the client or a
     * network issue.
     *
     * @generated from protobuf field: uint32 optional_limit = 3;
     */
    optionalLimit: number;
    /**
     * optional_cursor, if specified, indicates the cursor after which results should resume being returned.
     * The cursor can be found on the ReadRelationshipsResponse object.
     *
     * @generated from protobuf field: authzed.api.v1.Cursor optional_cursor = 4;
     */
    optionalCursor?: Cursor;
}
/**
 * ReadRelationshipsResponse contains a Relationship found that matches the
 * specified relationship filter(s). A instance of this response message will
 * be streamed to the client for each relationship found.
 *
 * @generated from protobuf message authzed.api.v1.ReadRelationshipsResponse
 */
export interface ReadRelationshipsResponse {
    /**
     * read_at is the ZedToken at which the relationship was found.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken read_at = 1;
     */
    readAt?: ZedToken;
    /**
     * relationship is the found relationship.
     *
     * @generated from protobuf field: authzed.api.v1.Relationship relationship = 2;
     */
    relationship?: Relationship;
    /**
     * after_result_cursor holds a cursor that can be used to resume the ReadRelationships stream after this
     * result.
     *
     * @generated from protobuf field: authzed.api.v1.Cursor after_result_cursor = 3;
     */
    afterResultCursor?: Cursor;
}
/**
 * Precondition specifies how and the existence or absence of certain
 * relationships as expressed through the accompanying filter should affect
 * whether or not the operation proceeds.
 *
 * MUST_NOT_MATCH will fail the parent request if any relationships match the
 * relationships filter.
 * MUST_MATCH will fail the parent request if there are no
 * relationships that match the filter.
 *
 * @generated from protobuf message authzed.api.v1.Precondition
 */
export interface Precondition {
    /**
     * @generated from protobuf field: authzed.api.v1.Precondition.Operation operation = 1;
     */
    operation: Precondition_Operation;
    /**
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter filter = 2;
     */
    filter?: RelationshipFilter;
}
/**
 * @generated from protobuf enum authzed.api.v1.Precondition.Operation
 */
export enum Precondition_Operation {
    /**
     * @generated from protobuf enum value: OPERATION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: OPERATION_MUST_NOT_MATCH = 1;
     */
    MUST_NOT_MATCH = 1,
    /**
     * @generated from protobuf enum value: OPERATION_MUST_MATCH = 2;
     */
    MUST_MATCH = 2
}
/**
 * WriteRelationshipsRequest contains a list of Relationship mutations that
 * should be applied to the service. If the optional_preconditions parameter
 * is included, all of the specified preconditions must also be satisfied before
 * the write will be committed. All updates will be applied transactionally,
 * and if any preconditions fail, the entire transaction will be reverted.
 *
 * @generated from protobuf message authzed.api.v1.WriteRelationshipsRequest
 */
export interface WriteRelationshipsRequest {
    /**
     * @generated from protobuf field: repeated authzed.api.v1.RelationshipUpdate updates = 1;
     */
    updates: RelationshipUpdate[];
    /**
     * @generated from protobuf field: repeated authzed.api.v1.Precondition optional_preconditions = 2;
     */
    optionalPreconditions: Precondition[]; // To be bounded by configuration
    /**
     * optional_transaction_metadata is an optional field that can be used to store metadata about the transaction.
     * If specified, this metadata will be supplied in the WatchResponse for the updates associated with this
     * transaction.
     *
     * @generated from protobuf field: google.protobuf.Struct optional_transaction_metadata = 3;
     */
    optionalTransactionMetadata?: Struct;
}
/**
 * @generated from protobuf message authzed.api.v1.WriteRelationshipsResponse
 */
export interface WriteRelationshipsResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken written_at = 1;
     */
    writtenAt?: ZedToken;
}
/**
 * DeleteRelationshipsRequest specifies which Relationships should be deleted,
 * requesting the delete of *ALL* relationships that match the specified
 * filters. If the optional_preconditions parameter is included, all of the
 * specified preconditions must also be satisfied before the delete will be
 * executed.
 *
 * @generated from protobuf message authzed.api.v1.DeleteRelationshipsRequest
 */
export interface DeleteRelationshipsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter relationship_filter = 1;
     */
    relationshipFilter?: RelationshipFilter;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.Precondition optional_preconditions = 2;
     */
    optionalPreconditions: Precondition[]; // To be bounded by configuration
    /**
     * optional_limit, if non-zero, specifies the limit on the number of relationships to be deleted.
     * If there are more matching relationships found to be deleted than the limit specified here,
     * the deletion call will fail with an error to prevent partial deletion. If partial deletion
     * is needed, specify below that partial deletion is allowed. Partial deletions can be used
     * in a loop to delete large amounts of relationships in a *non-transactional* manner.
     *
     * @generated from protobuf field: uint32 optional_limit = 3;
     */
    optionalLimit: number;
    /**
     * optional_allow_partial_deletions, if true and a limit is specified, will delete matching found
     * relationships up to the count specified in optional_limit, and no more.
     *
     * @generated from protobuf field: bool optional_allow_partial_deletions = 4;
     */
    optionalAllowPartialDeletions: boolean;
    /**
     * optional_transaction_metadata is an optional field that can be used to store metadata about the transaction.
     * If specified, this metadata will be supplied in the WatchResponse for the deletions associated with
     * this transaction.
     *
     * @generated from protobuf field: google.protobuf.Struct optional_transaction_metadata = 5;
     */
    optionalTransactionMetadata?: Struct;
}
/**
 * @generated from protobuf message authzed.api.v1.DeleteRelationshipsResponse
 */
export interface DeleteRelationshipsResponse {
    /**
     * deleted_at is the revision at which the relationships were deleted.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken deleted_at = 1;
     */
    deletedAt?: ZedToken;
    /**
     * deletion_progress is an enumeration of the possible outcomes that occurred when attempting to delete the specified relationships.
     *
     * @generated from protobuf field: authzed.api.v1.DeleteRelationshipsResponse.DeletionProgress deletion_progress = 2;
     */
    deletionProgress: DeleteRelationshipsResponse_DeletionProgress;
}
/**
 * @generated from protobuf enum authzed.api.v1.DeleteRelationshipsResponse.DeletionProgress
 */
export enum DeleteRelationshipsResponse_DeletionProgress {
    /**
     * @generated from protobuf enum value: DELETION_PROGRESS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * DELETION_PROGRESS_COMPLETE indicates that all remaining relationships matching the filter
     * were deleted. Will be returned even if no relationships were deleted.
     *
     * @generated from protobuf enum value: DELETION_PROGRESS_COMPLETE = 1;
     */
    COMPLETE = 1,
    /**
     * DELETION_PROGRESS_PARTIAL indicates that a subset of the relationships matching the filter
     * were deleted. Only returned if optional_allow_partial_deletions was true, an optional_limit was
     * specified, and there existed more relationships matching the filter than optional_limit would allow.
     * Once all remaining relationships have been deleted, DELETION_PROGRESS_COMPLETE will be returned.
     *
     * @generated from protobuf enum value: DELETION_PROGRESS_PARTIAL = 2;
     */
    PARTIAL = 2
}
/**
 * CheckPermissionRequest issues a check on whether a subject has a permission
 * or is a member of a relation, on a specific resource.
 *
 * @generated from protobuf message authzed.api.v1.CheckPermissionRequest
 */
export interface CheckPermissionRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * resource is the resource on which to check the permission or relation.
     *
     * @generated from protobuf field: authzed.api.v1.ObjectReference resource = 2;
     */
    resource?: ObjectReference;
    /**
     * permission is the name of the permission (or relation) on which to execute
     * the check.
     *
     * @generated from protobuf field: string permission = 3;
     */
    permission: string;
    /**
     * subject is the subject that will be checked for the permission or relation.
     *
     * @generated from protobuf field: authzed.api.v1.SubjectReference subject = 4;
     */
    subject?: SubjectReference;
    /**
     * context consists of named values that are injected into the caveat evaluation context
     *
     * @generated from protobuf field: google.protobuf.Struct context = 5;
     */
    context?: Struct;
    /**
     * with_tracing, if true, indicates that the response should include a debug trace.
     * This can be useful for debugging and performance analysis, but adds a small amount
     * of compute overhead to the request.
     *
     * @generated from protobuf field: bool with_tracing = 6;
     */
    withTracing: boolean;
}
/**
 * @generated from protobuf message authzed.api.v1.CheckPermissionResponse
 */
export interface CheckPermissionResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken checked_at = 1;
     */
    checkedAt?: ZedToken;
    /**
     * Permissionship communicates whether or not the subject has the requested
     * permission or has a relationship with the given resource, over the given
     * relation.
     *
     * This value will be authzed.api.v1.PERMISSIONSHIP_HAS_PERMISSION if the
     * requested subject is a member of the computed permission set or there
     * exists a relationship with the requested relation from the given resource
     * to the given subject.
     *
     * @generated from protobuf field: authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 2;
     */
    permissionship: CheckPermissionResponse_Permissionship;
    /**
     * partial_caveat_info holds information of a partially-evaluated caveated response
     *
     * @generated from protobuf field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3;
     */
    partialCaveatInfo?: PartialCaveatInfo;
    /**
     * debug_trace is the debugging trace of this check, if requested.
     *
     * @generated from protobuf field: authzed.api.v1.DebugInformation debug_trace = 4;
     */
    debugTrace?: DebugInformation;
}
/**
 * @generated from protobuf enum authzed.api.v1.CheckPermissionResponse.Permissionship
 */
export enum CheckPermissionResponse_Permissionship {
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_NO_PERMISSION = 1;
     */
    NO_PERMISSION = 1,
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_HAS_PERMISSION = 2;
     */
    HAS_PERMISSION = 2,
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_CONDITIONAL_PERMISSION = 3;
     */
    CONDITIONAL_PERMISSION = 3
}
/**
 * CheckBulkPermissionsRequest issues a check on whether a subject has permission
 * or is a member of a relation on a specific resource for each item in the list.
 *
 * The ordering of the items in the response is maintained in the response.
 * Checks with the same subject/permission will automatically be batched for performance optimization.
 *
 * @generated from protobuf message authzed.api.v1.CheckBulkPermissionsRequest
 */
export interface CheckBulkPermissionsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.CheckBulkPermissionsRequestItem items = 2;
     */
    items: CheckBulkPermissionsRequestItem[];
}
/**
 * @generated from protobuf message authzed.api.v1.CheckBulkPermissionsRequestItem
 */
export interface CheckBulkPermissionsRequestItem {
    /**
     * @generated from protobuf field: authzed.api.v1.ObjectReference resource = 1;
     */
    resource?: ObjectReference;
    /**
     * @generated from protobuf field: string permission = 2;
     */
    permission: string;
    /**
     * @generated from protobuf field: authzed.api.v1.SubjectReference subject = 3;
     */
    subject?: SubjectReference;
    /**
     * @generated from protobuf field: google.protobuf.Struct context = 4;
     */
    context?: Struct;
}
/**
 * @generated from protobuf message authzed.api.v1.CheckBulkPermissionsResponse
 */
export interface CheckBulkPermissionsResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken checked_at = 1;
     */
    checkedAt?: ZedToken;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.CheckBulkPermissionsPair pairs = 2;
     */
    pairs: CheckBulkPermissionsPair[];
}
/**
 * @generated from protobuf message authzed.api.v1.CheckBulkPermissionsPair
 */
export interface CheckBulkPermissionsPair {
    /**
     * @generated from protobuf field: authzed.api.v1.CheckBulkPermissionsRequestItem request = 1;
     */
    request?: CheckBulkPermissionsRequestItem;
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "item";
        /**
         * @generated from protobuf field: authzed.api.v1.CheckBulkPermissionsResponseItem item = 2;
         */
        item: CheckBulkPermissionsResponseItem;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: google.rpc.Status error = 3;
         */
        error: Status;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message authzed.api.v1.CheckBulkPermissionsResponseItem
 */
export interface CheckBulkPermissionsResponseItem {
    /**
     * @generated from protobuf field: authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 1;
     */
    permissionship: CheckPermissionResponse_Permissionship;
    /**
     * @generated from protobuf field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 2;
     */
    partialCaveatInfo?: PartialCaveatInfo;
}
/**
 * ExpandPermissionTreeRequest returns a tree representing the expansion of all
 * relationships found accessible from a permission or relation on a particular
 * resource.
 *
 * ExpandPermissionTreeRequest is typically used to determine the full set of
 * subjects with a permission, along with the relationships that grant said
 * access.
 *
 * @generated from protobuf message authzed.api.v1.ExpandPermissionTreeRequest
 */
export interface ExpandPermissionTreeRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * resource is the resource over which to run the expansion.
     *
     * @generated from protobuf field: authzed.api.v1.ObjectReference resource = 2;
     */
    resource?: ObjectReference;
    /**
     * permission is the name of the permission or relation over which to run the
     * expansion for the resource.
     *
     * @generated from protobuf field: string permission = 3;
     */
    permission: string;
}
/**
 * @generated from protobuf message authzed.api.v1.ExpandPermissionTreeResponse
 */
export interface ExpandPermissionTreeResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken expanded_at = 1;
     */
    expandedAt?: ZedToken;
    /**
     * tree_root is a tree structure whose leaf nodes are subjects, and
     * intermediate nodes represent the various operations (union, intersection,
     * exclusion) to reach those subjects.
     *
     * @generated from protobuf field: authzed.api.v1.PermissionRelationshipTree tree_root = 2;
     */
    treeRoot?: PermissionRelationshipTree;
}
/**
 * LookupResourcesRequest performs a lookup of all resources of a particular
 * kind on which the subject has the specified permission or the relation in
 * which the subject exists, streaming back the IDs of those resources.
 *
 * @generated from protobuf message authzed.api.v1.LookupResourcesRequest
 */
export interface LookupResourcesRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * resource_object_type is the type of resource object for which the IDs will
     * be returned.
     *
     * @generated from protobuf field: string resource_object_type = 2;
     */
    resourceObjectType: string;
    /**
     * permission is the name of the permission or relation for which the subject
     * must Check.
     *
     * @generated from protobuf field: string permission = 3;
     */
    permission: string;
    /**
     * subject is the subject with access to the resources.
     *
     * @generated from protobuf field: authzed.api.v1.SubjectReference subject = 4;
     */
    subject?: SubjectReference;
    /**
     * context consists of named values that are injected into the caveat evaluation context
     *
     * @generated from protobuf field: google.protobuf.Struct context = 5;
     */
    context?: Struct;
    /**
     * optional_limit, if non-zero, specifies the limit on the number of resources to return
     * before the stream is closed on the server side. By default, the stream will continue
     * resolving resources until exhausted or the stream is closed due to the client or a
     * network issue.
     *
     * @generated from protobuf field: uint32 optional_limit = 6;
     */
    optionalLimit: number;
    /**
     * optional_cursor, if specified, indicates the cursor after which results should resume being returned.
     * The cursor can be found on the LookupResourcesResponse object.
     *
     * @generated from protobuf field: authzed.api.v1.Cursor optional_cursor = 7;
     */
    optionalCursor?: Cursor;
}
/**
 * LookupResourcesResponse contains a single matching resource object ID for the
 * requested object type, permission, and subject.
 *
 * @generated from protobuf message authzed.api.v1.LookupResourcesResponse
 */
export interface LookupResourcesResponse {
    /**
     * looked_up_at is the ZedToken at which the resource was found.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken looked_up_at = 1;
     */
    lookedUpAt?: ZedToken;
    /**
     * resource_object_id is the object ID of the found resource.
     *
     * @generated from protobuf field: string resource_object_id = 2;
     */
    resourceObjectId: string;
    /**
     * permissionship indicates whether the response was partially evaluated or not
     *
     * @generated from protobuf field: authzed.api.v1.LookupPermissionship permissionship = 3;
     */
    permissionship: LookupPermissionship;
    /**
     * partial_caveat_info holds information of a partially-evaluated caveated response
     *
     * @generated from protobuf field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 4;
     */
    partialCaveatInfo?: PartialCaveatInfo;
    /**
     * after_result_cursor holds a cursor that can be used to resume the LookupResources stream after this
     * result.
     *
     * @generated from protobuf field: authzed.api.v1.Cursor after_result_cursor = 5;
     */
    afterResultCursor?: Cursor;
}
/**
 * LookupSubjectsRequest performs a lookup of all subjects of a particular
 * kind for which the subject has the specified permission or the relation in
 * which the subject exists, streaming back the IDs of those subjects.
 *
 * @generated from protobuf message authzed.api.v1.LookupSubjectsRequest
 */
export interface LookupSubjectsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * resource is the resource for which all matching subjects for the permission
     * or relation will be returned.
     *
     * @generated from protobuf field: authzed.api.v1.ObjectReference resource = 2;
     */
    resource?: ObjectReference;
    /**
     * permission is the name of the permission (or relation) for which to find
     * the subjects.
     *
     * @generated from protobuf field: string permission = 3;
     */
    permission: string;
    /**
     * subject_object_type is the type of subject object for which the IDs will
     * be returned.
     *
     * @generated from protobuf field: string subject_object_type = 4;
     */
    subjectObjectType: string;
    /**
     * optional_subject_relation is the optional relation for the subject.
     *
     * @generated from protobuf field: string optional_subject_relation = 5;
     */
    optionalSubjectRelation: string;
    /**
     * context consists of named values that are injected into the caveat evaluation context
     *
     * @generated from protobuf field: google.protobuf.Struct context = 6;
     */
    context?: Struct;
    /**
     * optional_concrete_limit, if non-zero, specifies the limit on the number of
     * *concrete* (non-wildcard) subjects to return before the stream is closed on the
     * server side. With the default value of zero, the stream will continue resolving
     * concrete subjects until exhausted or the stream is closed due to the client or
     * a network issue.
     *
     * NOTE: Wildcard subjects ("*") have special treatment when cursors and limits are used. Because
     * wildcards can apply to *any* concrete subjects, if a wildcard subject is found within the dataset,
     * a wildcard subject can be returned for *all* LookupSubjects calls, regardless of the cursor or
     * limit.
     *
     * For example, if wildcards are requested, a wildcard subject exists, there is a specified limit
     * of 10 concrete subjects, and at least 10 concrete subjects exist, the API will return 11 subjects
     * in total: the 10 concrete + the wildcard
     *
     * Furthermore, if a wildcard has a set of exclusions generated by the dataset,
     * the exclusions *will respect the cursor* and only a *partial* set of exclusions will be returned
     * for each invocation of the API.
     *
     * ***IT IS UP TO THE CALLER IN THIS CASE TO COMBINE THE EXCLUSIONS IF DESIRED***
     *
     * @generated from protobuf field: uint32 optional_concrete_limit = 7;
     */
    optionalConcreteLimit: number;
    /**
     * optional_cursor, if specified, indicates the cursor after which results should resume being returned.
     * The cursor can be found on the LookupSubjectsResponse object.
     *
     * NOTE: See above for notes about how cursors interact with wildcard subjects.
     *
     * @generated from protobuf field: authzed.api.v1.Cursor optional_cursor = 8;
     */
    optionalCursor?: Cursor;
    /**
     * wildcard_option specifies whether wildcards should be returned by LookupSubjects.
     * For backwards compatibility, defaults to WILDCARD_OPTION_INCLUDE_WILDCARDS if unspecified.
     *
     * @generated from protobuf field: authzed.api.v1.LookupSubjectsRequest.WildcardOption wildcard_option = 9;
     */
    wildcardOption: LookupSubjectsRequest_WildcardOption;
}
/**
 * @generated from protobuf enum authzed.api.v1.LookupSubjectsRequest.WildcardOption
 */
export enum LookupSubjectsRequest_WildcardOption {
    /**
     * @generated from protobuf enum value: WILDCARD_OPTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: WILDCARD_OPTION_INCLUDE_WILDCARDS = 1;
     */
    INCLUDE_WILDCARDS = 1,
    /**
     * @generated from protobuf enum value: WILDCARD_OPTION_EXCLUDE_WILDCARDS = 2;
     */
    EXCLUDE_WILDCARDS = 2
}
/**
 * LookupSubjectsResponse contains a single matching subject object ID for the
 * requested subject object type on the permission or relation.
 *
 * @generated from protobuf message authzed.api.v1.LookupSubjectsResponse
 */
export interface LookupSubjectsResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken looked_up_at = 1;
     */
    lookedUpAt?: ZedToken;
    /**
     * subject_object_id is the Object ID of the subject found. May be a `*` if
     * a wildcard was found.
     * deprecated: use `subject`
     *
     * @deprecated
     * @generated from protobuf field: string subject_object_id = 2 [deprecated = true];
     */
    subjectObjectId: string;
    /**
     * excluded_subject_ids are the Object IDs of the subjects excluded. This list
     * will only contain object IDs if `subject_object_id` is a wildcard (`*`) and
     * will only be populated if exclusions exist from the wildcard.
     * deprecated: use `excluded_subjects`
     *
     * @deprecated
     * @generated from protobuf field: repeated string excluded_subject_ids = 3 [deprecated = true];
     */
    excludedSubjectIds: string[];
    /**
     * permissionship indicates whether the response was partially evaluated or not
     * deprecated: use `subject.permissionship`
     *
     * @deprecated
     * @generated from protobuf field: authzed.api.v1.LookupPermissionship permissionship = 4 [deprecated = true];
     */
    permissionship: LookupPermissionship;
    /**
     * partial_caveat_info holds information of a partially-evaluated caveated response
     * deprecated: use `subject.partial_caveat_info`
     *
     * @deprecated
     * @generated from protobuf field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 5 [deprecated = true];
     */
    partialCaveatInfo?: PartialCaveatInfo;
    /**
     * subject is the subject found, along with its permissionship.
     *
     * @generated from protobuf field: authzed.api.v1.ResolvedSubject subject = 6;
     */
    subject?: ResolvedSubject;
    /**
     * excluded_subjects are the subjects excluded. This list
     * will only contain subjects if `subject.subject_object_id` is a wildcard (`*`) and
     * will only be populated if exclusions exist from the wildcard.
     *
     * @generated from protobuf field: repeated authzed.api.v1.ResolvedSubject excluded_subjects = 7;
     */
    excludedSubjects: ResolvedSubject[];
    /**
     * after_result_cursor holds a cursor that can be used to resume the LookupSubjects stream after this
     * result.
     *
     * @generated from protobuf field: authzed.api.v1.Cursor after_result_cursor = 8;
     */
    afterResultCursor?: Cursor;
}
/**
 * ResolvedSubject is a single subject resolved within LookupSubjects.
 *
 * @generated from protobuf message authzed.api.v1.ResolvedSubject
 */
export interface ResolvedSubject {
    /**
     * subject_object_id is the Object ID of the subject found. May be a `*` if
     * a wildcard was found.
     *
     * @generated from protobuf field: string subject_object_id = 1;
     */
    subjectObjectId: string;
    /**
     * permissionship indicates whether the response was partially evaluated or not
     *
     * @generated from protobuf field: authzed.api.v1.LookupPermissionship permissionship = 2;
     */
    permissionship: LookupPermissionship;
    /**
     * partial_caveat_info holds information of a partially-evaluated caveated response
     *
     * @generated from protobuf field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3;
     */
    partialCaveatInfo?: PartialCaveatInfo;
}
/**
 * ImportBulkRelationshipsRequest represents one batch of the streaming
 * ImportBulkRelationships API. The maximum size is only limited by the backing
 * datastore, and optimal size should be determined by the calling client
 * experimentally.
 *
 * @generated from protobuf message authzed.api.v1.ImportBulkRelationshipsRequest
 */
export interface ImportBulkRelationshipsRequest {
    /**
     * @generated from protobuf field: repeated authzed.api.v1.Relationship relationships = 1;
     */
    relationships: Relationship[];
}
/**
 * ImportBulkRelationshipsResponse is returned on successful completion of the
 * bulk load stream, and contains the total number of relationships loaded.
 *
 * @generated from protobuf message authzed.api.v1.ImportBulkRelationshipsResponse
 */
export interface ImportBulkRelationshipsResponse {
    /**
     * @generated from protobuf field: uint64 num_loaded = 1;
     */
    numLoaded: string;
}
/**
 * ExportBulkRelationshipsRequest represents a resumable request for
 * all relationships from the server.
 *
 * @generated from protobuf message authzed.api.v1.ExportBulkRelationshipsRequest
 */
export interface ExportBulkRelationshipsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * optional_limit, if non-zero, specifies the limit on the number of
     * relationships the server can return in one page. By default, the server
     * will pick a page size, and the server is free to choose a smaller size
     * at will.
     *
     * @generated from protobuf field: uint32 optional_limit = 2;
     */
    optionalLimit: number;
    /**
     * optional_cursor, if specified, indicates the cursor after which results
     * should resume being returned. The cursor can be found on the
     * BulkExportRelationshipsResponse object.
     *
     * @generated from protobuf field: authzed.api.v1.Cursor optional_cursor = 3;
     */
    optionalCursor?: Cursor;
    /**
     * optional_relationship_filter, if specified, indicates the
     * filter to apply to each relationship to be exported.
     *
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter optional_relationship_filter = 4;
     */
    optionalRelationshipFilter?: RelationshipFilter;
}
/**
 * ExportBulkRelationshipsResponse is one page in a stream of relationship
 * groups that meet the criteria specified by the originating request. The
 * server will continue to stream back relationship groups as quickly as it can
 * until all relationships have been transmitted back.
 *
 * @generated from protobuf message authzed.api.v1.ExportBulkRelationshipsResponse
 */
export interface ExportBulkRelationshipsResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.Cursor after_result_cursor = 1;
     */
    afterResultCursor?: Cursor;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.Relationship relationships = 2;
     */
    relationships: Relationship[];
}
/**
 * LookupPermissionship represents whether a Lookup response was partially evaluated or not
 *
 * @generated from protobuf enum authzed.api.v1.LookupPermissionship
 */
export enum LookupPermissionship {
    /**
     * @generated from protobuf enum value: LOOKUP_PERMISSIONSHIP_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: LOOKUP_PERMISSIONSHIP_HAS_PERMISSION = 1;
     */
    HAS_PERMISSION = 1,
    /**
     * @generated from protobuf enum value: LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION = 2;
     */
    CONDITIONAL_PERMISSION = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Consistency$Type extends MessageType<Consistency> {
    constructor() {
        super("authzed.api.v1.Consistency", [
            { no: 1, name: "minimize_latency", kind: "scalar", oneof: "requirement", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 2, name: "at_least_as_fresh", kind: "message", oneof: "requirement", T: () => ZedToken },
            { no: 3, name: "at_exact_snapshot", kind: "message", oneof: "requirement", T: () => ZedToken },
            { no: 4, name: "fully_consistent", kind: "scalar", oneof: "requirement", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } }
        ]);
    }
    create(value?: PartialMessage<Consistency>): Consistency {
        const message = { requirement: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Consistency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Consistency): Consistency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool minimize_latency */ 1:
                    message.requirement = {
                        oneofKind: "minimizeLatency",
                        minimizeLatency: reader.bool()
                    };
                    break;
                case /* authzed.api.v1.ZedToken at_least_as_fresh */ 2:
                    message.requirement = {
                        oneofKind: "atLeastAsFresh",
                        atLeastAsFresh: ZedToken.internalBinaryRead(reader, reader.uint32(), options, (message.requirement as any).atLeastAsFresh)
                    };
                    break;
                case /* authzed.api.v1.ZedToken at_exact_snapshot */ 3:
                    message.requirement = {
                        oneofKind: "atExactSnapshot",
                        atExactSnapshot: ZedToken.internalBinaryRead(reader, reader.uint32(), options, (message.requirement as any).atExactSnapshot)
                    };
                    break;
                case /* bool fully_consistent */ 4:
                    message.requirement = {
                        oneofKind: "fullyConsistent",
                        fullyConsistent: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Consistency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool minimize_latency = 1; */
        if (message.requirement.oneofKind === "minimizeLatency")
            writer.tag(1, WireType.Varint).bool(message.requirement.minimizeLatency);
        /* authzed.api.v1.ZedToken at_least_as_fresh = 2; */
        if (message.requirement.oneofKind === "atLeastAsFresh")
            ZedToken.internalBinaryWrite(message.requirement.atLeastAsFresh, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken at_exact_snapshot = 3; */
        if (message.requirement.oneofKind === "atExactSnapshot")
            ZedToken.internalBinaryWrite(message.requirement.atExactSnapshot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool fully_consistent = 4; */
        if (message.requirement.oneofKind === "fullyConsistent")
            writer.tag(4, WireType.Varint).bool(message.requirement.fullyConsistent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.Consistency
 */
export const Consistency = new Consistency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipFilter$Type extends MessageType<RelationshipFilter> {
    constructor() {
        super("authzed.api.v1.RelationshipFilter", [
            { no: 1, name: "resource_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^(([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 2, name: "optional_resource_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1024", pattern: "^([a-zA-Z0-9/_|\\-=+]{1,})?$" } } } },
            { no: 5, name: "optional_resource_id_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1024", pattern: "^([a-zA-Z0-9/_|\\-=+]{1,})?$" } } } },
            { no: 3, name: "optional_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 4, name: "optional_subject_filter", kind: "message", T: () => SubjectFilter }
        ]);
    }
    create(value?: PartialMessage<RelationshipFilter>): RelationshipFilter {
        const message = { resourceType: "", optionalResourceId: "", optionalResourceIdPrefix: "", optionalRelation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipFilter): RelationshipFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resource_type */ 1:
                    message.resourceType = reader.string();
                    break;
                case /* string optional_resource_id */ 2:
                    message.optionalResourceId = reader.string();
                    break;
                case /* string optional_resource_id_prefix */ 5:
                    message.optionalResourceIdPrefix = reader.string();
                    break;
                case /* string optional_relation */ 3:
                    message.optionalRelation = reader.string();
                    break;
                case /* authzed.api.v1.SubjectFilter optional_subject_filter */ 4:
                    message.optionalSubjectFilter = SubjectFilter.internalBinaryRead(reader, reader.uint32(), options, message.optionalSubjectFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string resource_type = 1; */
        if (message.resourceType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resourceType);
        /* string optional_resource_id = 2; */
        if (message.optionalResourceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.optionalResourceId);
        /* string optional_resource_id_prefix = 5; */
        if (message.optionalResourceIdPrefix !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.optionalResourceIdPrefix);
        /* string optional_relation = 3; */
        if (message.optionalRelation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.optionalRelation);
        /* authzed.api.v1.SubjectFilter optional_subject_filter = 4; */
        if (message.optionalSubjectFilter)
            SubjectFilter.internalBinaryWrite(message.optionalSubjectFilter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.RelationshipFilter
 */
export const RelationshipFilter = new RelationshipFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubjectFilter$Type extends MessageType<SubjectFilter> {
    constructor() {
        super("authzed.api.v1.SubjectFilter", [
            { no: 1, name: "subject_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 2, name: "optional_subject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1024", pattern: "^(([a-zA-Z0-9/_|\\-=+]{1,})|\\*)?$" } } } },
            { no: 3, name: "optional_relation", kind: "message", T: () => SubjectFilter_RelationFilter }
        ]);
    }
    create(value?: PartialMessage<SubjectFilter>): SubjectFilter {
        const message = { subjectType: "", optionalSubjectId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubjectFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubjectFilter): SubjectFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subject_type */ 1:
                    message.subjectType = reader.string();
                    break;
                case /* string optional_subject_id */ 2:
                    message.optionalSubjectId = reader.string();
                    break;
                case /* authzed.api.v1.SubjectFilter.RelationFilter optional_relation */ 3:
                    message.optionalRelation = SubjectFilter_RelationFilter.internalBinaryRead(reader, reader.uint32(), options, message.optionalRelation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubjectFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subject_type = 1; */
        if (message.subjectType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subjectType);
        /* string optional_subject_id = 2; */
        if (message.optionalSubjectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.optionalSubjectId);
        /* authzed.api.v1.SubjectFilter.RelationFilter optional_relation = 3; */
        if (message.optionalRelation)
            SubjectFilter_RelationFilter.internalBinaryWrite(message.optionalRelation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.SubjectFilter
 */
export const SubjectFilter = new SubjectFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubjectFilter_RelationFilter$Type extends MessageType<SubjectFilter_RelationFilter> {
    constructor() {
        super("authzed.api.v1.SubjectFilter.RelationFilter", [
            { no: 1, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value?: PartialMessage<SubjectFilter_RelationFilter>): SubjectFilter_RelationFilter {
        const message = { relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubjectFilter_RelationFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubjectFilter_RelationFilter): SubjectFilter_RelationFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relation */ 1:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubjectFilter_RelationFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string relation = 1; */
        if (message.relation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.SubjectFilter.RelationFilter
 */
export const SubjectFilter_RelationFilter = new SubjectFilter_RelationFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRelationshipsRequest$Type extends MessageType<ReadRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.ReadRelationshipsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "relationship_filter", kind: "message", T: () => RelationshipFilter, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "optional_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 4, name: "optional_cursor", kind: "message", T: () => Cursor }
        ]);
    }
    create(value?: PartialMessage<ReadRelationshipsRequest>): ReadRelationshipsRequest {
        const message = { optionalLimit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRelationshipsRequest): ReadRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.RelationshipFilter relationship_filter */ 2:
                    message.relationshipFilter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.relationshipFilter);
                    break;
                case /* uint32 optional_limit */ 3:
                    message.optionalLimit = reader.uint32();
                    break;
                case /* authzed.api.v1.Cursor optional_cursor */ 4:
                    message.optionalCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.optionalCursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.RelationshipFilter relationship_filter = 2; */
        if (message.relationshipFilter)
            RelationshipFilter.internalBinaryWrite(message.relationshipFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 optional_limit = 3; */
        if (message.optionalLimit !== 0)
            writer.tag(3, WireType.Varint).uint32(message.optionalLimit);
        /* authzed.api.v1.Cursor optional_cursor = 4; */
        if (message.optionalCursor)
            Cursor.internalBinaryWrite(message.optionalCursor, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadRelationshipsRequest
 */
export const ReadRelationshipsRequest = new ReadRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRelationshipsResponse$Type extends MessageType<ReadRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.ReadRelationshipsResponse", [
            { no: 1, name: "read_at", kind: "message", T: () => ZedToken, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "relationship", kind: "message", T: () => Relationship, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "after_result_cursor", kind: "message", T: () => Cursor }
        ]);
    }
    create(value?: PartialMessage<ReadRelationshipsResponse>): ReadRelationshipsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRelationshipsResponse): ReadRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken read_at */ 1:
                    message.readAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                case /* authzed.api.v1.Relationship relationship */ 2:
                    message.relationship = Relationship.internalBinaryRead(reader, reader.uint32(), options, message.relationship);
                    break;
                case /* authzed.api.v1.Cursor after_result_cursor */ 3:
                    message.afterResultCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.afterResultCursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken read_at = 1; */
        if (message.readAt)
            ZedToken.internalBinaryWrite(message.readAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.Relationship relationship = 2; */
        if (message.relationship)
            Relationship.internalBinaryWrite(message.relationship, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.Cursor after_result_cursor = 3; */
        if (message.afterResultCursor)
            Cursor.internalBinaryWrite(message.afterResultCursor, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadRelationshipsResponse
 */
export const ReadRelationshipsResponse = new ReadRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Precondition$Type extends MessageType<Precondition> {
    constructor() {
        super("authzed.api.v1.Precondition", [
            { no: 1, name: "operation", kind: "enum", T: () => ["authzed.api.v1.Precondition.Operation", Precondition_Operation, "OPERATION_"], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 2, name: "filter", kind: "message", T: () => RelationshipFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<Precondition>): Precondition {
        const message = { operation: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Precondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Precondition): Precondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Precondition.Operation operation */ 1:
                    message.operation = reader.int32();
                    break;
                case /* authzed.api.v1.RelationshipFilter filter */ 2:
                    message.filter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Precondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Precondition.Operation operation = 1; */
        if (message.operation !== 0)
            writer.tag(1, WireType.Varint).int32(message.operation);
        /* authzed.api.v1.RelationshipFilter filter = 2; */
        if (message.filter)
            RelationshipFilter.internalBinaryWrite(message.filter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.Precondition
 */
export const Precondition = new Precondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRelationshipsRequest$Type extends MessageType<WriteRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.WriteRelationshipsRequest", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelationshipUpdate, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } },
            { no: 2, name: "optional_preconditions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Precondition, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } },
            { no: 3, name: "optional_transaction_metadata", kind: "message", T: () => Struct, options: { "validate.rules": { message: { required: false } } } }
        ]);
    }
    create(value?: PartialMessage<WriteRelationshipsRequest>): WriteRelationshipsRequest {
        const message = { updates: [], optionalPreconditions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteRelationshipsRequest): WriteRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.RelationshipUpdate updates */ 1:
                    message.updates.push(RelationshipUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated authzed.api.v1.Precondition optional_preconditions */ 2:
                    message.optionalPreconditions.push(Precondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Struct optional_transaction_metadata */ 3:
                    message.optionalTransactionMetadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.optionalTransactionMetadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v1.RelationshipUpdate updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            RelationshipUpdate.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.Precondition optional_preconditions = 2; */
        for (let i = 0; i < message.optionalPreconditions.length; i++)
            Precondition.internalBinaryWrite(message.optionalPreconditions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct optional_transaction_metadata = 3; */
        if (message.optionalTransactionMetadata)
            Struct.internalBinaryWrite(message.optionalTransactionMetadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.WriteRelationshipsRequest
 */
export const WriteRelationshipsRequest = new WriteRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRelationshipsResponse$Type extends MessageType<WriteRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.WriteRelationshipsResponse", [
            { no: 1, name: "written_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<WriteRelationshipsResponse>): WriteRelationshipsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteRelationshipsResponse): WriteRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken written_at */ 1:
                    message.writtenAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.writtenAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken written_at = 1; */
        if (message.writtenAt)
            ZedToken.internalBinaryWrite(message.writtenAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.WriteRelationshipsResponse
 */
export const WriteRelationshipsResponse = new WriteRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRelationshipsRequest$Type extends MessageType<DeleteRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.DeleteRelationshipsRequest", [
            { no: 1, name: "relationship_filter", kind: "message", T: () => RelationshipFilter, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "optional_preconditions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Precondition, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } },
            { no: 3, name: "optional_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 4, name: "optional_allow_partial_deletions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "optional_transaction_metadata", kind: "message", T: () => Struct, options: { "validate.rules": { message: { required: false } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteRelationshipsRequest>): DeleteRelationshipsRequest {
        const message = { optionalPreconditions: [], optionalLimit: 0, optionalAllowPartialDeletions: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRelationshipsRequest): DeleteRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.RelationshipFilter relationship_filter */ 1:
                    message.relationshipFilter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.relationshipFilter);
                    break;
                case /* repeated authzed.api.v1.Precondition optional_preconditions */ 2:
                    message.optionalPreconditions.push(Precondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 optional_limit */ 3:
                    message.optionalLimit = reader.uint32();
                    break;
                case /* bool optional_allow_partial_deletions */ 4:
                    message.optionalAllowPartialDeletions = reader.bool();
                    break;
                case /* google.protobuf.Struct optional_transaction_metadata */ 5:
                    message.optionalTransactionMetadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.optionalTransactionMetadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.RelationshipFilter relationship_filter = 1; */
        if (message.relationshipFilter)
            RelationshipFilter.internalBinaryWrite(message.relationshipFilter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.Precondition optional_preconditions = 2; */
        for (let i = 0; i < message.optionalPreconditions.length; i++)
            Precondition.internalBinaryWrite(message.optionalPreconditions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 optional_limit = 3; */
        if (message.optionalLimit !== 0)
            writer.tag(3, WireType.Varint).uint32(message.optionalLimit);
        /* bool optional_allow_partial_deletions = 4; */
        if (message.optionalAllowPartialDeletions !== false)
            writer.tag(4, WireType.Varint).bool(message.optionalAllowPartialDeletions);
        /* google.protobuf.Struct optional_transaction_metadata = 5; */
        if (message.optionalTransactionMetadata)
            Struct.internalBinaryWrite(message.optionalTransactionMetadata, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.DeleteRelationshipsRequest
 */
export const DeleteRelationshipsRequest = new DeleteRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRelationshipsResponse$Type extends MessageType<DeleteRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.DeleteRelationshipsResponse", [
            { no: 1, name: "deleted_at", kind: "message", T: () => ZedToken },
            { no: 2, name: "deletion_progress", kind: "enum", T: () => ["authzed.api.v1.DeleteRelationshipsResponse.DeletionProgress", DeleteRelationshipsResponse_DeletionProgress, "DELETION_PROGRESS_"] }
        ]);
    }
    create(value?: PartialMessage<DeleteRelationshipsResponse>): DeleteRelationshipsResponse {
        const message = { deletionProgress: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRelationshipsResponse): DeleteRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken deleted_at */ 1:
                    message.deletedAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                case /* authzed.api.v1.DeleteRelationshipsResponse.DeletionProgress deletion_progress */ 2:
                    message.deletionProgress = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken deleted_at = 1; */
        if (message.deletedAt)
            ZedToken.internalBinaryWrite(message.deletedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.DeleteRelationshipsResponse.DeletionProgress deletion_progress = 2; */
        if (message.deletionProgress !== 0)
            writer.tag(2, WireType.Varint).int32(message.deletionProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.DeleteRelationshipsResponse
 */
export const DeleteRelationshipsResponse = new DeleteRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionRequest$Type extends MessageType<CheckPermissionRequest> {
    constructor() {
        super("authzed.api.v1.CheckPermissionRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "resource", kind: "message", T: () => ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 4, name: "subject", kind: "message", T: () => SubjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 5, name: "context", kind: "message", T: () => Struct, options: { "validate.rules": { message: { required: false } } } },
            { no: 6, name: "with_tracing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CheckPermissionRequest>): CheckPermissionRequest {
        const message = { permission: "", withTracing: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckPermissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckPermissionRequest): CheckPermissionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 4:
                    message.subject = SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* google.protobuf.Struct context */ 5:
                    message.context = Struct.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* bool with_tracing */ 6:
                    message.withTracing = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckPermissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 4; */
        if (message.subject)
            SubjectReference.internalBinaryWrite(message.subject, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct context = 5; */
        if (message.context)
            Struct.internalBinaryWrite(message.context, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool with_tracing = 6; */
        if (message.withTracing !== false)
            writer.tag(6, WireType.Varint).bool(message.withTracing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckPermissionRequest
 */
export const CheckPermissionRequest = new CheckPermissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionResponse$Type extends MessageType<CheckPermissionResponse> {
    constructor() {
        super("authzed.api.v1.CheckPermissionResponse", [
            { no: 1, name: "checked_at", kind: "message", T: () => ZedToken, options: { "validate.rules": { message: { required: false } } } },
            { no: 2, name: "permissionship", kind: "enum", T: () => ["authzed.api.v1.CheckPermissionResponse.Permissionship", CheckPermissionResponse_Permissionship, "PERMISSIONSHIP_"], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 3, name: "partial_caveat_info", kind: "message", T: () => PartialCaveatInfo, options: { "validate.rules": { message: { required: false } } } },
            { no: 4, name: "debug_trace", kind: "message", T: () => DebugInformation }
        ]);
    }
    create(value?: PartialMessage<CheckPermissionResponse>): CheckPermissionResponse {
        const message = { permissionship: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckPermissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckPermissionResponse): CheckPermissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken checked_at */ 1:
                    message.checkedAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.checkedAt);
                    break;
                case /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship */ 2:
                    message.permissionship = reader.int32();
                    break;
                case /* authzed.api.v1.PartialCaveatInfo partial_caveat_info */ 3:
                    message.partialCaveatInfo = PartialCaveatInfo.internalBinaryRead(reader, reader.uint32(), options, message.partialCaveatInfo);
                    break;
                case /* authzed.api.v1.DebugInformation debug_trace */ 4:
                    message.debugTrace = DebugInformation.internalBinaryRead(reader, reader.uint32(), options, message.debugTrace);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckPermissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken checked_at = 1; */
        if (message.checkedAt)
            ZedToken.internalBinaryWrite(message.checkedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 2; */
        if (message.permissionship !== 0)
            writer.tag(2, WireType.Varint).int32(message.permissionship);
        /* authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3; */
        if (message.partialCaveatInfo)
            PartialCaveatInfo.internalBinaryWrite(message.partialCaveatInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.DebugInformation debug_trace = 4; */
        if (message.debugTrace)
            DebugInformation.internalBinaryWrite(message.debugTrace, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckPermissionResponse
 */
export const CheckPermissionResponse = new CheckPermissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckBulkPermissionsRequest$Type extends MessageType<CheckBulkPermissionsRequest> {
    constructor() {
        super("authzed.api.v1.CheckBulkPermissionsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CheckBulkPermissionsRequestItem, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<CheckBulkPermissionsRequest>): CheckBulkPermissionsRequest {
        const message = { items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckBulkPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckBulkPermissionsRequest): CheckBulkPermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* repeated authzed.api.v1.CheckBulkPermissionsRequestItem items */ 2:
                    message.items.push(CheckBulkPermissionsRequestItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckBulkPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.CheckBulkPermissionsRequestItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            CheckBulkPermissionsRequestItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckBulkPermissionsRequest
 */
export const CheckBulkPermissionsRequest = new CheckBulkPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckBulkPermissionsRequestItem$Type extends MessageType<CheckBulkPermissionsRequestItem> {
    constructor() {
        super("authzed.api.v1.CheckBulkPermissionsRequestItem", [
            { no: 1, name: "resource", kind: "message", T: () => ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 3, name: "subject", kind: "message", T: () => SubjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "context", kind: "message", T: () => Struct, options: { "validate.rules": { message: { required: false } } } }
        ]);
    }
    create(value?: PartialMessage<CheckBulkPermissionsRequestItem>): CheckBulkPermissionsRequestItem {
        const message = { permission: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckBulkPermissionsRequestItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckBulkPermissionsRequestItem): CheckBulkPermissionsRequestItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ObjectReference resource */ 1:
                    message.resource = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 2:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 3:
                    message.subject = SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* google.protobuf.Struct context */ 4:
                    message.context = Struct.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckBulkPermissionsRequestItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ObjectReference resource = 1; */
        if (message.resource)
            ObjectReference.internalBinaryWrite(message.resource, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 2; */
        if (message.permission !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 3; */
        if (message.subject)
            SubjectReference.internalBinaryWrite(message.subject, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct context = 4; */
        if (message.context)
            Struct.internalBinaryWrite(message.context, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckBulkPermissionsRequestItem
 */
export const CheckBulkPermissionsRequestItem = new CheckBulkPermissionsRequestItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckBulkPermissionsResponse$Type extends MessageType<CheckBulkPermissionsResponse> {
    constructor() {
        super("authzed.api.v1.CheckBulkPermissionsResponse", [
            { no: 1, name: "checked_at", kind: "message", T: () => ZedToken, options: { "validate.rules": { message: { required: false } } } },
            { no: 2, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CheckBulkPermissionsPair, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<CheckBulkPermissionsResponse>): CheckBulkPermissionsResponse {
        const message = { pairs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckBulkPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckBulkPermissionsResponse): CheckBulkPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken checked_at */ 1:
                    message.checkedAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.checkedAt);
                    break;
                case /* repeated authzed.api.v1.CheckBulkPermissionsPair pairs */ 2:
                    message.pairs.push(CheckBulkPermissionsPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckBulkPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken checked_at = 1; */
        if (message.checkedAt)
            ZedToken.internalBinaryWrite(message.checkedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.CheckBulkPermissionsPair pairs = 2; */
        for (let i = 0; i < message.pairs.length; i++)
            CheckBulkPermissionsPair.internalBinaryWrite(message.pairs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckBulkPermissionsResponse
 */
export const CheckBulkPermissionsResponse = new CheckBulkPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckBulkPermissionsPair$Type extends MessageType<CheckBulkPermissionsPair> {
    constructor() {
        super("authzed.api.v1.CheckBulkPermissionsPair", [
            { no: 1, name: "request", kind: "message", T: () => CheckBulkPermissionsRequestItem },
            { no: 2, name: "item", kind: "message", oneof: "response", T: () => CheckBulkPermissionsResponseItem },
            { no: 3, name: "error", kind: "message", oneof: "response", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<CheckBulkPermissionsPair>): CheckBulkPermissionsPair {
        const message = { response: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckBulkPermissionsPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckBulkPermissionsPair): CheckBulkPermissionsPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.CheckBulkPermissionsRequestItem request */ 1:
                    message.request = CheckBulkPermissionsRequestItem.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* authzed.api.v1.CheckBulkPermissionsResponseItem item */ 2:
                    message.response = {
                        oneofKind: "item",
                        item: CheckBulkPermissionsResponseItem.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).item)
                    };
                    break;
                case /* google.rpc.Status error */ 3:
                    message.response = {
                        oneofKind: "error",
                        error: Status.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckBulkPermissionsPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.CheckBulkPermissionsRequestItem request = 1; */
        if (message.request)
            CheckBulkPermissionsRequestItem.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.CheckBulkPermissionsResponseItem item = 2; */
        if (message.response.oneofKind === "item")
            CheckBulkPermissionsResponseItem.internalBinaryWrite(message.response.item, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status error = 3; */
        if (message.response.oneofKind === "error")
            Status.internalBinaryWrite(message.response.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckBulkPermissionsPair
 */
export const CheckBulkPermissionsPair = new CheckBulkPermissionsPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckBulkPermissionsResponseItem$Type extends MessageType<CheckBulkPermissionsResponseItem> {
    constructor() {
        super("authzed.api.v1.CheckBulkPermissionsResponseItem", [
            { no: 1, name: "permissionship", kind: "enum", T: () => ["authzed.api.v1.CheckPermissionResponse.Permissionship", CheckPermissionResponse_Permissionship, "PERMISSIONSHIP_"], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 2, name: "partial_caveat_info", kind: "message", T: () => PartialCaveatInfo, options: { "validate.rules": { message: { required: false } } } }
        ]);
    }
    create(value?: PartialMessage<CheckBulkPermissionsResponseItem>): CheckBulkPermissionsResponseItem {
        const message = { permissionship: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckBulkPermissionsResponseItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckBulkPermissionsResponseItem): CheckBulkPermissionsResponseItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship */ 1:
                    message.permissionship = reader.int32();
                    break;
                case /* authzed.api.v1.PartialCaveatInfo partial_caveat_info */ 2:
                    message.partialCaveatInfo = PartialCaveatInfo.internalBinaryRead(reader, reader.uint32(), options, message.partialCaveatInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckBulkPermissionsResponseItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 1; */
        if (message.permissionship !== 0)
            writer.tag(1, WireType.Varint).int32(message.permissionship);
        /* authzed.api.v1.PartialCaveatInfo partial_caveat_info = 2; */
        if (message.partialCaveatInfo)
            PartialCaveatInfo.internalBinaryWrite(message.partialCaveatInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckBulkPermissionsResponseItem
 */
export const CheckBulkPermissionsResponseItem = new CheckBulkPermissionsResponseItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandPermissionTreeRequest$Type extends MessageType<ExpandPermissionTreeRequest> {
    constructor() {
        super("authzed.api.v1.ExpandPermissionTreeRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "resource", kind: "message", T: () => ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value?: PartialMessage<ExpandPermissionTreeRequest>): ExpandPermissionTreeRequest {
        const message = { permission: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExpandPermissionTreeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpandPermissionTreeRequest): ExpandPermissionTreeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpandPermissionTreeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permission);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpandPermissionTreeRequest
 */
export const ExpandPermissionTreeRequest = new ExpandPermissionTreeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandPermissionTreeResponse$Type extends MessageType<ExpandPermissionTreeResponse> {
    constructor() {
        super("authzed.api.v1.ExpandPermissionTreeResponse", [
            { no: 1, name: "expanded_at", kind: "message", T: () => ZedToken },
            { no: 2, name: "tree_root", kind: "message", T: () => PermissionRelationshipTree }
        ]);
    }
    create(value?: PartialMessage<ExpandPermissionTreeResponse>): ExpandPermissionTreeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExpandPermissionTreeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpandPermissionTreeResponse): ExpandPermissionTreeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken expanded_at */ 1:
                    message.expandedAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.expandedAt);
                    break;
                case /* authzed.api.v1.PermissionRelationshipTree tree_root */ 2:
                    message.treeRoot = PermissionRelationshipTree.internalBinaryRead(reader, reader.uint32(), options, message.treeRoot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpandPermissionTreeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken expanded_at = 1; */
        if (message.expandedAt)
            ZedToken.internalBinaryWrite(message.expandedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.PermissionRelationshipTree tree_root = 2; */
        if (message.treeRoot)
            PermissionRelationshipTree.internalBinaryWrite(message.treeRoot, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpandPermissionTreeResponse
 */
export const ExpandPermissionTreeResponse = new ExpandPermissionTreeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupResourcesRequest$Type extends MessageType<LookupResourcesRequest> {
    constructor() {
        super("authzed.api.v1.LookupResourcesRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "resource_object_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 4, name: "subject", kind: "message", T: () => SubjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 5, name: "context", kind: "message", T: () => Struct, options: { "validate.rules": { message: { required: false } } } },
            { no: 6, name: "optional_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 7, name: "optional_cursor", kind: "message", T: () => Cursor }
        ]);
    }
    create(value?: PartialMessage<LookupResourcesRequest>): LookupResourcesRequest {
        const message = { resourceObjectType: "", permission: "", optionalLimit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupResourcesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupResourcesRequest): LookupResourcesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* string resource_object_type */ 2:
                    message.resourceObjectType = reader.string();
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 4:
                    message.subject = SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* google.protobuf.Struct context */ 5:
                    message.context = Struct.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* uint32 optional_limit */ 6:
                    message.optionalLimit = reader.uint32();
                    break;
                case /* authzed.api.v1.Cursor optional_cursor */ 7:
                    message.optionalCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.optionalCursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupResourcesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string resource_object_type = 2; */
        if (message.resourceObjectType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourceObjectType);
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 4; */
        if (message.subject)
            SubjectReference.internalBinaryWrite(message.subject, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct context = 5; */
        if (message.context)
            Struct.internalBinaryWrite(message.context, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 optional_limit = 6; */
        if (message.optionalLimit !== 0)
            writer.tag(6, WireType.Varint).uint32(message.optionalLimit);
        /* authzed.api.v1.Cursor optional_cursor = 7; */
        if (message.optionalCursor)
            Cursor.internalBinaryWrite(message.optionalCursor, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupResourcesRequest
 */
export const LookupResourcesRequest = new LookupResourcesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupResourcesResponse$Type extends MessageType<LookupResourcesResponse> {
    constructor() {
        super("authzed.api.v1.LookupResourcesResponse", [
            { no: 1, name: "looked_up_at", kind: "message", T: () => ZedToken },
            { no: 2, name: "resource_object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "permissionship", kind: "enum", T: () => ["authzed.api.v1.LookupPermissionship", LookupPermissionship, "LOOKUP_PERMISSIONSHIP_"], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 4, name: "partial_caveat_info", kind: "message", T: () => PartialCaveatInfo, options: { "validate.rules": { message: { required: false } } } },
            { no: 5, name: "after_result_cursor", kind: "message", T: () => Cursor }
        ]);
    }
    create(value?: PartialMessage<LookupResourcesResponse>): LookupResourcesResponse {
        const message = { resourceObjectId: "", permissionship: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupResourcesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupResourcesResponse): LookupResourcesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken looked_up_at */ 1:
                    message.lookedUpAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.lookedUpAt);
                    break;
                case /* string resource_object_id */ 2:
                    message.resourceObjectId = reader.string();
                    break;
                case /* authzed.api.v1.LookupPermissionship permissionship */ 3:
                    message.permissionship = reader.int32();
                    break;
                case /* authzed.api.v1.PartialCaveatInfo partial_caveat_info */ 4:
                    message.partialCaveatInfo = PartialCaveatInfo.internalBinaryRead(reader, reader.uint32(), options, message.partialCaveatInfo);
                    break;
                case /* authzed.api.v1.Cursor after_result_cursor */ 5:
                    message.afterResultCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.afterResultCursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupResourcesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken looked_up_at = 1; */
        if (message.lookedUpAt)
            ZedToken.internalBinaryWrite(message.lookedUpAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string resource_object_id = 2; */
        if (message.resourceObjectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourceObjectId);
        /* authzed.api.v1.LookupPermissionship permissionship = 3; */
        if (message.permissionship !== 0)
            writer.tag(3, WireType.Varint).int32(message.permissionship);
        /* authzed.api.v1.PartialCaveatInfo partial_caveat_info = 4; */
        if (message.partialCaveatInfo)
            PartialCaveatInfo.internalBinaryWrite(message.partialCaveatInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.Cursor after_result_cursor = 5; */
        if (message.afterResultCursor)
            Cursor.internalBinaryWrite(message.afterResultCursor, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupResourcesResponse
 */
export const LookupResourcesResponse = new LookupResourcesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupSubjectsRequest$Type extends MessageType<LookupSubjectsRequest> {
    constructor() {
        super("authzed.api.v1.LookupSubjectsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "resource", kind: "message", T: () => ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 4, name: "subject_object_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 5, name: "optional_subject_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 6, name: "context", kind: "message", T: () => Struct, options: { "validate.rules": { message: { required: false } } } },
            { no: 7, name: "optional_concrete_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 8, name: "optional_cursor", kind: "message", T: () => Cursor },
            { no: 9, name: "wildcard_option", kind: "enum", T: () => ["authzed.api.v1.LookupSubjectsRequest.WildcardOption", LookupSubjectsRequest_WildcardOption, "WILDCARD_OPTION_"] }
        ]);
    }
    create(value?: PartialMessage<LookupSubjectsRequest>): LookupSubjectsRequest {
        const message = { permission: "", subjectObjectType: "", optionalSubjectRelation: "", optionalConcreteLimit: 0, wildcardOption: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupSubjectsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupSubjectsRequest): LookupSubjectsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* string subject_object_type */ 4:
                    message.subjectObjectType = reader.string();
                    break;
                case /* string optional_subject_relation */ 5:
                    message.optionalSubjectRelation = reader.string();
                    break;
                case /* google.protobuf.Struct context */ 6:
                    message.context = Struct.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* uint32 optional_concrete_limit */ 7:
                    message.optionalConcreteLimit = reader.uint32();
                    break;
                case /* authzed.api.v1.Cursor optional_cursor */ 8:
                    message.optionalCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.optionalCursor);
                    break;
                case /* authzed.api.v1.LookupSubjectsRequest.WildcardOption wildcard_option */ 9:
                    message.wildcardOption = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupSubjectsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permission);
        /* string subject_object_type = 4; */
        if (message.subjectObjectType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subjectObjectType);
        /* string optional_subject_relation = 5; */
        if (message.optionalSubjectRelation !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.optionalSubjectRelation);
        /* google.protobuf.Struct context = 6; */
        if (message.context)
            Struct.internalBinaryWrite(message.context, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 optional_concrete_limit = 7; */
        if (message.optionalConcreteLimit !== 0)
            writer.tag(7, WireType.Varint).uint32(message.optionalConcreteLimit);
        /* authzed.api.v1.Cursor optional_cursor = 8; */
        if (message.optionalCursor)
            Cursor.internalBinaryWrite(message.optionalCursor, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.LookupSubjectsRequest.WildcardOption wildcard_option = 9; */
        if (message.wildcardOption !== 0)
            writer.tag(9, WireType.Varint).int32(message.wildcardOption);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupSubjectsRequest
 */
export const LookupSubjectsRequest = new LookupSubjectsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupSubjectsResponse$Type extends MessageType<LookupSubjectsResponse> {
    constructor() {
        super("authzed.api.v1.LookupSubjectsResponse", [
            { no: 1, name: "looked_up_at", kind: "message", T: () => ZedToken },
            { no: 2, name: "subject_object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "excluded_subject_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "permissionship", kind: "enum", T: () => ["authzed.api.v1.LookupPermissionship", LookupPermissionship, "LOOKUP_PERMISSIONSHIP_"], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 5, name: "partial_caveat_info", kind: "message", T: () => PartialCaveatInfo, options: { "validate.rules": { message: { required: false } } } },
            { no: 6, name: "subject", kind: "message", T: () => ResolvedSubject },
            { no: 7, name: "excluded_subjects", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResolvedSubject },
            { no: 8, name: "after_result_cursor", kind: "message", T: () => Cursor }
        ]);
    }
    create(value?: PartialMessage<LookupSubjectsResponse>): LookupSubjectsResponse {
        const message = { subjectObjectId: "", excludedSubjectIds: [], permissionship: 0, excludedSubjects: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupSubjectsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupSubjectsResponse): LookupSubjectsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken looked_up_at */ 1:
                    message.lookedUpAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.lookedUpAt);
                    break;
                case /* string subject_object_id = 2 [deprecated = true];*/ 2:
                    message.subjectObjectId = reader.string();
                    break;
                case /* repeated string excluded_subject_ids = 3 [deprecated = true];*/ 3:
                    message.excludedSubjectIds.push(reader.string());
                    break;
                case /* authzed.api.v1.LookupPermissionship permissionship = 4 [deprecated = true];*/ 4:
                    message.permissionship = reader.int32();
                    break;
                case /* authzed.api.v1.PartialCaveatInfo partial_caveat_info = 5 [deprecated = true];*/ 5:
                    message.partialCaveatInfo = PartialCaveatInfo.internalBinaryRead(reader, reader.uint32(), options, message.partialCaveatInfo);
                    break;
                case /* authzed.api.v1.ResolvedSubject subject */ 6:
                    message.subject = ResolvedSubject.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* repeated authzed.api.v1.ResolvedSubject excluded_subjects */ 7:
                    message.excludedSubjects.push(ResolvedSubject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* authzed.api.v1.Cursor after_result_cursor */ 8:
                    message.afterResultCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.afterResultCursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupSubjectsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken looked_up_at = 1; */
        if (message.lookedUpAt)
            ZedToken.internalBinaryWrite(message.lookedUpAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string subject_object_id = 2 [deprecated = true]; */
        if (message.subjectObjectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subjectObjectId);
        /* repeated string excluded_subject_ids = 3 [deprecated = true]; */
        for (let i = 0; i < message.excludedSubjectIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.excludedSubjectIds[i]);
        /* authzed.api.v1.LookupPermissionship permissionship = 4 [deprecated = true]; */
        if (message.permissionship !== 0)
            writer.tag(4, WireType.Varint).int32(message.permissionship);
        /* authzed.api.v1.PartialCaveatInfo partial_caveat_info = 5 [deprecated = true]; */
        if (message.partialCaveatInfo)
            PartialCaveatInfo.internalBinaryWrite(message.partialCaveatInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ResolvedSubject subject = 6; */
        if (message.subject)
            ResolvedSubject.internalBinaryWrite(message.subject, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.ResolvedSubject excluded_subjects = 7; */
        for (let i = 0; i < message.excludedSubjects.length; i++)
            ResolvedSubject.internalBinaryWrite(message.excludedSubjects[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.Cursor after_result_cursor = 8; */
        if (message.afterResultCursor)
            Cursor.internalBinaryWrite(message.afterResultCursor, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupSubjectsResponse
 */
export const LookupSubjectsResponse = new LookupSubjectsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolvedSubject$Type extends MessageType<ResolvedSubject> {
    constructor() {
        super("authzed.api.v1.ResolvedSubject", [
            { no: 1, name: "subject_object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "permissionship", kind: "enum", T: () => ["authzed.api.v1.LookupPermissionship", LookupPermissionship, "LOOKUP_PERMISSIONSHIP_"], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 3, name: "partial_caveat_info", kind: "message", T: () => PartialCaveatInfo, options: { "validate.rules": { message: { required: false } } } }
        ]);
    }
    create(value?: PartialMessage<ResolvedSubject>): ResolvedSubject {
        const message = { subjectObjectId: "", permissionship: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResolvedSubject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResolvedSubject): ResolvedSubject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subject_object_id */ 1:
                    message.subjectObjectId = reader.string();
                    break;
                case /* authzed.api.v1.LookupPermissionship permissionship */ 2:
                    message.permissionship = reader.int32();
                    break;
                case /* authzed.api.v1.PartialCaveatInfo partial_caveat_info */ 3:
                    message.partialCaveatInfo = PartialCaveatInfo.internalBinaryRead(reader, reader.uint32(), options, message.partialCaveatInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResolvedSubject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subject_object_id = 1; */
        if (message.subjectObjectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subjectObjectId);
        /* authzed.api.v1.LookupPermissionship permissionship = 2; */
        if (message.permissionship !== 0)
            writer.tag(2, WireType.Varint).int32(message.permissionship);
        /* authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3; */
        if (message.partialCaveatInfo)
            PartialCaveatInfo.internalBinaryWrite(message.partialCaveatInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ResolvedSubject
 */
export const ResolvedSubject = new ResolvedSubject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportBulkRelationshipsRequest$Type extends MessageType<ImportBulkRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.ImportBulkRelationshipsRequest", [
            { no: 1, name: "relationships", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Relationship, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<ImportBulkRelationshipsRequest>): ImportBulkRelationshipsRequest {
        const message = { relationships: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportBulkRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportBulkRelationshipsRequest): ImportBulkRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.Relationship relationships */ 1:
                    message.relationships.push(Relationship.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportBulkRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v1.Relationship relationships = 1; */
        for (let i = 0; i < message.relationships.length; i++)
            Relationship.internalBinaryWrite(message.relationships[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ImportBulkRelationshipsRequest
 */
export const ImportBulkRelationshipsRequest = new ImportBulkRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportBulkRelationshipsResponse$Type extends MessageType<ImportBulkRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.ImportBulkRelationshipsResponse", [
            { no: 1, name: "num_loaded", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<ImportBulkRelationshipsResponse>): ImportBulkRelationshipsResponse {
        const message = { numLoaded: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportBulkRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportBulkRelationshipsResponse): ImportBulkRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 num_loaded */ 1:
                    message.numLoaded = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportBulkRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 num_loaded = 1; */
        if (message.numLoaded !== "0")
            writer.tag(1, WireType.Varint).uint64(message.numLoaded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ImportBulkRelationshipsResponse
 */
export const ImportBulkRelationshipsResponse = new ImportBulkRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportBulkRelationshipsRequest$Type extends MessageType<ExportBulkRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.ExportBulkRelationshipsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "optional_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 3, name: "optional_cursor", kind: "message", T: () => Cursor },
            { no: 4, name: "optional_relationship_filter", kind: "message", T: () => RelationshipFilter }
        ]);
    }
    create(value?: PartialMessage<ExportBulkRelationshipsRequest>): ExportBulkRelationshipsRequest {
        const message = { optionalLimit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExportBulkRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExportBulkRelationshipsRequest): ExportBulkRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* uint32 optional_limit */ 2:
                    message.optionalLimit = reader.uint32();
                    break;
                case /* authzed.api.v1.Cursor optional_cursor */ 3:
                    message.optionalCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.optionalCursor);
                    break;
                case /* authzed.api.v1.RelationshipFilter optional_relationship_filter */ 4:
                    message.optionalRelationshipFilter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.optionalRelationshipFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExportBulkRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 optional_limit = 2; */
        if (message.optionalLimit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.optionalLimit);
        /* authzed.api.v1.Cursor optional_cursor = 3; */
        if (message.optionalCursor)
            Cursor.internalBinaryWrite(message.optionalCursor, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.RelationshipFilter optional_relationship_filter = 4; */
        if (message.optionalRelationshipFilter)
            RelationshipFilter.internalBinaryWrite(message.optionalRelationshipFilter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExportBulkRelationshipsRequest
 */
export const ExportBulkRelationshipsRequest = new ExportBulkRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExportBulkRelationshipsResponse$Type extends MessageType<ExportBulkRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.ExportBulkRelationshipsResponse", [
            { no: 1, name: "after_result_cursor", kind: "message", T: () => Cursor },
            { no: 2, name: "relationships", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Relationship }
        ]);
    }
    create(value?: PartialMessage<ExportBulkRelationshipsResponse>): ExportBulkRelationshipsResponse {
        const message = { relationships: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExportBulkRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExportBulkRelationshipsResponse): ExportBulkRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Cursor after_result_cursor */ 1:
                    message.afterResultCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.afterResultCursor);
                    break;
                case /* repeated authzed.api.v1.Relationship relationships */ 2:
                    message.relationships.push(Relationship.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExportBulkRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Cursor after_result_cursor = 1; */
        if (message.afterResultCursor)
            Cursor.internalBinaryWrite(message.afterResultCursor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.Relationship relationships = 2; */
        for (let i = 0; i < message.relationships.length; i++)
            Relationship.internalBinaryWrite(message.relationships[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExportBulkRelationshipsResponse
 */
export const ExportBulkRelationshipsResponse = new ExportBulkRelationshipsResponse$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.v1.PermissionsService
 */
export const PermissionsService = new ServiceType("authzed.api.v1.PermissionsService", [
    { name: "ReadRelationships", serverStreaming: true, options: { "google.api.http": { post: "/v1/relationships/read", body: "*" } }, I: ReadRelationshipsRequest, O: ReadRelationshipsResponse },
    { name: "WriteRelationships", options: { "google.api.http": { post: "/v1/relationships/write", body: "*" } }, I: WriteRelationshipsRequest, O: WriteRelationshipsResponse },
    { name: "DeleteRelationships", options: { "google.api.http": { post: "/v1/relationships/delete", body: "*" } }, I: DeleteRelationshipsRequest, O: DeleteRelationshipsResponse },
    { name: "CheckPermission", options: { "google.api.http": { post: "/v1/permissions/check", body: "*" } }, I: CheckPermissionRequest, O: CheckPermissionResponse },
    { name: "CheckBulkPermissions", options: { "google.api.http": { post: "/v1/permissions/checkbulk", body: "*" } }, I: CheckBulkPermissionsRequest, O: CheckBulkPermissionsResponse },
    { name: "ExpandPermissionTree", options: { "google.api.http": { post: "/v1/permissions/expand", body: "*" } }, I: ExpandPermissionTreeRequest, O: ExpandPermissionTreeResponse },
    { name: "LookupResources", serverStreaming: true, options: { "google.api.http": { post: "/v1/permissions/resources", body: "*" } }, I: LookupResourcesRequest, O: LookupResourcesResponse },
    { name: "LookupSubjects", serverStreaming: true, options: { "google.api.http": { post: "/v1/permissions/subjects", body: "*" } }, I: LookupSubjectsRequest, O: LookupSubjectsResponse },
    { name: "ImportBulkRelationships", clientStreaming: true, options: { "google.api.http": { post: "/v1/experimental/relationships/bulkimport", body: "*" } }, I: ImportBulkRelationshipsRequest, O: ImportBulkRelationshipsResponse },
    { name: "ExportBulkRelationships", serverStreaming: true, options: { "google.api.http": { post: "/v1/experimental/relationships/bulkexport", body: "*" } }, I: ExportBulkRelationshipsRequest, O: ExportBulkRelationshipsResponse }
]);
