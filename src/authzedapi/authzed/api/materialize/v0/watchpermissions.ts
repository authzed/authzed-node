// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "authzed/api/materialize/v0/watchpermissions.proto" (package "authzed.api.materialize.v0", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SubjectReference } from "../../v1/core";
import { ObjectReference } from "../../v1/core";
import { ZedToken } from "../../v1/core";
/**
 * @generated from protobuf message authzed.api.materialize.v0.WatchPermissionsRequest
 */
export interface WatchPermissionsRequest {
    /**
     * permissions is a list of permissions to watch for changes. At least one permission must be specified, and it must
     * be a subset or equal to the permissions that were enabled for the service.
     *
     * @generated from protobuf field: repeated authzed.api.materialize.v0.WatchedPermission permissions = 1;
     */
    permissions: WatchedPermission[];
    /**
     * optional_starting_after is the revision token to start watching from. If not provided, the stream
     * will start from the current revision at the moment of the request.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken optional_starting_after = 2;
     */
    optionalStartingAfter?: ZedToken;
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.WatchedPermission
 */
export interface WatchedPermission {
    /**
     * resource_type is the type of the resource to watch for changes.
     *
     * @generated from protobuf field: string resource_type = 1;
     */
    resourceType: string;
    /**
     * permission is the permission to watch for changes.
     *
     * @generated from protobuf field: string permission = 2;
     */
    permission: string;
    /**
     * subject_type is the type of the subject to watch for changes.
     *
     * @generated from protobuf field: string subject_type = 3;
     */
    subjectType: string;
    /**
     * optional_subject_relation is the relation on the subject to watch for changes.
     *
     * @generated from protobuf field: string optional_subject_relation = 4;
     */
    optionalSubjectRelation: string;
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.WatchPermissionsResponse
 */
export interface WatchPermissionsResponse {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "change";
        /**
         * change is the computed permission delta that has occurred as result of a mutation in origin SpiceDB.
         * The consumer should apply this change to the current state of the computed permissions in their target system.
         * Once an event arrives with completed_revision instead, the consumer shall consider there are not more changes
         * originating from that revision.
         *
         * The consumer should keep track of the revision in order to resume streaming in the event of consumer restarts.
         *
         * @generated from protobuf field: authzed.api.materialize.v0.PermissionChange change = 1;
         */
        change: PermissionChange;
    } | {
        oneofKind: "completedRevision";
        /**
         * completed_revision is the revision token that indicates all changes originating from a revision have been
         * streamed and thus the revision should be considered completed. It may also be
         * received without accompanying set of changes, indicating that a mutation in the origin SpiceDB cluster did
         * not yield any effective changes in the computed permissions
         *
         * @generated from protobuf field: authzed.api.v1.ZedToken completed_revision = 2;
         */
        completedRevision: ZedToken;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.PermissionChange
 */
export interface PermissionChange {
    /**
     * revision represents the revision at which the change occurred.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken revision = 1;
     */
    revision?: ZedToken;
    /**
     * resource is the resource that the permission change is related to.
     *
     * @generated from protobuf field: authzed.api.v1.ObjectReference resource = 2;
     */
    resource?: ObjectReference;
    /**
     * permission is the permission that has changed.
     *
     * @generated from protobuf field: string permission = 3;
     */
    permission: string;
    /**
     * subject is the subject that the permission change is related to.
     *
     * @generated from protobuf field: authzed.api.v1.SubjectReference subject = 4;
     */
    subject?: SubjectReference;
    /**
     * permissionship is the new permissionship of the subject over the resource after the change.
     *
     * @generated from protobuf field: authzed.api.materialize.v0.PermissionChange.Permissionship permissionship = 5;
     */
    permissionship: PermissionChange_Permissionship;
}
/**
 * @generated from protobuf enum authzed.api.materialize.v0.PermissionChange.Permissionship
 */
export enum PermissionChange_Permissionship {
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_NO_PERMISSION = 1;
     */
    NO_PERMISSION = 1,
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_HAS_PERMISSION = 2;
     */
    HAS_PERMISSION = 2,
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_CONDITIONAL_PERMISSION = 3;
     */
    CONDITIONAL_PERMISSION = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class WatchPermissionsRequest$Type extends MessageType<WatchPermissionsRequest> {
    constructor() {
        super("authzed.api.materialize.v0.WatchPermissionsRequest", [
            { no: 1, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WatchedPermission },
            { no: 2, name: "optional_starting_after", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<WatchPermissionsRequest>): WatchPermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        if (value !== undefined)
            reflectionMergePartial<WatchPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchPermissionsRequest): WatchPermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.materialize.v0.WatchedPermission permissions */ 1:
                    message.permissions.push(WatchedPermission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* authzed.api.v1.ZedToken optional_starting_after */ 2:
                    message.optionalStartingAfter = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.optionalStartingAfter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.materialize.v0.WatchedPermission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            WatchedPermission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken optional_starting_after = 2; */
        if (message.optionalStartingAfter)
            ZedToken.internalBinaryWrite(message.optionalStartingAfter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.WatchPermissionsRequest
 */
export const WatchPermissionsRequest = new WatchPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchedPermission$Type extends MessageType<WatchedPermission> {
    constructor() {
        super("authzed.api.materialize.v0.WatchedPermission", [
            { no: 1, name: "resource_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subject_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "optional_subject_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WatchedPermission>): WatchedPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceType = "";
        message.permission = "";
        message.subjectType = "";
        message.optionalSubjectRelation = "";
        if (value !== undefined)
            reflectionMergePartial<WatchedPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchedPermission): WatchedPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resource_type */ 1:
                    message.resourceType = reader.string();
                    break;
                case /* string permission */ 2:
                    message.permission = reader.string();
                    break;
                case /* string subject_type */ 3:
                    message.subjectType = reader.string();
                    break;
                case /* string optional_subject_relation */ 4:
                    message.optionalSubjectRelation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchedPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string resource_type = 1; */
        if (message.resourceType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resourceType);
        /* string permission = 2; */
        if (message.permission !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.permission);
        /* string subject_type = 3; */
        if (message.subjectType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subjectType);
        /* string optional_subject_relation = 4; */
        if (message.optionalSubjectRelation !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.optionalSubjectRelation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.WatchedPermission
 */
export const WatchedPermission = new WatchedPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchPermissionsResponse$Type extends MessageType<WatchPermissionsResponse> {
    constructor() {
        super("authzed.api.materialize.v0.WatchPermissionsResponse", [
            { no: 1, name: "change", kind: "message", oneof: "response", T: () => PermissionChange },
            { no: 2, name: "completed_revision", kind: "message", oneof: "response", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<WatchPermissionsResponse>): WatchPermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<WatchPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchPermissionsResponse): WatchPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.materialize.v0.PermissionChange change */ 1:
                    message.response = {
                        oneofKind: "change",
                        change: PermissionChange.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).change)
                    };
                    break;
                case /* authzed.api.v1.ZedToken completed_revision */ 2:
                    message.response = {
                        oneofKind: "completedRevision",
                        completedRevision: ZedToken.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).completedRevision)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.materialize.v0.PermissionChange change = 1; */
        if (message.response.oneofKind === "change")
            PermissionChange.internalBinaryWrite(message.response.change, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken completed_revision = 2; */
        if (message.response.oneofKind === "completedRevision")
            ZedToken.internalBinaryWrite(message.response.completedRevision, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.WatchPermissionsResponse
 */
export const WatchPermissionsResponse = new WatchPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionChange$Type extends MessageType<PermissionChange> {
    constructor() {
        super("authzed.api.materialize.v0.PermissionChange", [
            { no: 1, name: "revision", kind: "message", T: () => ZedToken },
            { no: 2, name: "resource", kind: "message", T: () => ObjectReference },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subject", kind: "message", T: () => SubjectReference },
            { no: 5, name: "permissionship", kind: "enum", T: () => ["authzed.api.materialize.v0.PermissionChange.Permissionship", PermissionChange_Permissionship, "PERMISSIONSHIP_"] }
        ]);
    }
    create(value?: PartialMessage<PermissionChange>): PermissionChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permission = "";
        message.permissionship = 0;
        if (value !== undefined)
            reflectionMergePartial<PermissionChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionChange): PermissionChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken revision */ 1:
                    message.revision = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.revision);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 4:
                    message.subject = SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* authzed.api.materialize.v0.PermissionChange.Permissionship permissionship */ 5:
                    message.permissionship = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken revision = 1; */
        if (message.revision)
            ZedToken.internalBinaryWrite(message.revision, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 4; */
        if (message.subject)
            SubjectReference.internalBinaryWrite(message.subject, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.materialize.v0.PermissionChange.Permissionship permissionship = 5; */
        if (message.permissionship !== 0)
            writer.tag(5, WireType.Varint).int32(message.permissionship);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.PermissionChange
 */
export const PermissionChange = new PermissionChange$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.materialize.v0.WatchPermissionsService
 */
export const WatchPermissionsService = new ServiceType("authzed.api.materialize.v0.WatchPermissionsService", [
    { name: "WatchPermissions", serverStreaming: true, options: {}, I: WatchPermissionsRequest, O: WatchPermissionsResponse }
]);
