// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "authzed/api/materialize/v0/watchpermissionsets.proto" (package "authzed.api.materialize.v0", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ZedToken } from "../../v1/core.js";
/**
 * @generated from protobuf message authzed.api.materialize.v0.WatchPermissionSetsRequest
 */
export interface WatchPermissionSetsRequest {
    /**
     * optional_starting_after is used to specify the SpiceDB revision to start watching from.
     * If not specified, the watch will start from the current SpiceDB revision time of the request ("head revision").
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken optional_starting_after = 1;
     */
    optionalStartingAfter?: ZedToken;
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.WatchPermissionSetsResponse
 */
export interface WatchPermissionSetsResponse {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "change";
        /**
         * change is the permission set delta that has occurred as result of a mutation in origin SpiceDB.
         * The consumer should apply this change to the current state of the permission sets in their target system.
         * Once an event arrives with completed_revision instead, the consumer shall consider the set of
         * changes originating from that revision completed.
         *
         * The consumer should keep track of the revision in order to resume streaming in the event of consumer restarts.
         *
         * @generated from protobuf field: authzed.api.materialize.v0.PermissionSetChange change = 1;
         */
        change: PermissionSetChange;
    } | {
        oneofKind: "completedRevision";
        /**
         * completed_revision is the revision token that indicates the completion of a set of changes. It may also be
         * received without accompanying set of changes, indicating that a mutation in the origin SpiceDB cluster did
         * not yield any effective changes in the permission sets
         *
         * @generated from protobuf field: authzed.api.v1.ZedToken completed_revision = 2;
         */
        completedRevision: ZedToken;
    } | {
        oneofKind: "lookupPermissionSetsRequired";
        /**
         * lookup_permission_sets_required is a signal that the consumer should perform a LookupPermissionSets call because
         * the permission set snapshot needs to be rebuilt from scratch. This typically happens when the origin SpiceDB
         * cluster has seen its schema changed.
         *
         * @generated from protobuf field: authzed.api.materialize.v0.LookupPermissionSetsRequired lookup_permission_sets_required = 3;
         */
        lookupPermissionSetsRequired: LookupPermissionSetsRequired;
    } | {
        oneofKind: "breakingSchemaChange";
        /**
         * breaking_schema_change is a signal that a breaking schema change has been written to the origin SpiceDB cluster,
         * and that the consumer should expect delays in the ingestion of new changes,
         * because the permission set snapshot needs to be rebuilt from scratch. Once the snapshot is ready, the consumer
         * will receive a LookupPermissionSetsRequired event.
         *
         * @generated from protobuf field: authzed.api.materialize.v0.BreakingSchemaChange breaking_schema_change = 4;
         */
        breakingSchemaChange: BreakingSchemaChange;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.Cursor
 */
export interface Cursor {
    /**
     * limit is the number of permission sets to stream over a single LookupPermissionSets call that was requested.
     *
     * @generated from protobuf field: uint32 limit = 1;
     */
    limit: number;
    /**
     * token is the snapshot revision at which the cursor was computed.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken token = 4;
     */
    token?: ZedToken;
    /**
     * starting_index is an offset of the permission set represented by this cursor
     *
     * @generated from protobuf field: uint32 starting_index = 5;
     */
    startingIndex: number;
    /**
     * completed_members is a boolean flag that indicates that the cursor has reached the end of the permission sets
     *
     * @generated from protobuf field: bool completed_members = 6;
     */
    completedMembers: boolean;
    /**
     * starting_key is a string cursor used by some backends to resume the stream from a specific point.
     *
     * @generated from protobuf field: string starting_key = 7;
     */
    startingKey: string;
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.LookupPermissionSetsRequest
 */
export interface LookupPermissionSetsRequest {
    /**
     * limit is the number of permission sets to stream over a single LookupPermissionSets. Once the limit is reached,
     * the server will close the stream. If more permission sets are available, the consume should open a new stream
     * providing optional_starting_after_cursor, using the cursor from the last response.
     *
     * @generated from protobuf field: uint32 limit = 1;
     */
    limit: number;
    /**
     * optional_at_revision specifies the client is requesting to lookup PermissionSets at a specific revision. It's
     * optional, and if not provided, PermissionSets will be looked up at the current revision. The cursor always
     * takes precedence in defining the revision when present.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken optional_at_revision = 2;
     */
    optionalAtRevision?: ZedToken;
    /**
     * optional_starting_after_cursor is used to specify the offset to start streaming permission sets from.
     *
     * @generated from protobuf field: authzed.api.materialize.v0.Cursor optional_starting_after_cursor = 4;
     */
    optionalStartingAfterCursor?: Cursor;
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.LookupPermissionSetsResponse
 */
export interface LookupPermissionSetsResponse {
    /**
     * change represents the permission set delta necessary to transition an uninitialized target system to
     * a specific snapshot revision. In practice it's not different from the WatchPermissionSetsResponse.change, except
     * all changes will be of time SET_OPERATION_ADDED because it's assumed there is no known previous state.
     *
     * Applying the deltas to a previously initialized target system would yield incorrect results.
     *
     * @generated from protobuf field: authzed.api.materialize.v0.PermissionSetChange change = 1;
     */
    change?: PermissionSetChange;
    /**
     * cursor points to a specific permission set in a revision.
     * The consumer should keep track of the cursor in order to resume streaming in the event of consumer restarts. This
     * is particularly important in backfill scenarios that may take hours or event days to complete.
     *
     * @generated from protobuf field: authzed.api.materialize.v0.Cursor cursor = 2;
     */
    cursor?: Cursor;
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.PermissionSetChange
 */
export interface PermissionSetChange {
    /**
     * revision represents the revision at which the permission set change occurred.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken at_revision = 1;
     */
    atRevision?: ZedToken;
    /**
     * operation represents the type of set operation that took place as part of the change
     *
     * @generated from protobuf field: authzed.api.materialize.v0.PermissionSetChange.SetOperation operation = 2;
     */
    operation: PermissionSetChange_SetOperation;
    /**
     * parent_set represents the permission set parent of either another set or a member
     *
     * @generated from protobuf field: authzed.api.materialize.v0.SetReference parent_set = 3;
     */
    parentSet?: SetReference;
    /**
     * @generated from protobuf oneof: child
     */
    child: {
        oneofKind: "childSet";
        /**
         * child_set represents the scenario where another set is considered member of the parent set
         *
         * @generated from protobuf field: authzed.api.materialize.v0.SetReference child_set = 4;
         */
        childSet: SetReference;
    } | {
        oneofKind: "childMember";
        /**
         * child_member represents the scenario where an specific object is considered member of the parent set
         *
         * @generated from protobuf field: authzed.api.materialize.v0.MemberReference child_member = 5;
         */
        childMember: MemberReference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum authzed.api.materialize.v0.PermissionSetChange.SetOperation
 */
export enum PermissionSetChange_SetOperation {
    /**
     * @generated from protobuf enum value: SET_OPERATION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SET_OPERATION_ADDED = 1;
     */
    ADDED = 1,
    /**
     * @generated from protobuf enum value: SET_OPERATION_REMOVED = 2;
     */
    REMOVED = 2
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.SetReference
 */
export interface SetReference {
    /**
     * object_type is the type of object in a permission set
     *
     * @generated from protobuf field: string object_type = 1;
     */
    objectType: string;
    /**
     * object_id is the ID of a permission set
     *
     * @generated from protobuf field: string object_id = 2;
     */
    objectId: string;
    /**
     * permission_or_relation is the permission or relation referenced by this permission set
     *
     * @generated from protobuf field: string permission_or_relation = 3;
     */
    permissionOrRelation: string;
}
/**
 * @generated from protobuf message authzed.api.materialize.v0.MemberReference
 */
export interface MemberReference {
    /**
     * object_type is the type of object of a permission set member
     *
     * @generated from protobuf field: string object_type = 1;
     */
    objectType: string;
    /**
     * object_id is the ID of a permission set member
     *
     * @generated from protobuf field: string object_id = 2;
     */
    objectId: string;
    /**
     * optional_permission_or_relation is the permission or relation referenced by this permission set member
     *
     * @generated from protobuf field: string optional_permission_or_relation = 3;
     */
    optionalPermissionOrRelation: string;
}
/**
 * LookupPermissionSetsRequired is a signal that the consumer should perform a LookupPermissionSets call because
 * the permission set snapshot needs to be rebuilt from scratch. This typically happens when the origin SpiceDB
 * cluster has seen its schema changed, see BreakingSchemaChange event.
 *
 * @generated from protobuf message authzed.api.materialize.v0.LookupPermissionSetsRequired
 */
export interface LookupPermissionSetsRequired {
    /**
     * required_lookup_at is the snapshot revision at which the permission set needs to be rebuilt to.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken required_lookup_at = 1;
     */
    requiredLookupAt?: ZedToken;
}
/**
 * BreakingSchemaChange is used to signal a breaking schema change has happened, and that the consumer should
 * expect delays in the ingestion of new changes, because the permission set snapshot needs to be rebuilt from scratch.
 * Once the snapshot is ready, the consumer will receive a LookupPermissionSetsRequired event.
 *
 * @generated from protobuf message authzed.api.materialize.v0.BreakingSchemaChange
 */
export interface BreakingSchemaChange {
    /**
     * change_at is the revision at which a breaking schema event has happened.
     *
     * @generated from protobuf field: authzed.api.v1.ZedToken change_at = 1;
     */
    changeAt?: ZedToken;
}
// @generated message type with reflection information, may provide speed optimized methods
class WatchPermissionSetsRequest$Type extends MessageType<WatchPermissionSetsRequest> {
    constructor() {
        super("authzed.api.materialize.v0.WatchPermissionSetsRequest", [
            { no: 1, name: "optional_starting_after", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<WatchPermissionSetsRequest>): WatchPermissionSetsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WatchPermissionSetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchPermissionSetsRequest): WatchPermissionSetsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken optional_starting_after */ 1:
                    message.optionalStartingAfter = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.optionalStartingAfter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchPermissionSetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken optional_starting_after = 1; */
        if (message.optionalStartingAfter)
            ZedToken.internalBinaryWrite(message.optionalStartingAfter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.WatchPermissionSetsRequest
 */
export const WatchPermissionSetsRequest = new WatchPermissionSetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchPermissionSetsResponse$Type extends MessageType<WatchPermissionSetsResponse> {
    constructor() {
        super("authzed.api.materialize.v0.WatchPermissionSetsResponse", [
            { no: 1, name: "change", kind: "message", oneof: "response", T: () => PermissionSetChange },
            { no: 2, name: "completed_revision", kind: "message", oneof: "response", T: () => ZedToken },
            { no: 3, name: "lookup_permission_sets_required", kind: "message", oneof: "response", T: () => LookupPermissionSetsRequired },
            { no: 4, name: "breaking_schema_change", kind: "message", oneof: "response", T: () => BreakingSchemaChange }
        ]);
    }
    create(value?: PartialMessage<WatchPermissionSetsResponse>): WatchPermissionSetsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<WatchPermissionSetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchPermissionSetsResponse): WatchPermissionSetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.materialize.v0.PermissionSetChange change */ 1:
                    message.response = {
                        oneofKind: "change",
                        change: PermissionSetChange.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).change)
                    };
                    break;
                case /* authzed.api.v1.ZedToken completed_revision */ 2:
                    message.response = {
                        oneofKind: "completedRevision",
                        completedRevision: ZedToken.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).completedRevision)
                    };
                    break;
                case /* authzed.api.materialize.v0.LookupPermissionSetsRequired lookup_permission_sets_required */ 3:
                    message.response = {
                        oneofKind: "lookupPermissionSetsRequired",
                        lookupPermissionSetsRequired: LookupPermissionSetsRequired.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).lookupPermissionSetsRequired)
                    };
                    break;
                case /* authzed.api.materialize.v0.BreakingSchemaChange breaking_schema_change */ 4:
                    message.response = {
                        oneofKind: "breakingSchemaChange",
                        breakingSchemaChange: BreakingSchemaChange.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).breakingSchemaChange)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchPermissionSetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.materialize.v0.PermissionSetChange change = 1; */
        if (message.response.oneofKind === "change")
            PermissionSetChange.internalBinaryWrite(message.response.change, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken completed_revision = 2; */
        if (message.response.oneofKind === "completedRevision")
            ZedToken.internalBinaryWrite(message.response.completedRevision, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.materialize.v0.LookupPermissionSetsRequired lookup_permission_sets_required = 3; */
        if (message.response.oneofKind === "lookupPermissionSetsRequired")
            LookupPermissionSetsRequired.internalBinaryWrite(message.response.lookupPermissionSetsRequired, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.materialize.v0.BreakingSchemaChange breaking_schema_change = 4; */
        if (message.response.oneofKind === "breakingSchemaChange")
            BreakingSchemaChange.internalBinaryWrite(message.response.breakingSchemaChange, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.WatchPermissionSetsResponse
 */
export const WatchPermissionSetsResponse = new WatchPermissionSetsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cursor$Type extends MessageType<Cursor> {
    constructor() {
        super("authzed.api.materialize.v0.Cursor", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "token", kind: "message", T: () => ZedToken },
            { no: 5, name: "starting_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "completed_members", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "starting_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Cursor>): Cursor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.startingIndex = 0;
        message.completedMembers = false;
        message.startingKey = "";
        if (value !== undefined)
            reflectionMergePartial<Cursor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cursor): Cursor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* authzed.api.v1.ZedToken token */ 4:
                    message.token = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.token);
                    break;
                case /* uint32 starting_index */ 5:
                    message.startingIndex = reader.uint32();
                    break;
                case /* bool completed_members */ 6:
                    message.completedMembers = reader.bool();
                    break;
                case /* string starting_key */ 7:
                    message.startingKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cursor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* authzed.api.v1.ZedToken token = 4; */
        if (message.token)
            ZedToken.internalBinaryWrite(message.token, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 starting_index = 5; */
        if (message.startingIndex !== 0)
            writer.tag(5, WireType.Varint).uint32(message.startingIndex);
        /* bool completed_members = 6; */
        if (message.completedMembers !== false)
            writer.tag(6, WireType.Varint).bool(message.completedMembers);
        /* string starting_key = 7; */
        if (message.startingKey !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.startingKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.Cursor
 */
export const Cursor = new Cursor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupPermissionSetsRequest$Type extends MessageType<LookupPermissionSetsRequest> {
    constructor() {
        super("authzed.api.materialize.v0.LookupPermissionSetsRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "optional_at_revision", kind: "message", T: () => ZedToken },
            { no: 4, name: "optional_starting_after_cursor", kind: "message", T: () => Cursor }
        ]);
    }
    create(value?: PartialMessage<LookupPermissionSetsRequest>): LookupPermissionSetsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<LookupPermissionSetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupPermissionSetsRequest): LookupPermissionSetsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* authzed.api.v1.ZedToken optional_at_revision */ 2:
                    message.optionalAtRevision = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.optionalAtRevision);
                    break;
                case /* authzed.api.materialize.v0.Cursor optional_starting_after_cursor */ 4:
                    message.optionalStartingAfterCursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.optionalStartingAfterCursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupPermissionSetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* authzed.api.v1.ZedToken optional_at_revision = 2; */
        if (message.optionalAtRevision)
            ZedToken.internalBinaryWrite(message.optionalAtRevision, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.materialize.v0.Cursor optional_starting_after_cursor = 4; */
        if (message.optionalStartingAfterCursor)
            Cursor.internalBinaryWrite(message.optionalStartingAfterCursor, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.LookupPermissionSetsRequest
 */
export const LookupPermissionSetsRequest = new LookupPermissionSetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupPermissionSetsResponse$Type extends MessageType<LookupPermissionSetsResponse> {
    constructor() {
        super("authzed.api.materialize.v0.LookupPermissionSetsResponse", [
            { no: 1, name: "change", kind: "message", T: () => PermissionSetChange },
            { no: 2, name: "cursor", kind: "message", T: () => Cursor }
        ]);
    }
    create(value?: PartialMessage<LookupPermissionSetsResponse>): LookupPermissionSetsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LookupPermissionSetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupPermissionSetsResponse): LookupPermissionSetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.materialize.v0.PermissionSetChange change */ 1:
                    message.change = PermissionSetChange.internalBinaryRead(reader, reader.uint32(), options, message.change);
                    break;
                case /* authzed.api.materialize.v0.Cursor cursor */ 2:
                    message.cursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.cursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupPermissionSetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.materialize.v0.PermissionSetChange change = 1; */
        if (message.change)
            PermissionSetChange.internalBinaryWrite(message.change, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.materialize.v0.Cursor cursor = 2; */
        if (message.cursor)
            Cursor.internalBinaryWrite(message.cursor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.LookupPermissionSetsResponse
 */
export const LookupPermissionSetsResponse = new LookupPermissionSetsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionSetChange$Type extends MessageType<PermissionSetChange> {
    constructor() {
        super("authzed.api.materialize.v0.PermissionSetChange", [
            { no: 1, name: "at_revision", kind: "message", T: () => ZedToken },
            { no: 2, name: "operation", kind: "enum", T: () => ["authzed.api.materialize.v0.PermissionSetChange.SetOperation", PermissionSetChange_SetOperation, "SET_OPERATION_"] },
            { no: 3, name: "parent_set", kind: "message", T: () => SetReference },
            { no: 4, name: "child_set", kind: "message", oneof: "child", T: () => SetReference },
            { no: 5, name: "child_member", kind: "message", oneof: "child", T: () => MemberReference }
        ]);
    }
    create(value?: PartialMessage<PermissionSetChange>): PermissionSetChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operation = 0;
        message.child = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PermissionSetChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionSetChange): PermissionSetChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken at_revision */ 1:
                    message.atRevision = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.atRevision);
                    break;
                case /* authzed.api.materialize.v0.PermissionSetChange.SetOperation operation */ 2:
                    message.operation = reader.int32();
                    break;
                case /* authzed.api.materialize.v0.SetReference parent_set */ 3:
                    message.parentSet = SetReference.internalBinaryRead(reader, reader.uint32(), options, message.parentSet);
                    break;
                case /* authzed.api.materialize.v0.SetReference child_set */ 4:
                    message.child = {
                        oneofKind: "childSet",
                        childSet: SetReference.internalBinaryRead(reader, reader.uint32(), options, (message.child as any).childSet)
                    };
                    break;
                case /* authzed.api.materialize.v0.MemberReference child_member */ 5:
                    message.child = {
                        oneofKind: "childMember",
                        childMember: MemberReference.internalBinaryRead(reader, reader.uint32(), options, (message.child as any).childMember)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionSetChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken at_revision = 1; */
        if (message.atRevision)
            ZedToken.internalBinaryWrite(message.atRevision, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.materialize.v0.PermissionSetChange.SetOperation operation = 2; */
        if (message.operation !== 0)
            writer.tag(2, WireType.Varint).int32(message.operation);
        /* authzed.api.materialize.v0.SetReference parent_set = 3; */
        if (message.parentSet)
            SetReference.internalBinaryWrite(message.parentSet, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.materialize.v0.SetReference child_set = 4; */
        if (message.child.oneofKind === "childSet")
            SetReference.internalBinaryWrite(message.child.childSet, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.materialize.v0.MemberReference child_member = 5; */
        if (message.child.oneofKind === "childMember")
            MemberReference.internalBinaryWrite(message.child.childMember, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.PermissionSetChange
 */
export const PermissionSetChange = new PermissionSetChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReference$Type extends MessageType<SetReference> {
    constructor() {
        super("authzed.api.materialize.v0.SetReference", [
            { no: 1, name: "object_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "permission_or_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetReference>): SetReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectType = "";
        message.objectId = "";
        message.permissionOrRelation = "";
        if (value !== undefined)
            reflectionMergePartial<SetReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReference): SetReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_type */ 1:
                    message.objectType = reader.string();
                    break;
                case /* string object_id */ 2:
                    message.objectId = reader.string();
                    break;
                case /* string permission_or_relation */ 3:
                    message.permissionOrRelation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_type = 1; */
        if (message.objectType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectType);
        /* string object_id = 2; */
        if (message.objectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.objectId);
        /* string permission_or_relation = 3; */
        if (message.permissionOrRelation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permissionOrRelation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.SetReference
 */
export const SetReference = new SetReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemberReference$Type extends MessageType<MemberReference> {
    constructor() {
        super("authzed.api.materialize.v0.MemberReference", [
            { no: 1, name: "object_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "optional_permission_or_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MemberReference>): MemberReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectType = "";
        message.objectId = "";
        message.optionalPermissionOrRelation = "";
        if (value !== undefined)
            reflectionMergePartial<MemberReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberReference): MemberReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_type */ 1:
                    message.objectType = reader.string();
                    break;
                case /* string object_id */ 2:
                    message.objectId = reader.string();
                    break;
                case /* string optional_permission_or_relation */ 3:
                    message.optionalPermissionOrRelation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemberReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_type = 1; */
        if (message.objectType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectType);
        /* string object_id = 2; */
        if (message.objectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.objectId);
        /* string optional_permission_or_relation = 3; */
        if (message.optionalPermissionOrRelation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.optionalPermissionOrRelation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.MemberReference
 */
export const MemberReference = new MemberReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupPermissionSetsRequired$Type extends MessageType<LookupPermissionSetsRequired> {
    constructor() {
        super("authzed.api.materialize.v0.LookupPermissionSetsRequired", [
            { no: 1, name: "required_lookup_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<LookupPermissionSetsRequired>): LookupPermissionSetsRequired {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LookupPermissionSetsRequired>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupPermissionSetsRequired): LookupPermissionSetsRequired {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken required_lookup_at */ 1:
                    message.requiredLookupAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.requiredLookupAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupPermissionSetsRequired, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken required_lookup_at = 1; */
        if (message.requiredLookupAt)
            ZedToken.internalBinaryWrite(message.requiredLookupAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.LookupPermissionSetsRequired
 */
export const LookupPermissionSetsRequired = new LookupPermissionSetsRequired$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreakingSchemaChange$Type extends MessageType<BreakingSchemaChange> {
    constructor() {
        super("authzed.api.materialize.v0.BreakingSchemaChange", [
            { no: 1, name: "change_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<BreakingSchemaChange>): BreakingSchemaChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BreakingSchemaChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BreakingSchemaChange): BreakingSchemaChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken change_at */ 1:
                    message.changeAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.changeAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BreakingSchemaChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken change_at = 1; */
        if (message.changeAt)
            ZedToken.internalBinaryWrite(message.changeAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.materialize.v0.BreakingSchemaChange
 */
export const BreakingSchemaChange = new BreakingSchemaChange$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.materialize.v0.WatchPermissionSetsService
 */
export const WatchPermissionSetsService = new ServiceType("authzed.api.materialize.v0.WatchPermissionSetsService", [
    { name: "WatchPermissionSets", serverStreaming: true, options: {}, I: WatchPermissionSetsRequest, O: WatchPermissionSetsResponse },
    { name: "LookupPermissionSets", serverStreaming: true, options: {}, I: LookupPermissionSetsRequest, O: LookupPermissionSetsResponse }
]);
